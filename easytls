#!/bin/sh

# Copyright - negotiable
copyright ()
{
cat << VERBATUM_COPYRIGHT_HEADER_INCLUDE_NEGOTIABLE
# Easy-TLS -- A Shell-based Easy-RSA extension utility to help manage
#               * OpenVPN specific TLS keys
#               * Easy-RSA based x509 security credentials
#               * Verified 'inline' combined OpenVPN node packages
#
# Copyright (C) 2020 Richard Bonhomme (Friday 13th of March 2020)
# https://github.com/TinCanTech/easy-tls
# tincanteksup@gmail.com
# All Rights reserved.
#
# This code is released under version 2 of the GNU GPL
# See LICENSE of this project for full licensing details.
#
# Acknowledgement:
# This utility is "written in the style of" and "borrows heavily from" Easy-RSA
# See: https://github.com/OpenVPN/easy-rsa
#
VERBATUM_COPYRIGHT_HEADER_INCLUDE_NEGOTIABLE
}

# Easy-TLS requirements:
# + Easy-RSA Version 3.X
# + OpenVPN Version 2.X
#


# Help/usage output to stdout
usage()
{
	# command help:
	print "
Easy-TLS usage and overview

USAGE: easytls [options] COMMAND [command-options]

A list of commands is shown below. To get detailed usage and help for a
command, run:
  ./easytls help COMMAND

For a listing of options that can be supplied before the command, use:
  ./easytls help options

Here is the list of commands available with a short syntax reminder.
Use the 'help' command above to get full usage details.

  init-tls
  build-tls-auth
  build-tls-crypt
  build-tls-crypt-v2-server <filename_base>
  build-tls-crypt-v2-client <server_filename_base> <client_filename_base>
  inline-base <filename_base> [ cmd-opts ]
  inline-tls-auth <filename_base> <key_direction> [ cmd-opts ]
  inline-tls-crypt <filename_base> [ cmd-opts ]
  inline-tls-crypt-v2 <filename_base> [ cmd-opts ]
  inline-remove <filename_base>
  inline-renew <filename_base> [ cmd-opts ]
  inline-status [ cmd-opts ]
  inline-show <filename_base>
  inline-index-rebuild
  cert-expire <filename_base> | <ca>
  disable <filename_base>
  enable <filename_base>

NOTE: Easy-TLS requires that you have a working EasyRSA PKI in place.
NOTE: Easy-TLS requires that you have OpenVPN installed.
"

	# collect/show dir status:
	err_source="Not defined: vars autodetect failed and no value provided"
	work_dir="${EASYRSA:-$err_source}"
	pki_dir="${EASYRSA_PKI:-$err_source}"
	tls_dir="${EASYTLS_PKI:-$err_source}"
	print "\
DIRECTORY STATUS (commands would take effect on these locations)
  EASYRSA: $work_dir
      PKI: $pki_dir
      TLS: $tls_dir"
EASYTLS_SILENT=1
} # => usage()

# Detailed command help
# When called with no args, calls usage(), otherwise shows help for a command
cmd_help()
{
	text=""
	opts=""
	case "$1" in
		init-tls) text="
  init-tls
      Removes & re-initializes the TLS key dir" ;;
		build-tls-auth) text="
  build-tls-auth
      Create an OpenVPN TLS auth PSK (tls-auth.key)" ;;
		build-tls-crypt) text="
  build-tls-crypt
      Create an OpenVPN TLS crypt PSK (tls-crypt.key)" ;;
		build-tls-crypt-v2-server) text="
  build-tls-crypt-v2-server <server_filename_base>
      Create an OpenVPN TLS crypt V2 Server key" ;;
		build-tls-crypt-v2-client) text="
  build-tls-crypt-v2-client <server_filename_base> <client_filename_base>
      Create an OpenVPN TLS crypt V2 Client key" ;;
		inline-base) text="
  inline-base <filename_base> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA files only
      for VPN node <filename_base>"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-tls-auth) text="
  inline-tls-auth <filename_base> <key_direction> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS auth file
      <key_direction> '0' or '1'
      (If key-direction is omitted then do not add key-direction to inline file)"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-tls-crypt) text="
  inline-tls-crypt <filename_base> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS crypt file"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-tls-crypt-v2) text="
  inline-tls-crypt-v2 <filename_base> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS crypt v2 file"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-remove) text="
  inline-remove <filename_base>
      Delete <filename_base>.inline when Easy-RSA certificate is revoked" ;;
		inline-renew) text="
  inline-renew <filename_base> [ cmd-opts ]
      Renew <filename_base>.inline when Easy-RSA certificate is renewed"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-status) text="
  inline-status [ cmd-opts ]
      Compare Easy-RSA certificate(s) to Easy-TLS inline(s) status"
			opts="
	valid   - List only Easy-RSA valid certificates
	revoked - List only Easy-RSA revoked certificates
	inline  - List only Easy-TLS inline files
	invalid - List only Easy-TLS invalid inline files" ;;
		inline-show) text="
  inline-show <filename_base>
      Copy <filename_base>.inline to stdout" ;;
		inline-index-rebuild) text="
  inline-index-rebuild
      Rebuild easytls-index.txt
      If you need to do this then you may have found a bug, please
      raise an issue https://github.com/TinCanTech/easy-tls/issues" ;;
		cert-expire) text="
  cert-expire <filename_base> | <ca>
      Display certificate expiry date for <filename_base>"
			opts="
        If <filename_base> is 'ca' then show ca.crt expiry
        If no <filename_base> is given then list all certificate expiry dates" ;;
		disable) text="
  disable <filename_base>
      Add serial number for <filename_base> to the disabled list
      for immediate use by the tls-crypt-v2-verify script" ;;
		enable) text="
  enable <filename_base>
      Remove serial number for <filename_base> from the disabled list
      for immediate use by the tls-crypt-v2-verify script" ;;
		options)
			opt_usage ;;
		"")
			usage ;;
		*) text="
  Unknown command: '$1' (try without commands for a list of commands)" ;;
	esac

	# display the help text
	print "$text"
	[ -n "$opts" ] && print "
      cmd-opts is an optional set of command options from this list:
$opts"
} # => cmd_help()

# Options usage
opt_usage()
{
	print "
Easy-TLS Global Option Flags

The following options may be provided before the command. Options specified
at runtime override env-vars and any 'vars' file in use. Unless noted,
non-empty values to options are mandatory.

General options:

--batch         : set automatic (no-prompts when possible) mode
--silent        : Silence all message output except prompts
--pki-dir=DIR   : declare the EasyRSA PKI directory
--vars=FILE     : define a specific 'vars' file to use for Easy-RSA config
--dh=FILE       : define an alternate Diffy Hellman parameters file
--custom-group  : Append a custom field to the default TLS crypt v2 metadata
                  This field can also be matched in tls-crypt-v2-verify.sh
                  with the command line option: -g|--custom-group XYZ
                  XYZ MUST be a single alphanumerical word with NO spaces"
EASYTLS_SILENT=1
} # => opt_usage()

# Wrapper around printf - clobber print since it's not POSIX anyway
print() { printf "%s\n" "$*"; }

# Exit fatally with a message to stderr
# present even with EASYTLS_BATCH as these are fatal problems
die()
{
	easy_tls_version
	print "
Easy-TLS error:

$help_note

$1" 1>&2
	exit "${2:-1}"
} # => die()

# remove temp files and do terminal cleanups
cleanup()
{
	[ -z "$EASYRSA_TEMP_DIR_session" ] || rm -rf "$EASYRSA_TEMP_DIR_session"
	(stty echo 2>/dev/null) || { (set -o echo 2>/dev/null) && set -o echo; }
	[ $EASYTLS_SILENT ] || echo "" # just to get a clean line
} # => cleanup()

# non-fatal warning output
warn()
{
	[ "$EASYTLS_SILENT" ] && return 0
		print "
$1" 1>&2
} # => warn()

# informational notices to stdout
notice()
{
	[ "$EASYTLS_SILENT" ] && return 0
		print "
$1"
} # => notice()

# intent confirmation helper func
# returns without prompting in EASYTLS_BATCH
confirm()
{
	[ "$EASYTLS_BATCH" ] && return
	prompt="$1"
	value="$2"
	msg="$3"
	input=""
	print "
$msg

Type the word '$value' to continue, or any other input to abort."
	printf %s "  $prompt"
	read input
	[ "$input" = "$value" ] && return
	notice "Aborting without confirmation."
	exit 9
} # => confirm()

vars_source_check() {
	# Check for defined EASYRSA_PKI
	[ -n "$EASYRSA_PKI" ] || die "\
EASYRSA_PKI env-var undefined"
} # => vars_source_check()

# Basic sanity-check of PKI init and complain if missing
verify_pki_init () {
	help_note="Run easyrsa without commands for usage and command help."

	# check that the pki dir exists
	vars_source_check
	[ -d "$EASYRSA_PKI" ] || die "\
Easy-TLS requires that you have initialised your Easy-RSA PKI.

Easy-RSA error:

EASYRSA_PKI does not exist (perhaps you need to run init-pki)?
Expected to find the EASYRSA_PKI at: $EASYRSA_PKI
$help_note"

	# verify expected dirs present:
	for i in private reqs; do
		[ -d "$EASYRSA_PKI/$i" ] || die "\
Easy-TLS requires that you have initialised your Easy-RSA PKI.

Easy-RSA error:

Missing expected directory: $i (perhaps you need to run init-pki?)
$help_note"
	done
} # => verify_pki_init()

# Verify core CA files present
verify_ca_init () {
	help_note="Run without commands for usage and command help."

	# First check the PKI has been initialized
	verify_pki_init

	# Verify expected files are present. Allow files to be regular files
	# (or symlinks), but also pipes, for flexibility with ca.key
	for i in serial index.txt index.txt.attr ca.crt private/ca.key; do
		if [ ! -f "$EASYRSA_PKI/$i" ] && [ ! -p "$EASYRSA_PKI/$i" ]; then
			#[ "$1" = "test" ] && return 1
			die "\
Easy-TLS TLS-crypt-v2 requires that you have built your EASY-RSA PKI.

Easy-RSA error:

Missing expected CA file: $i (perhaps you need to run build-ca?)
$help_note"
		fi
	done

	# When operating in 'test' mode, return success.
	# test callers don't care about CA-specific dir structure
	#[ "$1" = "test" ] && return 0

	# verify expected CA-specific dirs:
	for i in issued certs_by_serial
	do
		[ -d "$EASYRSA_PKI/$i" ] || die "\
Easy-TLS TLS-crypt-v2 requires that you have built your EASY-RSA PKI.

Easy-RSA error:

Missing expected CA dir: $i (perhaps you need to run build-ca?)
$help_note"
	done

	# explicitly return success for callers
	return 0

} # => verify_ca_init()

############################################################################
#
# EASYTLS MANGEMENT Section
#

# Verify Openvpn is available
verify_openvpn ()
{
	[ -f "$EASYTLS_OPENVPN" ] || die "OpenVPN not found: $EASYTLS_OPENVPN"
	ovpn_test="$("$EASYTLS_OPENVPN" --version|grep ^OpenV|awk '{print $1}')"
	[ "$ovpn_test" = "OpenVPN" ] || die "OpenVPN invalid: $EASYTLS_OPENVPN"
	# explicitly return success for callers
	return 0
} # => verify_openvpn ()

# Verify Openvpn version
# 2.5 required for TLS crypt v2
# 2.4 required for TLS crypt v1
verify_openvpn_version ()
{
	[ $# -ge 1 ] || die "Required option(s): <ovpn_ver_req_maj>"

	Ver_req_maj="$1"
	Ver_str="$("$EASYTLS_OPENVPN" --version|grep ^OpenVPN|awk '{print $2}')"

	Ver_ints="$(printf "%s" "$Ver_str" | sed "s/[^0123456789]/\ /g")"

	Ver_main="$(printf "%s" "$Ver_ints" | awk '{print $1}')"
	Ver_major="$(printf "%s" "$Ver_ints" | awk '{print $2}')"
	Ver_minor="$(printf "%s" "$Ver_ints" | awk '{print $3}')"

	Ver_main="${Ver_main:-0}"
	Ver_major="${Ver_major:-0}"
	Ver_minor="${Ver_minor:-0}"

	[ $Ver_main -lt 2 ] && die "Openvpn 2.5 required, Found $Ver_str"
	[ $Ver_major -lt $Ver_req_maj ] && \
		die "Openvpn 2.$Ver_req_maj required, Found $Ver_str"
	[ $Ver_minor -lt 0 ] && die "Openvpn 2 required, Found $Ver_str"

	# explicitly return success for callers
	# because reasons..
	return 0

} # => verify_openvpn_version ()

# Verify TLS has been initialised
verify_tls_init ()
{
	[ -d "$EASYTLS_PKI" ] || die "EasyTLS has not been initialised"
	[ -f "$EASYTLS_INLINE_INDEX" ] || die "EasyTLS has not been initialised"
	[ -f "$EASYTLS_DISABLED_LIST" ] || die "EasyTLS has not been initialised"
	verify_openvpn
} # => verify_tls_init ()

# init-tls backend:
init_tls ()
{
	# Easy-TLS requires that your Easy-RSA PKI is initialised
	verify_pki_init
	# If EASYTLS_PKI exists, confirm before we rm -rf
	# skipped with EASYTLS_BATCH
	if [ -d "$EASYTLS_PKI" ]; then
		confirm "Confirm removal: " "yes" "
WARNING!!!

You are about to remove the EASYTLS_PKI at: $EASYTLS_PKI
and initialize a fresh TLS PKI here."
		# now remove it:
		rm -rf "$EASYTLS_PKI" \
		|| die "Removal of TLS dir failed. Check/correct errors above"
	fi

	# Create tls dir in Easyrsa PKI dir
	mkdir -p "$EASYTLS_PKI" || die "Failed to create TLS dir (permissions?)"

	# Create tls dir index file
	printf "%s" "" > "$EASYTLS_INLINE_INDEX" \
		|| die "Failed to create $EASYTLS_INLINE_INDEX (permissions?)"

	# Create disabled list
	head_text="# OpenVPN Server tls-crypt-v2-verify.sh disabled list"
	date_text="# Created: $(date)"
	printf "%s\n%s\n" "$head_text" "$date_text" > "$EASYTLS_DISABLED_LIST" \
		|| die "Failed to create disabled list"

	notice "\
init-tls complete; you may now create TLS keys and .inline files.
Your newly created TLS dir is: $EASYTLS_PKI
"
	return 0
} # => init_tls ()

# Auto-check for invalid inline files
# Run on exit to avoid "checken and egg" with init-tls
inline_auto_check ()
{
	auto_check=1
	inline_status invalid
	[ $mismatch_count -eq 0 ] || \
		warn "EasyTLS: Invalid .inline files found."
	unset auto_check
}

# Show Easy-TLS inlines and Easy-RSA certificates
# Report invalid inline files due to certificate revokation
inline_status ()
{
	subsection="$1"

	verify_ca_init

	ersa_valid_cn_list=""
	ersa_valid_serial_list=""
	ersa_revoked_cn_list=""
	ersa_revoked_serial_list=""
	#easytls_valid_cn_list=""
	etls_valid_serial_list=""
	#easytls_revoked_serial_list="" # Not used

	if [ -n "$subsection" ]
	then
		#EASYTLS_SILENT=1
		case "$subsection" in
		valid)
				status_easyrsa_valid ;;
		revoked)
				status_easyrsa_revoked ;;
		inline)
				verify_tls_init
				status_easytls_inline ;;
		invalid)
				silent_status=1
				status_easyrsa_valid
				status_easyrsa_revoked
				verify_tls_init
				status_easytls_inline
				status_easytls_invalid
				unset silent_status
				;;
		*)		print "Unknown status option" ;;
		esac
		#unset EASYTLS_SILENT
		return 0
	fi

	print "Easy-RSA: Valid certificates:"
	status_easyrsa_valid

	print "Easy-RSA: Revoked certificates:"
	status_easyrsa_revoked

	verify_tls_init

	print "Easy-TLS: Known inline files:"
	status_easytls_inline

	#print "Easy-TLS: Revoked inline files:"
	#status_easytls_revoked

	print "Easy-TLS: Invalid inline files:"
	status_easytls_invalid

} #=> inline_status ()

# Format inline_status output
status_output ()
{
	awk '{print "  Common-Name " $1 "    Serial-number " $2}'
}

# Format inline_status CN
status_cn ()
{
	sed -e "s\`^.*/CN=\`\`g" -e "s\`/.*$\`\`g"
}

# Extract Valid records from openssl index.txt
status_valid_extract_cn ()
{
	grep "^V.*[[:space:]]${i}[[:space:]]" "$EASYRSA_INDEX" | status_cn
}

# Extract Revoked records from openssl index.txt
status_revoked_extract_cn ()
{
	grep "^R.*[[:space:]]${i}[[:space:]]" "$EASYRSA_INDEX" | status_cn
}

# Print Valid certs from Easy-RSA
status_easyrsa_valid ()
{
	ersa_valid_serial_list="$(grep ^V "$EASYRSA_INDEX"|awk '{ print $3 }')"
	for i in $ersa_valid_serial_list
	do
		ersa_valid_cn="$(status_valid_extract_cn)"
		ersa_valid_cn_list="$ersa_valid_cn_list $ersa_valid_cn"
		[ $silent_status ] || print "$ersa_valid_cn $i" | status_output
	done
} # => status_easyrsa_valid ()

# Print Revoked certs from Easy-RSA
status_easyrsa_revoked ()
{
	ersa_revoked_serial_list="$(grep ^R "$EASYRSA_INDEX"|awk '{ print $4 }')"
	for i in $ersa_revoked_serial_list
	do
		ersa_revoked_cn="$(status_revoked_extract_cn)"
		ersa_revoked_cn_list="$ersa_revoked_cn_list $ersa_revoked_cn"
		[ $silent_status ] || print "$ersa_revoked_cn $i" | status_output
	done
} # => status_easyrsa_revoked ()

# Print Valid certs from Easy-TLS
status_easytls_inline ()
{
	etls_valid_serial="$(awk '{ print $2 }' "$EASYTLS_INLINE_INDEX")"
	etls_valid_serial_list="$etls_valid_serial_list $etls_valid_serial"
	[ $silent_status ] || cat "$EASYTLS_INLINE_INDEX" | status_output
} # => status_easytls_valid ()

# Print Revoked certs from Easy-TLS
status_easytls_revoked ()
{
	print "  Easy-TLS does not Revoke certificates."
	print "  If the certificate has been revoked in Easy-RSA then use:"
	print "  'inline-remove <filename_base>' to delete the inline file."
} # => status_easytls_revoked ()

# Check Easy-TLS valid vs Easy-RSA revoked
status_easytls_invalid ()
{
	mismatch_count=0
	for i in $etls_valid_serial_list
	do
		crt_serial=$i
		name="$(inline_index_serial_to_common_name)"
		inline_file="$EASYTLS_PKI/$name.inline"

		inline_index_check_hash || die "Failed HASH: $inline_file"
		mismatches="$(status_search_revoked_serial_list)"
		case $mismatches in
		0)
		# No mismatches found
			:
		;;
		1)
			mismatch_count=$((mismatch_count+1))
			[ $auto_check ] || inline_status_invalid_list
		;;
		*)
			warn "EasyRSA duplicate records detected!"
			[ $((mismatches)) -gt 1 ] || \
				die "Error in mismatches: $mismatches"
		;;
		esac
	done
} # => status_easytls_mismatch

# Search ersa revoked serial list for etls valid serial
status_search_revoked_serial_list()
{
	print "$ersa_revoked_serial_list" | grep -c "^${i}$"
}

# List the invalid inline file record by serial number
inline_status_invalid_list ()
{
	grep "^${name}[[:blank:]]${i}[[:blank:]]${inline_hash}$" \
		"$EASYTLS_INLINE_INDEX" | status_output
}

# Extract enddate from certificate
crt_expire_date ()
{
	"$EASYRSA_OPENSSL" x509 -in "$crt_file" -noout -enddate | \
		sed 's/^notAfter=//'
} # => crt_expire_date ()

# Get x509 certificate expiry date
cert_expire ()
{
	crt_name="$1"

	verify_tls_init

	if [ "$crt_name" = "ca" ]
	then
		crt_file="$EASYRSA_PKI/ca.crt"
		[ -f "$crt_file" ] || die "Missing: $crt_file"
		crt_expire="$(crt_expire_date)"
		print " Certificate: ca.crt   Expire-date: $crt_expire"
	elif [ -n "$crt_name" ]
	then
		crt_file="$EASYRSA_PKI/issued/$crt_name.crt"
		[ -f "$crt_file" ] || die "Missing: $crt_file"
		crt_expire="$(crt_expire_date)"
		print " Certificate: $crt_name.crt   Expire-date: $crt_expire"
	else
		easyrsa_valid_list="$(grep ^V "$EASYRSA_INDEX"|status_cn)"

		for i in $easyrsa_valid_list
		do
			crt_file="$EASYRSA_PKI/issued/$i.crt"
			[ -f "$crt_file" ] || die "Missing: $crt_file"
			crt_expire="$(crt_expire_date)"
			print " Certificate: $i.crt   Expire-date: $crt_expire"
		done

		crt_file="$EASYRSA_PKI/ca.crt"
		[ -f "$crt_file" ] || die "Missing: $crt_file"
		crt_expire="$(crt_expire_date)"
		print " Certificate: ca.crt   Expire-date: $crt_expire"
	fi

	EASYTLS_SILENT=1
} # => cert_expire ()

# Keep an index file for inline certs to manage revoke/renew
inline_index_update ()
{
	[ $# -ge 1 ] || die "Required option(s): <update_index_action>"

	update_index_action="$1"
	[ -f "$EASYTLS_INLINE_INDEX" ] || \
		die "inline_index_update () Missing: $EASYTLS_INLINE_INDEX"

	case "$update_index_action" in
	add)
		# Create new HASH here
		inline_hash="$(openssl sha1 "$inline_file" | awk '{print $2}')"
		printf "%s\n" "$name $crt_serial $inline_hash" >> \
			"$EASYTLS_INLINE_INDEX" || \
			die "Failed to update $EASYTLS_INLINE_INDEX"
	;;
	del)
		# Check saved HASH here
		# If .inline file has been removed then this check has been run
		[ $inline_removed ] || inline_index_check_hash
		sed -i -e \
		"/^${name}[[:blank:]]${crt_serial}[[:blank:]]${inline_hash}$/d" \
			"$EASYTLS_INLINE_INDEX" || \
			die "Failed to update $EASYTLS_INLINE_INDEX"
	;;
	*)
		die "Unknown index action: $update_index_action"
	;;
	esac
} # => inline_index_update ()

# Check inline hash
inline_index_check_hash ()
{
	# This is a check so check everything here
	# every value and file must exist at this time

	[ -z "$name" ] && \
		die "inline_index_check_hash: Missing value: name"

	[ -z "$crt_serial" ] && \
		die "inline_index_check_hash: Missing value: crt_serial"

	[ -z "$inline_file" ] && \
		die "inline_index_check_hash: Missing value: inline_file"

	[ -f "$inline_file" ] || \
		die "inline_index_check_hash: Missing file: $inline_file"

	# Calculate current file HASH
	inline_hash="$(openssl sha1 "$inline_file" | awk '{print $2}')"

	# Search for calculated current HASH
	find_hash="$(inline_index_search_hash)"

	case "$find_hash" in
	0) # HASH check failed
		insert_msg="HASH incorrect for: $inline_file"
		die "$insert_msg - Expecting: $inline_hash"
	;;
	1) return 0 ;;
	*) die "HASH check: unknown error" ;;
	esac
} # => inline_index_check_hash ()

# Get serial number from inline index file using Common name as key
inline_index_common_name_to_serial ()
{
	# TODO: This could be effected by duplicate names from easyrsa
	grep "^${name}[[:blank:]].*$" \
		"$EASYTLS_INLINE_INDEX" | awk '{ print $2 }'
}

# Get Common name from inline index file using serial number as key
inline_index_serial_to_common_name ()
{
	grep "^.*[[:blank:]]${crt_serial}[[:blank:]].*$" \
		"$EASYTLS_INLINE_INDEX" | awk '{ print $1 }'
}

# Search for hash
inline_index_search_hash ()
{
	grep -c "^${name}[[:blank:]]${crt_serial}[[:blank:]]${inline_hash}$" \
		"$EASYTLS_INLINE_INDEX"
}

# Copy inline to stdout
inline_show ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	name="$1"
	inline_file="$EASYTLS_PKI/$name.inline"

	verify_tls_init
	[ -f "$inline_file" ] || die "Missing: $inline_file"
	crt_serial="$(inline_index_common_name_to_serial)"
	inline_index_check_hash || die "Failed HASH: $inline_file"
	cat "$inline_file" || die "Failed to open: $inline_file"
} # => inline_show ()

# Remove .inline file
inline_remove ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	name="$1"
	inline_file="$EASYTLS_PKI/$name.inline"

	verify_tls_init

	[ -f "$inline_file" ] || die "Missing: $inline_file"

	# Get serial number from inline file
	crt_serial="$(inline_serial_number)"

	# Confirm remove
	[ ! $silent_remove ] && \
		confirm  "Remove inline file ? " "yes" "Remove: $inline_file"

	# Check .inline HASH prior to removal
	inline_index_check_hash

	rm "$inline_file" || die "Failed to remove: $inline_file"

	inline_removed=1
	inline_index_update del

	[ ! $silent_remove ] && notice "Inline file removed: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_remove ()

# Get serial number from inline file
inline_serial_number ()
{
	grep "^# Serial number: .*$" "$inline_file" | awk '{ print $4 }'
}

# Rebuild inline index
inline_index_rebuild ()
{
	# Warn!
	confirm "Rebuild inline index file ? " "yes" \
		"WARNING: You are about to rebuild easytls-index.txt"

	# Check easytls-index.txt
	[ -f "$EASYTLS_INLINE_INDEX" ] || warn "Missing: $EASYTLS_INLINE_INDEX"

	# Do not over write current easytls-index.txt.backup
	[ -f "$EASYTLS_INLINE_INDEX.backup" ] && \
		die "Backup file already exists: $EASYTLS_INLINE_INDEX.backup"

	# Backup current easytls-index.txt
	[ -f "$EASYTLS_INLINE_INDEX" ] && \
		cp "$EASYTLS_INLINE_INDEX" "$EASYTLS_INLINE_INDEX.backup"

	# Get list of files from easytls directory
	# There is no other way to do this because we need the actual files
	etls_inline_file_list="$(ls -1 "$EASYTLS_PKI/"*".inline")"

	# Check openssl index.txt
	[ -f "$EASYRSA_INDEX" ] || die "Missing: $EASYRSA_INDEX"

	# Get list of certs from openssl index.txt
	ersa_valid_cert_list="$(inline_index_openssl_cert_list)"

	# Create new easytls index file
	printf "%s" "" > "$EASYTLS_INLINE_INDEX" \
		|| die "Failed to create $EASYTLS_INLINE_INDEX (permissions?)"

	# Create records from openssl Valid names list
	for i in $ersa_valid_cert_list
	do
		# Reset flag
		unset add_inline_record

		name="$i"
		crt_serial=""
		inline_file="$EASYTLS_PKI/$name.inline"
		crt_file="$EASYRSA_PKI/issued/$name.crt"

		# If the list contains this name but there is no cert
		# then cannot recreate easytls-index
		# The EasyRSA PKI has been tainted
		help_note="EasyRSA has a record of $name but no certificate."
		[ -f "$crt_file" ] || die "Missing crt_file: $crt_file"
		unset help_note

		# If there is an inline file for this name
		# then recreate the inline easytls-index record
		# EasyTLS User can remove/create a new inline file
		# Note: The extra space ..
		[ -f "$inline_file" ] && {
			add_inline_record=1
			etls_inline_record_list="$etls_inline_record_list $name "
			}

		# Verify the openssl cert CN
		openssl_cert_cn="$(openssl_crt_cn)"
		[ "$name" = "$openssl_cert_cn" ] || \
			die "CommonName mismatch for :$name: :$openssl_cert_cn:"

		# Get the openssl cert serial
		openssl_crt_serial

		[ $add_inline_record ] && inline_index_update add
	done

	# Create records from easytls current inline files list
	for full_file_name in $etls_inline_file_list
	do
		# Reset flag
		unset add_inline_record

		# Get name only from full file name
		# Yes, I know this is a bad idea .. raise an issue
		# https://github.com/TinCanTech/easy-tls/issues
		inline_file="$full_file_name"
		part_file_name="${full_file_name%*.inline}"
		name="${part_file_name##*/}"
		[ -f "$inline_file" ] || die "Missing: $inline_file"
		crt_serial="$(inline_serial_number)"

		# If found an un-indexed inline file then index it
		inline_file_found_indexed="$(inline_index_search_index_for_name)"
		[ $inline_file_found_indexed -eq 0 ] && add_inline_record=1

		[ $add_inline_record ] && inline_index_update add
	done

	# Verify
	inline_status

	# Inform
	notice "Inline index file successfully rebuilt: $EASYTLS_INLINE_INDEX"
} # => inline_index_rebuild

# Does this .inline file name already have an index record
inline_index_search_index_for_name ()
{
	printf '%s\n' "$etls_inline_record_list" | \
		grep -c "[[:blank:]]${name}[[:blank:]]"
}

# Dragon be here ! - Extract CN from openssl index.txt
inline_index_openssl_cert_list ()
{
	grep "^V.*$" "$EASYRSA_INDEX" | \
		sed -e "s\`^.*/CN=\`\`g" -e "s\`/emailAddress=.*$\`\`g"
}


############################################################################
#
# EASYTLS BUILD Section
#

# Renew .inline file
inline_renew ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			0|1)	key_direction="$1" ;;
			add-dh)	cmd_opts="$cmd_opts add-dh" ;;
			nokey)	cmd_opts="$cmd_opts nokey" ;;
			*)	warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	inline_file="$EASYTLS_PKI/$name.inline"
	crt_file="$EASYRSA_PKI/issued/$name.crt"

	[ -f "$inline_file" ] || die "inline_renew: Missing: $inline_file"
	[ -f "$crt_file" ] || die "inline_renew: Missing: $crt_file"
	openssl_crt_serial

	# Collect the attributes of .inline file
	inline_is_base="$(grep -c '^# File name base:.*$' "$inline_file")"
	inline_is_tlsauth="$(grep -c '^<tls-auth>$' "$inline_file")"
	inline_is_tlscrypt="$(grep -c '^<tls-crypt>$' "$inline_file")"
	inline_is_tlscryptv2="$(grep -c '^<tls-crypt-v2>$' "$inline_file")"

	# Verify .inline is valid
	[ $inline_is_base -eq 1 ] || \
		die "File is not valid .inline: $inline_file"
	one_type=$((inline_is_tlsauth+inline_is_tlscrypt+inline_is_tlscryptv2))
	[ $one_type -le 1 ] || die "File is not valid .inline: $inline_file"

	# Determine the type of .inline file
	inline_type="tls-base"
	[ $inline_is_tlsauth -eq 1 ] && inline_type="tls-auth"
	[ $inline_is_tlscrypt -eq 1 ] && inline_type="tls-crypt"
	[ $inline_is_tlscryptv2 -eq 1 ] && inline_type="tls-crypt-v2"

	# If --key-direction is specified in command line but does not match
	# current inline setting then issue a warning
	if [ "$inline_type" = "tls-auth" ] && [ $key_direction ]
	then
		# Determine inline <key-direction>
		is_key_dir="$(inline_renew_key_direction)"
		case "$is_key_dir" in
		0|1)
			# Veify if command line want to change inline
			[ $key_direction -eq $is_key_dir ] || \
			warn "Command line will change inline key-direction"
		;;
		*)
			# Assume key-direction is missing from inline
			warn "TLS-auth key-direction missing"
		;;
		esac
	fi

	# Auto-detect --key-direction if not specified in command line
	# default to current inline file or no_key_direction
	if [ "$inline_type" = "tls-auth" ] && [ ! $key_direction ]
	then
		# Determine inline <key-direction>
		is_key_dir="$(inline_renew_key_direction)"
		case "$is_key_dir" in
			0|1)	key_direction="$is_key_dir" ;;
			*)	warn "TLS-auth key-direction missing" ;;
		esac
	fi

	# Confirm renew type
	confirm "Renew inline file ? " "yes" \
		"Renew: $inline_file as Type: $inline_type"

	# Make a backup of inline file incase renew fails
	[ -f "$inline_file.backup" ] && \
		die "Backup already exists: $inline_file.backup"
	cp "$inline_file" "$inline_file.backup" || \
		die "Unable to create backup: $inline_file.backup"

	# Remove the old .inline file
	# .inline HASH is checked prior to removal
	silent_remove=1
	inline_remove "$name"

	# Disable completion notices from sub processes
	silent_inline=1

	# Build the new .inline file
	case "$inline_type" in
		tls-base)
			silent_base=1
			inline_base "$name" $cmd_opts
			inline_index_update add
		;;
		tls-auth)
			inline_tls_auth "$name" "$key_direction" $cmd_opts
		;;
		tls-crypt)
			inline_tls_crypt_v1 "$name" $cmd_opts
		;;
		tls-crypt-v2)
			inline_tls_crypt_v2 "$name" $cmd_opts
		;;
		*)
			die "Unknown error inline_type: $inline_type"
		;;
	esac

	# Renew successful, remove the backup
	rm -f "$inline_file.backup"

	notice "Inline $inline_type file renewed: $inline_file"
} # => inline_renew ()

# Get and format openssl serial number output
openssl_crt_serial ()
{
	# get the serial number of the certificate -> serial=XXXX
	crt_serial="$("$EASYRSA_OPENSSL" x509 -in "$crt_file" -noout -serial)"
	# remove the serial= part -> we only need the XXXX part
	crt_serial=${crt_serial##*=}
}

# Extract the CommonName from openssl -subject
openssl_crt_cn ()
{
	"$EASYRSA_OPENSSL" x509 -in "$crt_file" \
		-noout -subject -nameopt sep_multiline | \
		grep "^[[:blank:]]*CN=.*$" | \
		sed "s/^[[:blank:]]*CN=//g"
}

# Get current inline key direction
inline_renew_key_direction ()
{
	grep "^key-direction [01]$" "$inline_file" | awk '{ print $2 }'
}

# Create inline credentials file from Easy-RSA PKI
inline_base ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	while [ -n "$1" ]; do
		case "$1" in
			nokey) no_x509_key=1 ;;
			add-dh) inline_dh_file=1 ;;
			*) warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	ca_file="$EASYRSA_PKI/ca.crt"
	crt_file="$EASYRSA_PKI/issued/$name.crt"
	key_file="$EASYRSA_PKI/private/$name.key"
	inline_file="$EASYTLS_PKI/$name.inline"
	help_note="Run 'easytls inline-status' to verify certificate revokation."

	[ -f "$crt_file" ] || die "\
Certificate file missing or revoked: $crt_file
$help_note"

	if [ "$no_x509_key" ]
	then
		# Key file is not required
		:
	else
		# Key file is required
		[ -f "$key_file" ] || die "\
Key file missing or revoked: $key_file
$help_note"
	fi

	if [ "$inline_dh_file" ]
	then
		# dh file is required
		help_note="Use --dh=<file_name> to specify an alternate dh file."
		default_dh_file="$EASYRSA_PKI/dh.pem"
		EASYRSA_DH_FILE="${EASYRSA_DH_FILE:-"$default_dh_file"}"
		[ -f "$EASYRSA_DH_FILE" ] || die "\
Diffy Hellman parameters file missing: $EASYRSA_DH_FILE
$help_note"
	fi
	unset help_note

	# get the serial number of the certificate from openssl
	crt_serial=""
	openssl_crt_serial

	# Check .inline file does not exist
	if [ "$EASYTLS_BATCH" ]
	then
		rm -f "$inline_file"
	else
		[ -f "$inline_file" ] && die "Inline file exists: $inline_file"
	fi

	# Build .inline file
	{	printf "%s\n" "# File name base: $name"
		printf "%s\n" "# Serial number: $crt_serial"
		printf "%s\n" ""
		printf "%s\n" "<cert>"
		cat "$crt_file"
		printf "%s\n" "</cert>"
		printf "%s\n" ""
		printf "%s\n" "<key>"

		if [ "$no_x509_key" ]
		then
			printf "%s\n" \
			" * Replace this line with your complete x509 key file *"
		else
			cat "$key_file"
		fi

		printf "%s\n" "</key>"
		printf "%s\n" ""
		printf "%s\n" "<ca>"
		cat "$ca_file"
		printf "%s\n" "</ca>"
		printf "%s\n" ""

		if [ "$inline_dh_file" ]
		then
			printf "%s\n" "<dh>"
			cat "$EASYRSA_DH_FILE"
			printf "%s\n" "</dh>"
			printf "%s\n" ""
		fi

	} > "$inline_file" || die "Failed to create inline file: $inline_file"

	# Update INLINE index
	# Only if this is the root caller
	[ ! $silent_base ] && inline_index_update add

	[ ! $silent_base ] && notice "Inline base file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_base ()

# Append TLS auth file to base file
inline_tls_auth ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			0|1)	key_direction="$1" ;;
			add-dh)	cmd_opts="$cmd_opts add-dh" ;;
			nokey)	cmd_opts="$cmd_opts nokey" ;;
			*) 	warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	tls_auth_key="$EASYTLS_PKI/tls-auth.key"
	inline_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_auth_key" ] || \
		die "TLS key file does not exist: $tls_auth_key"

	case "$key_direction" in
		0|1)
			# Using user specified --key-direction
			:
		;;
		*)
			# No key-direction found, not inlining --key-direction
			[ $silent_inline ] || \
				warn "TLS-auth key-direction missing"
			no_key_direction=1
		;;
	esac

	# Inline base file
	silent_base=1
	inline_base "$name" $cmd_opts

	{	printf "%s\n" "# TLS auth"
		printf "%s\n" ""

		if [ ! $no_key_direction ]
		then
			printf "%s\n" "key-direction $key_direction"
			printf "%s\n" ""
		fi

		printf "%s\n" "<tls-auth>"
		cat "$tls_auth_key"
		printf "%s\n" "</tls-auth>"
		printf "%s\n" ""
	} >> "$inline_file" || die "Failed to create inline file: $inline_file"

	# Hash inline file and add hash to index
	inline_index_update add

	[ ! $silent_inline ] && \
		notice "Inline TLS auth file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_tls_auth ()

# Append TLS crypt file to base file
inline_tls_crypt_v1 ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			add-dh) cmd_opts="$cmd_opts add-dh" ;;
			nokey) cmd_opts="$cmd_opts nokey" ;;
			*) warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	tls_file="$EASYTLS_PKI/tls-crypt.key"
	inline_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_file" ] || die "TLS key file does not exist: $tls_file"

	# Inline base file
	silent_base=1
	inline_base "$name" $cmd_opts

	{	printf "%s\n" "# TLS crypt"
		printf "%s\n" ""
		printf "%s\n" "<tls-crypt>"
		cat "$tls_file"
		printf "%s\n" "</tls-crypt>"
		printf "%s\n" ""
	} >> "$inline_file" || die "Failed to create inline file: $inline_file"

	# Hash inline file and add hash to index
	inline_index_update add

	[ ! $silent_inline ] && \
		notice "Inline TLS crypt file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_tls_crypt_v1 ()

# Append TLS crypt v2 file to base file
inline_tls_crypt_v2 ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			add-dh) cmd_opts="$cmd_opts add-dh" ;;
			nokey) cmd_opts="$cmd_opts nokey" ;;
			*) warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	tls_file="$EASYTLS_PKI/$name-tls-crypt-v2.key"
	inline_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_file" ] || die "TLS key file does not exist: $tls_file"
	[ -f "$inline_file" ] && die "Inline file already exist: $inline_file"

	# Inline base file
	silent_base=1
	inline_base "$name" $cmd_opts

	{	printf "%s\n" "# TLS crypt v2"
		printf "%s\n" ""
		printf "%s\n" "<tls-crypt-v2>"
		cat "$tls_file"
		printf "%s\n" "</tls-crypt-v2>"
		printf "%s\n" ""
	} >> "$inline_file" || die "Failed to create inline file: $inline_file"

	# Hash inline file and add hash to index
	inline_index_update add

	[ ! $silent_inline ] && \
		notice "Inline TLS crypt v2 file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_tls_crypt_v2 ()

# Create TLS auth file
build_tls_auth ()
{
	# This is allowed without a complete Easy-RSA PKI
	# Verify Easy-TLS and Easy-RSA have been correctly setup
	verify_tls_init
	key_file="$EASYTLS_PKI/tls-auth.key"

	[ -f "$key_file" ] && \
		die "TLS auth key already exists: $key_file"

	"$EASYTLS_OPENVPN" --genkey --secret "$key_file" || \
		die "Failed to create TLS auth key: $key_file"

	notice "TLS auth key created: $key_file"
} # => build_tls_auth ()

# Create TLS crypt v1 file
build_tls_crypt_v1 ()
{
	# Requires openvpn version 2.4
	verify_openvpn_version 4

	# This is allowed without a complete Easy-RSA PKI
	# Verify Easy-TLS and Easy-RSA have been correctly setup
	verify_tls_init

	key_file="$EASYTLS_PKI/tls-crypt.key"

	[ -f "$key_file" ] && \
		die "TLS crypt v1 key already exists: $key_file"

	"$EASYTLS_OPENVPN" --genkey --secret "$key_file" || \
		die "Failed to create TLS crypt v1 key: $key_file"

	notice "TLS crypt v1 key created: $key_file"
} # => build_tls_crypt_v1 ()

# Create TLS crypt v2 server file
build_tls_crypt_v2_server ()
{
	[ $# -ge 1 ] || die "Required option(s): <server_filename_base>"

	# Requires openvpn version 2.5
	verify_openvpn_version 5

	verify_tls_init

	srv_name="$1"
	srv_cert="$EASYRSA_PKI/issued/$srv_name.crt"
	key_file="$EASYTLS_PKI/$srv_name-tls-crypt-v2.key"

	[ -f "$srv_cert" ] || \
		die "Easy-TLS requires that the x509 certificate has been built.
Missing file: $srv_cert"

	[ -f "$key_file" ] && die "Server file already exists: $key_file"

	"$EASYTLS_OPENVPN" --genkey tls-crypt-v2-server "$key_file" || \
		die "Failed to create tls-crypt-v2-server key: $key_file"

	notice "TLS crypt v2 server key created: $key_file"
} # => build_tls_crypt_v2_server ()

# Create TLS crypt v2 client file
build_tls_crypt_v2_client ()
{
	[ $# -ge 2 ] || \
	die "Required option(s): <server_filename_base> <client_filename_base>"

	[ $# -eq 2 ] || \
	warn "Ignoring unknown option(s): $3 $4 $5 .. etc."

	# Requires openvpn version 2.5
	verify_openvpn_version 5

	verify_tls_init

	# Need the CA
	verify_ca_init

	ca_cert="$EASYRSA_PKI/ca.crt"
	srv_name="$1"
	srv_cert="$EASYRSA_PKI/issued/$srv_name.crt"
	cli_name="$2"
	cli_cert="$EASYRSA_PKI/issued/$cli_name.crt"
	shift 2

	[ "$srv_name" = "$cli_name" ] && \
		die "Server name cannot be the same as the client name."

	[ -f "$srv_cert" ] || \
		die "Easy-TLS requires that the x509 certificate has been built.
Missing srv file: $srv_cert"

	[ -f "$cli_cert" ] || \
		die "Easy-TLS requires that the x509 certificate has been built.
Missing cli file: $cli_cert"

	in_file="$EASYTLS_PKI/$srv_name-tls-crypt-v2.key"
	key_file="$EASYTLS_PKI/$cli_name-tls-crypt-v2.key"

	[ -f "$in_file" ] || die "Server file does not exist: $in_file"
	[ -f "$key_file" ] && die "Client file already exists: $key_file"

	metadata=""
	b64_metadata=""
	b64_enc_metadata

	"$EASYTLS_OPENVPN" --tls-crypt-v2 "$in_file" \
		--genkey tls-crypt-v2-client "$key_file" "$b64_metadata" || \
		die "Failed to create tls-crypt-v2-client key: $key_file"

	notice "TLS crypt v2 client key created: $key_file"
} # => build_tls_crypt_v2_client ()

# Base64 encode metadata fields
b64_enc_metadata ()
{
	# metadata strings:
	# 1. Metadata version: xx (Simple hex)
	# 2. CA SHA1 Fingerprint, contiguous single field
	#    `openssl output` Change space to underscore
	# 3. Client certificate serial, contiguous single field
	#    `openssl output` Drop the 'serial='
	# 4. Client CommonName
	# 5. Custom Group string

	# metadata_version
	metadata_version="metadata_version_easytls_A4"
	# CA fingerprint
	openssl_ca_fp="$(fn_ca_fingerprint)"
	ca_fingerprint="$(printf "%s" "$openssl_ca_fp" | sed "s/\ /\_/g")"
	# get the serial number of the certificate from openssl
	crt_serial=""
	openssl_crt_serial

	# Build metadata
	metadata="$metadata_version $ca_fingerprint $crt_serial $cli_name"
	# Append --custom-group
	if [ -n "$EASYTLS_TLSCV2_CG" ]
	then
		metadata="$metadata $EASYTLS_TLSCV2_CG"
	fi

	[ $EASYTLS_TRAVIS_CI ] && debug_metadata

	[ $EASYTLS_SILENT ] || printf "%s\n" "metadata: $metadata"
	# Base64 encode metadata
	b64_metadata="$(printf "%s" "$metadata"|"$EASYRSA_OPENSSL" enc -e -a -A)"
} # => b64_enc_metadata ()

# Generate CA fingerprint
fn_ca_fingerprint ()
{
	"$EASYRSA_OPENSSL" x509 -in "$ca_cert" -noout -fingerprint
} # => fn_ca_fingerprint ()

# Extract client certificate serial
#fn_cert_serial ()
#{
#	"$EASYRSA_OPENSSL" x509 -in "$cli_cert" -noout -serial
#} # => fn_cert_serial ()

# DEBUG metadata
debug_metadata ()
{
	metadata_debug="$EASYTLS_PKI/tls-crypt-v2-$cli_name.mdd"
	printf "%s\n" "$metadata" > "$metadata_debug"
}

############################################################################
#
# DISABLED LIST Section
#

# Manage tls-crypt-v2-verify default tls/disabled_list.txt
tls_crypt_v2_verify_disable_list ()
{
	name="$2"
	cli_cert="$EASYRSA_PKI/issued/$name.crt"
	[ -f "$cli_cert" ] || die "Cannot find certificate: $cli_cert"

	# get the serial number of the certificate from openssl
	crt_serial=""
	openssl_crt_serial

	# Check list for duplicates
	serial_disabled_status="$(search_disabled_list)"
	[ $serial_disabled_status -lt 2 ] || die "Serial is duplicated"

	# Serial number disable or enable and check
	case $1 in
	disable) # Add serial number to the list
		serial_disabled_status="$(search_disabled_list)"
		[ $serial_disabled_status -eq 0 ] || die "Serial is disabled"
		printf "%s\n" "$crt_serial $name" >> "$EASYTLS_DISABLED_LIST"
		serial_disabled_status="$(search_disabled_list)"
		[ $serial_disabled_status -eq 1 ] || die "Serial disabled failed"
	;;
	enable) # Remove serial number from the list
		serial_disabled_status="$(search_disabled_list)"
		[ $serial_disabled_status -eq 1 ] || die "Serial is enabled"
		sed -i "/^${crt_serial}[[:blank:]]${name}$/d" \
			"$EASYTLS_DISABLED_LIST"

		serial_disabled_status="$(search_disabled_list)"
		[ $serial_disabled_status -eq 0 ] || die "Serial enabled failed"
	;;
	*) die "tls_crypt_v2_verify action invalid: $1"
	;;
	esac

	# Update time-stamp
	update_text="# Updated: $(date) -- $1: $name"
	sed -i "/^\#\ Updated:.*$/d" "$EASYTLS_DISABLED_LIST"
	printf "%s\n" "$update_text" >> "$EASYTLS_DISABLED_LIST"
	notice "Updated disabled list: $name $1"
} # => tls_crypt_v2_verify_disable_list ()

# Search disabled list for serial number
search_disabled_list ()
{
	grep -c "^${crt_serial}[[:blank:]]${name}$" "$EASYTLS_DISABLED_LIST"
}

############################################################################
#
# EASYTLS SETUP Section
#

# vars setup
# Here sourcing of 'vars' if present occurs. If not present, defaults are used
# to support running without a sourced config format
vars_setup()
{
	# Try to locate a 'vars' file in order of location preference.
	# If one is found, source it
	vars=

	# set up program path
	prog_file="$0"
	prog_dir="${prog_file%/*}"
	prog_vars="${prog_dir}/vars"
	# set up PKI path
	pki_vars="${EASYRSA_PKI:-$PWD/pki}/vars"

	# command-line path:
	if [ ! -z "$EASYRSA_VARS_FILE" ]; then
	  if [ ! -f "$EASYRSA_VARS_FILE" ]; then
		# If the --vars option does not point to a file
		# then show helpful error.
			die "The file '$EASYRSA_VARS_FILE' was not found."
		fi
		vars="$EASYRSA_VARS_FILE"
	# PKI location, if present:
	elif [ -f "$pki_vars" ]; then
		vars="$pki_vars"
	# EASYRSA, if defined:
	elif [ -n "$EASYRSA" ] && [ -f "$EASYRSA/vars" ]; then
		vars="$EASYRSA/vars"
	# program location:
	elif [ -f "$prog_vars" ]; then
		vars="$prog_vars"
	# vars of last resort ./vars
	elif [ -f "./vars" ]; then
		vars="./vars"
		warn "'./vars' of last resort !"
	fi
	
	# If a vars file was located, source it
	# If $EASYRSA_NO_VARS is defined (not blank) this is skipped
	if [ -z "$EASYRSA_NO_VARS" ] && [ -n "$vars" ]; then
		EASYRSA_CALLER=1
		. "$vars"
		# Make this a verbose only noteice
		#notice "Note: using Easy-RSA configuration from: $vars"
	fi
	
	# Set defaults, preferring existing env-vars if present
	set_var
	set_var EASYRSA			"$prog_dir"
	set_var EASYRSA_OPENSSL		"openssl"
	set_var EASYRSA_PKI		"$PWD/pki"
	set_var EASYRSA_TEMP_DIR	"$EASYRSA_PKI"
	set_var EASYRSA_INDEX		"$EASYRSA_PKI/index.txt"

	set_var EASYTLS_PKI		"$EASYRSA_PKI/easytls"
	set_var EASYTLS_INLINE_INDEX	"$EASYTLS_PKI/easytls-inline-index.txt"
	set_var EASYTLS_OPENVPN		"openvpn"
	set_var EASYTLS_DISABLED_LIST	"$EASYTLS_PKI/easytls-disabled.txt"

	# Assign value to $EASYRSA_TEMP_DIR_session and work around
	# Windows mktemp bug when parent dir is missing
	if [ -z "$EASYRSA_TEMP_DIR_session" ]; then
		if [ -d "$EASYRSA_TEMP_DIR" ]; then
			EASYRSA_TEMP_DIR_session="$(mktemp_make_temp)"
		else
			# Directory does not exist then we have not run init-pki
			mkdir -p "$EASYRSA_TEMP_DIR" || \
				die "Cannot create $EASYRSA_TEMP_DIR"

			EASYRSA_TEMP_DIR_session="$(mktemp_make_temp)"
			rm -rf "$EASYRSA_TEMP_DIR"
		fi
	fi
} # vars_setup()

# mktemp return temp_dir name
mktemp_make_temp ()
{
	mktemp -du "$EASYRSA_TEMP_DIR/easy-rsa-$$.XXXXXX"
} # => mktemp_make_temp ()

# variable assignment by indirection when undefined; merely exports
# the variable when it is already defined (even if currently null)
# Sets $1 as the value contained in $2 and exports (may be blank)
set_var()
{
	[ $# -eq 0 ] && return
	var=$1
	shift
	value="$*"
	eval "export $var=\"\${$var-$value}\""
} #=> set_var()

# Set the Easy-TLS version
easy_tls_version ()
{
	EASYTLS_VERSION="1.27"
	print "Easy-TLS version: $EASYTLS_VERSION"
} # => easy_tls_version ()

############################################################################
#
# EASYTLS COMMAND Section
#

########################################
# Invocation entry point:


# Be secure with a restrictive umask
[ -z "$EASYTLS_NO_UMASK" ] && umask 077

# Parse options
while :; do
	# Separate option from value:
	opt="${1%%=*}"
	val="${1#*=}"
	empty_ok="" # Empty values are not allowed unless excepted

	case "$opt" in
	--batch)
		empty_ok=1
		export EASYTLS_BATCH=1 ;;
	--pki-dir)
		export EASYRSA_PKI="$val" ;;
	--vars)
		export EASYRSA_VARS_FILE="$val" ;;
	--silent)
		empty_ok=1
		export EASYTLS_SILENT=1 ;;
	--dh)
		export EASYRSA_DH_FILE="$val" ;;
	--custom-group)
		export EASYTLS_TLSCV2_CG="$val" ;;
	*)
		break ;;
	esac

	# fatal error when no value was provided
	if [ ! $empty_ok ] && { [ "$val" = "$1" ] || [ -z "$val" ]; }; then
		die "Missing value to option: $opt"
	fi

	shift
done

# Intelligent env-var detection and auto-loading:
vars_setup

# Register cleanup on EXIT
trap "cleanup" EXIT
# When SIGHUP, SIGINT, SIGQUIT, SIGABRT and SIGTERM,
# explicitly exit to signal EXIT (non-bash shells)
trap "exit 1" 1
trap "exit 2" 2
trap "exit 3" 3
trap "exit 6" 6
trap "exit 14" 15

# determine how we were called, then hand off to the function responsible
cmd="$1"
[ -n "$1" ] && shift # scrape off command
case "$cmd" in
	init-tls)
		init_tls "$@"
		;;
	build-tls-auth)
		build_tls_auth "$@"
		;;
	build-tls-crypt)
		build_tls_crypt_v1 "$@"
		;;
	build-tls-crypt-v2-server)
		build_tls_crypt_v2_server "$@"
		;;
	build-tls-crypt-v2-client)
		build_tls_crypt_v2_client "$@"
		;;
	inline-base)
		inline_base "$@"
		;;
	inline-tls-auth)
		inline_tls_auth "$@"
		;;
	inline-tls-crypt)
		inline_tls_crypt_v1 "$@"
		;;
	inline-tls-crypt-v2)
		inline_tls_crypt_v2 "$@"
		;;
	inline-remove)
		inline_remove "$@"
		;;
	inline-renew)
		inline_renew "$@"
		;;
	inline-status)
		inline_status "$@"
		;;
	inline-show)
		inline_show "$@"
		;;
	inline-index-rebuild)
		inline_index_rebuild "$@"
		;;
	cert-expire)
		cert_expire "$@"
		;;
	disable)
		tls_crypt_v2_verify_disable_list disable "$@"
		;;
	enable)
		tls_crypt_v2_verify_disable_list enable "$@"
		;;
	version|-v|--version)
		easy_tls_version
		exit 0
		;;
	""|help|-h|--help|--usage)
		cmd_help "$1"
		exit 0
		;;
	*)
		die "Unknown command '$cmd'. Run without commands for help."
		;;
esac

# EasyTLS auto-check
inline_auto_check

# vim: ft=sh nu ai sw=8 ts=8 noet
