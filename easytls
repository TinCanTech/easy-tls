#!/bin/sh

# Copyright - negotiable
copyright ()
{
cat << VERBATUM_COPYRIGHT_HEADER_INCLUDE_NEGOTIABLE
# Easy-TLS -- A Shell-based Easy-RSA extension utility to help manage
#               * OpenVPN specific TLS keys
#               * Easy-RSA based x509 security credentials
#               * Verified 'inline' combined OpenVPN node packages
#
# Copyright (C) 2020 Richard Bonhomme (Friday 13th of March 2020)
# https://github.com/TinCanTech/easy-tls
# tincanteksup@gmail.com
# All Rights reserved.
#
# This code is released under version 2 of the GNU GPL
# See LICENSE of this project for full licensing details.
#
# Acknowledgement:
# This utility is "written in the style of" and "borrows heavily from" Easy-RSA
# See: https://github.com/OpenVPN/easy-rsa
#
VERBATUM_COPYRIGHT_HEADER_INCLUDE_NEGOTIABLE
}

# Easy-TLS requirements:
# + Easy-RSA Version 3.X
# + OpenVPN Version 2.X
#


# Help/usage output to stdout
usage()
{
	# command help:
	print "
Easy-TLS usage and overview

USAGE: easytls [options] COMMAND [command-options]

A list of commands is shown below. To get detailed usage and help for a
command, run:
  ./easytls help COMMAND

For a listing of options that can be supplied before the command, use:
  ./easytls help options

Here is the list of commands available with a short syntax reminder.
Use the 'help' command above to get full usage details.

  init-tls
  build-tls-auth
  build-tls-crypt
  build-tls-crypt-v2-server <filename_base>
  build-tls-crypt-v2-client <server_filename_base> <client_filename_base>
  inline-base <filename_base> [ cmd-opts ]
  inline-tls-auth <filename_base> <key_direction> [ cmd-opts ]
  inline-tls-crypt <filename_base> [ cmd-opts ]
  inline-tls-crypt-v2 <filename_base> [ cmd-opts ]
  inline-remove <filename_base>
  inline-renew <filename_base> [ cmd-opts ]
  inline-status [ cmd-opts ]
  inline-show <filename_base>
  inline-index-rebuild
  inline-expire <filename_base>
  cert-expire <filename_base> | <ca>
  disable <filename_base>
  enable <filename_base>

NOTE: Easy-TLS requires that you have a working EasyRSA PKI in place.
NOTE: Easy-TLS requires that you have OpenVPN installed.
"

	# collect/show dir status:
	err_source="Not defined: vars autodetect failed and no value provided"
	work_dir="${EASYRSA:-$err_source}"
	pki_dir="${EASYRSA_PKI:-$err_source}"
	tls_dir="${EASYTLS_PKI:-$err_source}"
	print "\
DIRECTORY STATUS (commands would take effect on these locations)
  EASYRSA: $work_dir
      PKI: $pki_dir
      TLS: $tls_dir"
EASYTLS_SILENT=1
} # => usage()

# Detailed command help
# When called with no args, calls usage(), otherwise shows help for a command
cmd_help()
{
	text=""
	opts=""
	case "$1" in
		init-tls) text="
  init-tls
      Removes & re-initializes the TLS key dir" ;;
		build-tls-auth) text="
  build-tls-auth
      Create an OpenVPN TLS auth PSK (tls-auth.key)" ;;
		build-tls-crypt) text="
  build-tls-crypt
      Create an OpenVPN TLS crypt PSK (tls-crypt.key)" ;;
		build-tls-crypt-v2-server) text="
  build-tls-crypt-v2-server <server_filename_base>
      Create an OpenVPN TLS crypt V2 Server key" ;;
		build-tls-crypt-v2-client) text="
  build-tls-crypt-v2-client <server_filename_base> <client_filename_base>
      Create an OpenVPN TLS crypt V2 Client key" ;;
		inline-base) text="
  inline-base <filename_base> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA files only
      for VPN node <filename_base>"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-tls-auth) text="
  inline-tls-auth <filename_base> <key_direction> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS auth file
      <key_direction> '0' or '1'
      (If key-direction is omitted then do not add key-direction to inline file)"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-tls-crypt) text="
  inline-tls-crypt <filename_base> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS crypt file"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-tls-crypt-v2) text="
  inline-tls-crypt-v2 <filename_base> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS crypt v2 file"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-remove) text="
  inline-remove <filename_base>
      Delete <filename_base>.inline when Easy-RSA certificate is revoked" ;;
		inline-renew) text="
  inline-renew <filename_base> [ cmd-opts ]
      Renew <filename_base>.inline when Easy-RSA certificate is renewed"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-status) text="
  inline-status [ cmd-opts ]
      Compare Easy-RSA certificate(s) to Easy-TLS inline(s) status"
			opts="
	valid   - List only Easy-RSA valid certificates
	revoked - List only Easy-RSA revoked certificates
	inline  - List only Easy-TLS inline files
	invalid - List only Easy-TLS invalid inline files" ;;
		inline-show) text="
  inline-show <filename_base>
      Copy <filename_base>.inline to stdout" ;;
		inline-index-rebuild) text="
  inline-index-rebuild
      Rebuild easytls-index.txt
      If you need to do this then you may have found a bug, please
      raise an issue https://github.com/TinCanTech/easy-tls/issues" ;;
		inline-expire) text="
  inline-expire <filename_base>
      Display inline expiry date for <filename_base>"
			opts="
        If no <filename_base> is given then list all inline expiry dates" ;;
		cert-expire) text="
  cert-expire <filename_base> | <ca>
      Display certificate expiry date for <filename_base>"
			opts="
        If <filename_base> is 'ca' then show ca.crt expiry
        If no <filename_base> is given then list all certificate expiry dates" ;;
		disable) text="
  disable <filename_base>
      Add serial number for <filename_base> to the disabled list
      for immediate use by the tls-crypt-v2-verify script" ;;
		enable) text="
  enable <filename_base>
      Remove serial number for <filename_base> from the disabled list
      for immediate use by the tls-crypt-v2-verify script" ;;
		options)
			opt_usage ;;
		"")
			usage ;;
		*) text="
  Unknown command: '$1' (try without commands for a list of commands)" ;;
	esac

	# display the help text
	print "$text"
	[ -n "$opts" ] && print "
      cmd-opts is an optional set of command options from this list:
$opts"
} # => cmd_help()

# Options usage
opt_usage()
{
	print "
Easy-TLS Global Option Flags

The following options may be provided before the command. Options specified
at runtime override env-vars and any 'vars' file in use. Unless noted,
non-empty values to options are mandatory.

General options:

--openvpn=FILE  : The full (or relative) <path to> and <file-name of>
                  your preferred openvpn(.exe) executable openvpn file.
--disable-auto-check
                : For performance you can disable auto-check.
--batch         : set automatic (no-prompts when possible) mode.
--verbose       : Verbose output.
--silent        : Silence all message output except prompts.
--pki-dir=DIR   : declare the EasyRSA PKI directory.
--vars=FILE     : define a specific 'vars' file to use for Easy-RSA config.
--dh=FILE       : define an alternate Diffy Hellman parameters file.
--custom-group  : Append a custom field to the default TLS crypt v2 metadata.
                  This field can also be matched in tls-crypt-v2-verify.sh
                  with the command line option: -g|--custom-group XYZ
                  XYZ MUST be a single alphanumerical word with NO spaces
 --cache-id     : Saves the CA ID (Currently fingerprint) to file for use by
                  tls-crypt-v2-verify.sh
                  File name: easytls/easytls-ca-identity.txt"
EASYTLS_SILENT=1
} # => opt_usage()

# Wrapper around printf - clobber print since it's not POSIX anyway
print() { printf "%s\n" "$*"; }

# Exit fatally with a message to stderr
# present even with EASYTLS_BATCH as these are fatal problems
die()
{
	easy_tls_version
	print "
Easy-TLS error:

$help_note

$1" 1>&2
	exit "${2:-1}"
} # => die()

# remove temp files and do terminal cleanups
cleanup()
{
	[ -z "$EASYRSA_TEMP_DIR_session" ] || rm -rf "$EASYRSA_TEMP_DIR_session"
	(stty echo 2>/dev/null) || { (set -o echo 2>/dev/null) && set -o echo; }
	[ $EASYTLS_SILENT ] || echo "" # just to get a clean line
} # => cleanup()

# non-fatal warning output
warn()
{
	[ "$EASYTLS_SILENT" ] && return 0
		print "
WARNING:
  $1" 1>&2
} # => warn()

# informational notices to stdout
notice()
{
	[ "$EASYTLS_SILENT" ] && return 0
		print "
$1"
} # => notice()

# intent confirmation helper func
# returns without prompting in EASYTLS_BATCH
confirm()
{
	[ "$EASYTLS_BATCH" ] && return
	prompt="$1"
	value="$2"
	msg="$3"
	input=""
	print "
$msg

Type the word '$value' to continue, or any other input to abort."
	printf %s "  $prompt"
	read input
	[ "$input" = "$value" ] && return
	notice "Aborting without confirmation."
	exit 9
} # => confirm()

vars_source_check() {
	# Check for defined EASYRSA_PKI
	[ -n "$EASYRSA_PKI" ] || die "\
EASYRSA_PKI env-var undefined"
} # => vars_source_check()

# Basic sanity-check of PKI init and complain if missing
verify_pki_init () {
	help_note="Run easyrsa without commands for usage and command help."

	# check that the pki dir exists
	vars_source_check
	[ -d "$EASYRSA_PKI" ] || die "\
Easy-TLS requires that you have initialised your Easy-RSA PKI.

Easy-RSA error:

EASYRSA_PKI does not exist (perhaps you need to run init-pki)?
Expected to find the EASYRSA_PKI at: $EASYRSA_PKI
$help_note"

	# verify expected dirs present:
	for i in private reqs; do
		[ -d "$EASYRSA_PKI/$i" ] || die "\
Easy-TLS requires that you have initialised your Easy-RSA PKI.

Easy-RSA error:

Missing expected directory: $i (perhaps you need to run init-pki?)
$help_note"
	done
} # => verify_pki_init()

# Verify core CA files present
verify_ca_init () {
	help_note="Run without commands for usage and command help."

	# First check the PKI has been initialized
	verify_pki_init

	# Verify expected files are present. Allow files to be regular files
	# (or symlinks), but also pipes, for flexibility with ca.key
	for i in serial index.txt index.txt.attr ca.crt private/ca.key; do
		if [ ! -f "$EASYRSA_PKI/$i" ] && [ ! -p "$EASYRSA_PKI/$i" ]; then
			#[ "$1" = "test" ] && return 1
			die "\
Easy-TLS TLS-crypt-v2 requires that you have built your EASY-RSA PKI.

Easy-RSA error:

Missing expected CA file: $i (perhaps you need to run build-ca?)
$help_note"
		fi
	done

	# When operating in 'test' mode, return success.
	# test callers don't care about CA-specific dir structure
	#[ "$1" = "test" ] && return 0

	# verify expected CA-specific dirs:
	for i in issued certs_by_serial
	do
		[ -d "$EASYRSA_PKI/$i" ] || die "\
Easy-TLS TLS-crypt-v2 requires that you have built your EASY-RSA PKI.

Easy-RSA error:

Missing expected CA dir: $i (perhaps you need to run build-ca?)
$help_note"
	done

	# explicitly return success for callers
	return 0

} # => verify_ca_init()

############################################################################
#
# EASYTLS MANGEMENT Section
#

# Verify Openvpn is available
verify_openvpn ()
{
	# TODO: Find openvpn and openvpn.exe correctly
	help_note="See ./easytls help options - Option: --openvpn"
	[ -f "$EASYTLS_OPENVPN" ] || die "OpenVPN not found: $EASYTLS_OPENVPN"

	# extract openvpn version
	openvpn_version="$("$EASYTLS_OPENVPN" --version)"
	openvpn_version="${openvpn_version#OpenVPN }"
	openvpn_version="${openvpn_version%% *}"
	openvpn_version="${openvpn_version%_*}"
	case "$openvpn_version" in
	2.5) : ;;
	2.4) : ;;
	*) die "Unsupported OpenVPN version: $openvpn_version" ;;
	esac
	unset help_note
} # => verify_openvpn ()

# Verify TLS has been initialised
verify_tls_init ()
{
	[ -d "$EASYTLS_PKI" ] || die "EasyTLS has not been initialised"
	[ -f "$EASYTLS_INLINE_INDEX" ] || die "EasyTLS has not been initialised"
	[ -f "$EASYTLS_DISABLED_LIST" ] || die "EasyTLS has not been initialised"
	verify_openvpn
} # => verify_tls_init ()

# init-tls backend:
init_tls ()
{
	# Easy-TLS requires that your Easy-RSA PKI is initialised
	verify_pki_init
	# If EASYTLS_PKI exists, confirm before we rm -rf
	# skipped with EASYTLS_BATCH
	if [ -d "$EASYTLS_PKI" ]; then
		confirm "Confirm removal: " "yes" "
WARNING!!!

You are about to remove the EASYTLS_PKI at: $EASYTLS_PKI
and initialize a fresh TLS PKI here."
		# now remove it:
		rm -rf "$EASYTLS_PKI" \
		|| die "Removal of TLS dir failed. Check/correct errors above"
	fi

	# Create tls dir in Easyrsa PKI dir
	mkdir -p "$EASYTLS_PKI" || die "Failed to create TLS dir (permissions?)"

	# Create tls dir index file
	printf "%s" "" > "$EASYTLS_INLINE_INDEX" \
		|| die "Failed to create $EASYTLS_INLINE_INDEX (permissions?)"

	# Create disabled list
	head_text="# OpenVPN Server tls-crypt-v2-verify.sh disabled list"
	date_text="# Created: $(date)"
	printf "%s\n%s\n" "$head_text" "$date_text" > "$EASYTLS_DISABLED_LIST" \
		|| die "Failed to create disabled list"

	notice "\
init-tls complete; you may now create TLS keys and .inline files.
Your newly created TLS dir is: $EASYTLS_PKI
"
	return 0
} # => init_tls ()

# Auto-check for invalid inline files
# Run on exit to avoid "checken and egg" with init-tls
inline_auto_check ()
{
	[ $auto_check_disabled ] && return 0
	index_size="$(grep -c '^.*$' "$EASYTLS_INLINE_INDEX")"
	[ $index_size -gt 50 ] && \
		warn "EasyTLS: 50+ .inline files found, use --disable-auto-check"

	auto_check=1
	inline_status invalid
	[ $revoked_mismatch_count -eq 0 ] || \
		warn "EasyTLS: Invalid .inline files found: Revoked certs."

	inline_status renewed
	[ $renewed_mismatch_count -eq 0 ] || \
		warn "EasyTLS: Invalid .inline files found: Renewed certs."

	unset auto_check
}

# Show Easy-TLS inlines and Easy-RSA certificates
# Report invalid inline files due to certificate revokation
inline_status ()
{
	[ $auto_check ] || auto_check_disabled=1
	subsection="$1"

	verify_ca_init

	ersa_valid_cn_list=""
	ersa_valid_serial_list=""
	ersa_revoked_cn_list=""
	ersa_revoked_serial_list=""
	#easytls_valid_cn_list=""
	etls_valid_name_list=""
	etls_valid_serial_list=""
	#easytls_revoked_serial_list="" # Not used

	if [ -n "$subsection" ]
	then
		#EASYTLS_SILENT=1
		case "$subsection" in
		valid)
				status_easyrsa_valid ;;
		revoked)
				status_easyrsa_revoked ;;
		inline)
				verify_tls_init
				status_easytls_inline ;;
		invalid)
				silent_status=1
				status_easyrsa_valid
				status_easyrsa_revoked
				verify_tls_init
				status_easytls_inline
				unset silent_status
				status_easytls_invalid
				;;
		renewed)
				silent_status=1
				status_easyrsa_valid
				status_easyrsa_revoked
				verify_tls_init
				status_easytls_inline
				unset silent_status
				status_easyrsa_renewed
				;;
		*)
				print "Unknown status option" ;;
		esac
		#unset EASYTLS_SILENT
		return 0
	fi

	print "Easy-RSA: Valid certificates:"
	status_easyrsa_valid

	print "Easy-RSA: Revoked certificates:"
	status_easyrsa_revoked

	verify_tls_init

	print "Easy-TLS: Known inline files:"
	status_easytls_inline

	#print "Easy-TLS: Revoked inline files:"
	#status_easytls_revoked

	print "Easy-TLS: Invalid inline files:"
	status_easytls_invalid

	print "Easy-RSA: Renewed certificates:"
	status_easyrsa_renewed

} #=> inline_status ()

# Format inline_status output
status_output ()
{
	awk '{print "  Common-Name " $1 "    Serial-number " $2}'
}

# Format inline_status CN
status_cn ()
{
	sed -e 's`^.*/CN=``g' -e 's`/.*$``g'
}

# Extract Valid records from openssl index.txt by crt_serial
status_valid_extract_cn ()
{
	grep "^V.*[[:blank:]]${i}[[:blank:]]" "$EASYRSA_INDEX" | status_cn
}

# Extract Revoked records from openssl index.txt by crt_serial
status_revoked_extract_cn ()
{
	grep "^R.*[[:blank:]]${i}[[:blank:]]" "$EASYRSA_INDEX" | status_cn
}

# Search ersa revoked serial list for etls valid serial
status_search_revoked_serial_list()
{
	print "$ersa_revoked_serial_list" | grep -c "^${i}$"
}

# List the invalid inline file record by serial number
status_invalid_inline_list ()
{
	grep "^${name}[[:blank:]]${i}[[:blank:]]${inline_hash}$" \
		"$EASYTLS_INLINE_INDEX" | status_output
}

# Print Valid certs from Easy-RSA
status_easyrsa_valid ()
{
	ersa_valid_serial_list="$(grep '^V' "$EASYRSA_INDEX"|awk '{print $3}')"
	for i in $ersa_valid_serial_list
	do
		ersa_valid_cn="$(status_valid_extract_cn)"
		ersa_valid_cn_list="$ersa_valid_cn_list $ersa_valid_cn"
		[ $silent_status ] || print "$ersa_valid_cn $i" | status_output
	done
} # => status_easyrsa_valid ()

# Print Revoked certs from Easy-RSA
status_easyrsa_revoked ()
{
	ersa_revoked_serial_list="$(grep '^R' "$EASYRSA_INDEX"|awk '{print $4}')"
	for i in $ersa_revoked_serial_list
	do
		ersa_revoked_cn="$(status_revoked_extract_cn)"
		ersa_revoked_cn_list="$ersa_revoked_cn_list $ersa_revoked_cn"
		[ $silent_status ] || print "$ersa_revoked_cn $i" | status_output
	done
} # => status_easyrsa_revoked ()

# Print Valid certs from Easy-TLS
status_easytls_inline ()
{
	etls_valid_name_list="$(awk '{print $1 " "}' "$EASYTLS_INLINE_INDEX")"
	etls_valid_name_list="${etls_valid_name_list#* }"
	etls_valid_serial_list="$(awk '{print $2 " "}' "$EASYTLS_INLINE_INDEX")"
	etls_valid_serial_list="${etls_valid_serial_list#* }"
	[ $silent_status ] || cat "$EASYTLS_INLINE_INDEX" | status_output
} # => status_easytls_valid ()

# Print Revoked certs from Easy-TLS
status_easytls_revoked ()
{
	print "  Easy-TLS does not Revoke certificates."
	print "  If the certificate has been revoked in Easy-RSA then use:"
	print "  'inline-remove <filename_base>' to delete the inline file."
} # => status_easytls_revoked ()

# Check Easy-TLS valid vs Easy-RSA revoked
status_easytls_invalid ()
{
	revoked_mismatch_count=0
	for i in $etls_valid_serial_list
	do
		crt_serial=$i
		name="$(inline_index_serial_to_common_name)"
		inline_file="$EASYTLS_PKI/$name.inline"

		# Check the .inline HASH
		inline_index_check_hash || die "Failed HASH: $inline_file"
		# HASH has been checked so clear it
		unset inline_hash

		mismatches="$(status_search_revoked_serial_list)"
		case $mismatches in
		0)
		# No mismatches found
			:
		;;
		1)
			revoked_mismatch_count=$((revoked_mismatch_count+1))
			[ $auto_check ] || status_invalid_inline_list
		;;
		*)
			warn "EasyRSA duplicate records detected!"
			[ $((mismatches)) -gt 1 ] || \
				die "Error in mismatches: $mismatches"
		;;
		esac
	done
} # => status_easytls_invalid ()

# Print Renewed certs from Easy-RSA if they are inlined
status_easyrsa_renewed ()
{
	renewed_mismatch_count=0
	# REMEMBER: If there is no inline file for a cert
	# then EasyTLS does not care if the cert is renewed

	for i in $etls_valid_name_list
	do

	name=$i
	inline_file="$EASYTLS_PKI/$name.inline"
	[ -f "$inline_file" ] || die "Not found: inline_file = $inline_file"
	inline_serial="$(inline_crt_serial)"

	crt_file="$EASYRSA_PKI/issued/$name.crt"
	if [ -f "$crt_file" ]
	then

		# openssl_crt_serial DIFFERENT BEHAVIOUR TO inline_crt_serial
		crt_serial=""
		openssl_crt_serial

		if [ "$inline_serial" = "$crt_serial" ]
		then
			# serial match, inline is upto date
			:
		else
			# serial mismatch, cert has been renewed in EasyRSA
			renewed_mismatch_count=$((renewed_mismatch_count+1))
			if [ $silent_status ]
			then
				# No output
				:
			else
				[ $auto_check ] || { \
				print "  Common-Name $name"
				print "    Inline-Serial $inline_serial"
				print "    Cert-Serial   $crt_serial"
				}

			fi
		fi
	else
		# EasyRSA renew is broken
		# cert is probably revoked
		:
	fi

	# End of for loop
	done

} # => status_easyrsa_renewed ()

# Extract enddate from certificate
crt_expire_date ()
{
	"$EASYRSA_OPENSSL" x509 -in "$crt_file" -noout -enddate | \
		sed 's/^notAfter=//'
} # => crt_expire_date ()

# Extract enddate from certificate
inline_expire_date ()
{
	grep '^[[:blank:]]*Not After : ' "$inline_file" | \
		sed 's/^[[:blank:]]*Not After : //g'
} # => crt_expire_date ()

# Get x509 certificate expiry date
cert_expire ()
{
	name="$1"

	verify_tls_init

	if [ "$name" = "ca" ]
	then
		crt_file="$EASYRSA_PKI/ca.crt"
		[ -f "$crt_file" ] || die "Missing: $crt_file"
		crt_expire="$(crt_expire_date)"
		print " Certificate: ca.crt   Expire-date: $crt_expire"
	elif [ -n "$name" ]
	then
		crt_file="$EASYRSA_PKI/issued/$name.crt"
		[ -f "$crt_file" ] || die "Missing: $crt_file"
		crt_expire="$(crt_expire_date)"
		print " Certificate: $name.crt   Expire-date: $crt_expire"
	else
		easyrsa_valid_list="$(grep '^V' "$EASYRSA_INDEX"|status_cn)"
		for name in $easyrsa_valid_list
		do
			crt_file="$EASYRSA_PKI/issued/$name.crt"
			[ -f "$crt_file" ] || die "Missing: $crt_file"
			crt_expire="$(crt_expire_date)"
			print " Certificate: $name.crt   Expire-date: $crt_expire"
		done
		crt_file="$EASYRSA_PKI/ca.crt"
		[ -f "$crt_file" ] || die "Missing: $crt_file"
		crt_expire="$(crt_expire_date)"
		print " Certificate: ca.crt   Expire-date: $crt_expire"
	fi
} # => cert_expire ()

# Get inline certificate expiry date
inline_expire ()
{
	name="$1"

	verify_tls_init

	if [ -n "$name" ]
	then
		inline_file="$EASYTLS_PKI/$name.inline"
		[ -f "$inline_file" ] || die "Missing: $inline_file"
		inline_expire="$(inline_expire_date)"
		print " Certificate: $name.inline   Expire-date: $inline_expire"
	else
	# Get a list of Valid names from easytls-inline-index
	etls_valid_name_list="$(awk '{print $1 " "}' "$EASYTLS_INLINE_INDEX")"
		for name in $etls_valid_name_list
		do
			inline_file="$EASYTLS_PKI/$name.inline"
			[ -f "$inline_file" ] || die "Missing: $inline_file"
			inline_expire="$(inline_expire_date)"
		print " Inline-file: $name.inline   Expire-date: $inline_expire"
		done
	fi
} # => inline_expire ()

# Keep an index file for inline certs to manage revoke/renew
inline_index_update ()
{
	[ $# -ge 1 ] || die "Required option(s): <update_index_action>"

	update_index_action="$1"
	[ -f "$EASYTLS_INLINE_INDEX" ] || \
		die "inline_index_update () Missing: $EASYTLS_INLINE_INDEX"

	case "$update_index_action" in
	add)
		# Add the inline_serial not the crt_serial
		inline_serial="$(inline_crt_serial)"

		# If this HASH is set then another function is responsible for it
		[ "$inline_hash" ] && \
			die "Do not allow a HASH here: inline_index_update add"

		# Create new HASH
		inline_hash="$(inline_index_gen_hash)"
		[ $EASYTLS_VERBOSE ] && \
			printf "%s\n" "  ADD: $name $inline_serial $inline_hash"

		# Create new record
		printf "%s\n" "$name $inline_serial $inline_hash" >> \
			"$EASYTLS_INLINE_INDEX" || \
			die "Failed to update $EASYTLS_INLINE_INDEX"
	;;
	del)
		[ $EASYTLS_VERBOSE ] && \
			printf "%s\n" "  DEL: $name $crt_serial $inline_hash"

		# Find old record
		grep \
		"^${name}[[:blank:]]${crt_serial}[[:blank:]]${inline_hash}$" \
			"$EASYTLS_INLINE_INDEX" 1>/dev/null || {
			help_note="Failed: inline_index_update del"
			die "Missing record: $name $crt_serial $inline_hash"
			}

		# Remove old record
		sed -i -e \
		"/^${name}[[:blank:]]${crt_serial}[[:blank:]]${inline_hash}$/d" \
			"$EASYTLS_INLINE_INDEX"
	;;
	*)
		die "Unknown index action: $update_index_action"
	;;
	esac
} # => inline_index_update ()

# Check inline hash
inline_index_check_hash ()
{
	# This is a check so check everything here
	# every value and file must exist at this time
	# Try to logically illiminate the need for these checks

	[ -z "$name" ] && \
		die "inline_index_check_hash: Missing value: name"

	[ -z "$crt_serial" ] && \
		die "inline_index_check_hash: Missing value: crt_serial"

	# Should not have this HASH, that is the reaon to do this check
	# If we already have a HASH then something else is wrong
	[ -n "$inline_hash" ] && \
		die "inline_index_check_hash: Found value: inline_hash $inline_hash"

	[ -z "$inline_file" ] && \
		die "inline_index_check_hash: Missing value: inline_file"

	[ -f "$inline_file" ] || \
		die "inline_index_check_hash: Missing file: $inline_file"

	# Calculate current file HASH
	real_hash="$(inline_index_gen_hash)"

	# Search for calculated current HASH
	find_hash="$(inline_index_search_hash)"

	case "$find_hash" in
	0)
		# HASH check failed
		insert_msg="HASH incorrect for: $inline_file"
		insert_msg="Inline index HASH : $inline_hash"
		insert_msg="Inline file HASH : $real_hash"
		help_note="$insert_msg"
	;;
	1)
		# This is the correct HASH so set it
		# If this does not work in another function
		# then control it from that function
		inline_hash="$real_hash"

		# HASH is correct
		return 0 ;;
	*) help_note="HASH check unknown error: $find_hash" ;;
	esac

	# There is only one way out of this..
	return 1
} # => inline_index_check_hash ()

# Get serial number from inline index file using Common name as key
inline_index_common_name_to_serial ()
{
	# TODO: This could be effected by duplicate names from easyrsa
	# This function is defunct but keep it for the EasyRSA early warning
	# Other functions could be effected
	# https://github.com/TinCanTech/easy-tls/issues/48
	grep "^${name}[[:blank:]].*$" \
		"$EASYTLS_INLINE_INDEX" | awk '{print $2}'
}

# Get Common name from inline index file using serial number as key
inline_index_serial_to_common_name ()
{
	grep "^.*[[:blank:]]${crt_serial}[[:blank:]].*$" \
		"$EASYTLS_INLINE_INDEX" | awk '{print $1}'
}

# Generate HASH of inline file
inline_index_gen_hash ()
{
	"$EASYRSA_OPENSSL" sha1 "$inline_file" | awk '{print $NF}'
}
# Search for hash
inline_index_search_hash ()
{
	grep -c "^${name}[[:blank:]]${crt_serial}[[:blank:]]${real_hash}$" \
		"$EASYTLS_INLINE_INDEX"
}

# Get serial number from inline file
inline_crt_serial ()
{
	grep '^# Serial number: .*$' "$inline_file" | awk '{print $4}'
}

# Does this .inline file name already have an index record
inline_index_search_valid_cn_list ()
{
	printf '%s\n' "$etls_inline_record_list" | \
		grep -c "[[:blank:]]${name}[[:blank:]]"
}

# Dragon be here ! - Extract CN from openssl index.txt
inline_index_openssl_valid_cn_list ()
{
	grep '^V.*$' "$EASYRSA_INDEX" | \
		sed -e 's`^.*/CN=``g' -e 's`/emailAddress=.*$``g'
}

# Copy inline to stdout
inline_show ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	name="$1"
	inline_file="$EASYTLS_PKI/$name.inline"

	verify_tls_init

	[ -f "$inline_file" ] || die "Missing: $inline_file"
	crt_serial="$(inline_crt_serial)"
	inline_index_check_hash || die "Failed HASH: $inline_file"
	cat "$inline_file" || die "Failed to open: $inline_file"
} # => inline_show ()

# Remove .inline file
inline_remove ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	name="$1"
	inline_file="$EASYTLS_PKI/$name.inline"

	verify_tls_init

	[ -f "$inline_file" ] || die "Missing: $inline_file"

	# Get serial number from inline file
	crt_serial="$(inline_crt_serial)"

	# Confirm remove
	[ ! $silent_remove ] && \
		confirm  "Remove inline file ? " "yes" "Remove: $inline_file"

	# Check .inline HASH prior to removal
	inline_index_check_hash || die "inline_remove Failed HASH: $inline_file"

	rm "$inline_file" || die "Failed to remove: $inline_file"

	inline_index_update del

	# Inline file and record deleted - Forget the HASH
	# Otherwise 'inline_renew add' still has the HASH
	# Logically, this *cannot* be removed -- tct
	unset inline_hash

	[ ! $silent_remove ] && notice "Inline file removed: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_remove ()

# Rebuild inline index
inline_index_rebuild ()
{
	# TODO
	# TODO WARNING, inline_index_rebuild is a work in progress
	# TODO

	# Warn!
	confirm "Rebuild inline index file ? " "yes" \
		"WARNING: You are about to rebuild easytls-index.txt"

	# Check easytls-index.txt
	[ -f "$EASYTLS_INLINE_INDEX" ] || warn "Missing: $EASYTLS_INLINE_INDEX"

	# Do not over write current easytls-index.txt.backup
	[ -f "$EASYTLS_INLINE_INDEX.backup" ] && \
		die "Backup file already exists: $EASYTLS_INLINE_INDEX.backup"

	# Backup current easytls-index.txt
	[ -f "$EASYTLS_INLINE_INDEX" ] && \
		cp "$EASYTLS_INLINE_INDEX" "$EASYTLS_INLINE_INDEX.backup"

	# There is no other way to do this because we need the actual files
	# Get list of files from easytls directory
	etls_inline_file_list="$(ls -1 "$EASYTLS_PKI"/*.inline)"

	# Check openssl index.txt
	[ -f "$EASYRSA_INDEX" ] || die "Missing: $EASYRSA_INDEX"

	# This is where the duplicate names creep in
	# Get list of certs from openssl index.txt
	ersa_valid_cert_list="$(inline_index_openssl_valid_cn_list)"

	# Create new easytls index file
	printf "%s" "" > "$EASYTLS_INLINE_INDEX" \
		|| die "Failed to create $EASYTLS_INLINE_INDEX (permissions?)"

	# Create records from openssl Valid names list
	for i in $ersa_valid_cert_list
	do
		# Reset flag
		unset add_inline_record

		# Clear the previous HASH
		unset inline_hash

		# If the name is not a single word then the certificate
		# has been renewed in EasyRSA, which means:
		# There are two Valid record in openssl index.txt
		# with the same CommonName
		# Mitigate this disaster here
		name="$(printf "%s" "$i" | awk 1 ORS=' ')"
		name="${name%% *}"

		crt_serial=""
		inline_file="$EASYTLS_PKI/$name.inline"
		crt_file="$EASYRSA_PKI/issued/$name.crt"

		# If the list contains this name but there is no cert
		# then cannot recreate easytls-index
		# The EasyRSA PKI has been tainted
		help_note="EasyRSA has a record of $name but no certificate."
		[ -f "$crt_file" ] || die "Missing crt_file: $crt_file"
		unset help_note

		# If there is an inline file for this name
		# then recreate the inline easytls-index record
		# EasyTLS User can remove/create a new inline file
		# Note: The extra space ..
		[ -f "$inline_file" ] && {
			add_inline_record=1
			etls_inline_record_list="$etls_inline_record_list $name "
			}

		# If there is an inline-index record for this name
		# then do NOT add another
		if grep -q "^${name}[[:blank:]]" "$EASYTLS_INLINE_INDEX"
		then
			unset add_inline_record
		fi

		# Verify the openssl cert CN
		openssl_cert_cn="$(openssl_crt_cn)"
		[ "$name" = "$openssl_cert_cn" ] || \
			die "CommonName mismatch for :$name: :$openssl_cert_cn:"

		# This always returns the first crt_serial
		# Get the openssl crt_serial
		openssl_crt_serial

		[ $add_inline_record ] && inline_index_update add
	done

	OFS="$IFS"
	IFS='
'
	# Create records from easytls current inline files list
	for full_file_name in $etls_inline_file_list
	do
		# Reset flag
		unset add_inline_record

		# Clear the previous HASH
		unset inline_hash

		# Get name only from full file name
		# Yes, I know this is a bad idea .. raise an issue
		# https://github.com/TinCanTech/easy-tls/issues
		inline_file="$full_file_name"
		part_file_name="${full_file_name%*.inline}"
		name="${part_file_name##*/}"
		[ -f "$inline_file" ] || die "Missing: $inline_file"
		crt_serial="$(inline_crt_serial)"

		# If found an un-indexed inline file then index it
		inline_file_found_indexed="$(inline_index_search_valid_cn_list)"
		[ $inline_file_found_indexed -eq 0 ] && add_inline_record=1

		[ $add_inline_record ] && inline_index_update add
	done

	IFS="$OFS"
	unset OFS

	# Inform
	notice "Inline index file successfully rebuilt: $EASYTLS_INLINE_INDEX"
	print

	# Verify
	inline_status

} # => inline_index_rebuild ()


############################################################################
#
# EASYTLS INLINE Section
#

# Renew .inline file
inline_renew ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			0|1)	key_direction="$1" ;;
			add-dh)	cmd_opts="$cmd_opts add-dh" ;;
			nokey)	cmd_opts="$cmd_opts nokey" ;;
			*)	warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	inline_file="$EASYTLS_PKI/$name.inline"
	crt_file="$EASYRSA_PKI/issued/$name.crt"

	[ -f "$inline_file" ] || die "inline_renew: Missing: $inline_file"
	[ -f "$crt_file" ] || die "inline_renew: Missing: $crt_file"
	openssl_crt_serial

	# Collect the attributes of .inline file
	inline_is_base="$(grep -c '^# File name base:.*$' "$inline_file")"
	inline_is_tlsauth="$(grep -c '^<tls-auth>$' "$inline_file")"
	inline_is_tlscrypt="$(grep -c '^<tls-crypt>$' "$inline_file")"
	inline_is_tlscryptv2="$(grep -c '^<tls-crypt-v2>$' "$inline_file")"

	# Verify .inline is valid
	[ $inline_is_base -eq 1 ] || \
		die "File is not valid .inline: $inline_file"
	one_type=$((inline_is_tlsauth+inline_is_tlscrypt+inline_is_tlscryptv2))
	[ $one_type -le 1 ] || die "File is not valid .inline: $inline_file"

	# Determine the type of .inline file
	inline_type="tls-base"
	[ $inline_is_tlsauth -eq 1 ] && inline_type="tls-auth"
	[ $inline_is_tlscrypt -eq 1 ] && inline_type="tls-crypt"
	[ $inline_is_tlscryptv2 -eq 1 ] && inline_type="tls-crypt-v2"

	# If --key-direction is specified in command line but does not match
	# current inline setting then issue a warning
	if [ "$inline_type" = "tls-auth" ] && [ $key_direction ]
	then
		# Determine inline <key-direction>
		is_key_dir="$(inline_renew_key_direction)"
		case "$is_key_dir" in
		0|1)
			# Veify if command line want to change inline
			[ $key_direction -eq $is_key_dir ] || \
			warn "Command line will change inline key-direction"
		;;
		*)
			# Assume key-direction is missing from inline
			warn "TLS-auth key-direction missing"
		;;
		esac
	fi

	# Auto-detect --key-direction if not specified in command line
	# default to current inline file or no_key_direction
	if [ "$inline_type" = "tls-auth" ] && [ ! $key_direction ]
	then
		# Determine inline <key-direction>
		is_key_dir="$(inline_renew_key_direction)"
		case "$is_key_dir" in
			0|1)	key_direction="$is_key_dir" ;;
			*)	warn "TLS-auth key-direction missing" ;;
		esac
	fi

	# Confirm renew type
	confirm "Renew inline file ? " "yes" \
		"Renew: $inline_file as Type: $inline_type"

	# Make a backup of inline file incase renew fails
	[ -f "$inline_file.backup" ] && \
		die "Backup already exists: $inline_file.backup"
	cp "$inline_file" "$inline_file.backup" || \
		die "Unable to create backup: $inline_file.backup"

	# Remove the old .inline file
	# .inline HASH is checked prior to removal
	silent_remove=1
	inline_remove "$name"

	# Disable completion notices from sub processes
	silent_inline=1

	# Build the new .inline file
	case "$inline_type" in
		tls-base)
			silent_base=1
			inline_base "$name" $cmd_opts
			inline_index_update add
		;;
		tls-auth)
			inline_tls_auth "$name" "$key_direction" $cmd_opts
		;;
		tls-crypt)
			inline_tls_crypt_v1 "$name" $cmd_opts
		;;
		tls-crypt-v2)
			inline_tls_crypt_v2 "$name" $cmd_opts
		;;
		*)
			die "Unknown error inline_type: $inline_type"
		;;
	esac

	# Renew successful, remove the backup
	rm -f "$inline_file.backup"

	notice "Inline $inline_type file renewed: $inline_file"
} # => inline_renew ()

# Get and format openssl serial number output
openssl_crt_serial ()
{
	# Testing the file here is not suitable
	# [ -f "$crt_file" ] || die "Not found: crt_file = $crt_file"
	# get the serial number of the certificate -> serial=XXXX
	crt_serial="$("$EASYRSA_OPENSSL" x509 -in "$crt_file" -noout -serial)"
	# remove the serial= part -> we only need the XXXX part
	crt_serial=${crt_serial##*=}
}

# Extract the CommonName from openssl -subject
openssl_crt_cn ()
{
	"$EASYRSA_OPENSSL" x509 -in "$crt_file" \
		-noout -subject -nameopt sep_multiline | \
		grep '^[[:blank:]]*CN=.*$' | \
		sed 's/^[[:blank:]]*CN=//g'
}

# Get current inline key direction
inline_renew_key_direction ()
{
	grep '^key-direction [01]$' "$inline_file" | awk '{print $2}'
}

# Create inline credentials file from Easy-RSA PKI
inline_base ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	while [ -n "$1" ]; do
		case "$1" in
			nokey) no_x509_key=1 ;;
			add-dh) inline_dh_file=1 ;;
			*) warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	ca_file="$EASYRSA_PKI/ca.crt"
	crt_file="$EASYRSA_PKI/issued/$name.crt"
	key_file="$EASYRSA_PKI/private/$name.key"
	inline_file="$EASYTLS_PKI/$name.inline"
	help_note="Run 'easytls inline-status' to verify certificate revokation."

	[ -f "$crt_file" ] || die "\
Certificate file missing or revoked: $crt_file
$help_note"

	if [ "$no_x509_key" ]
	then
		# Key file is not required
		:
	else
		# Key file is required
		[ -f "$key_file" ] || die "\
Key file missing or revoked: $key_file
$help_note"
	fi

	if [ "$inline_dh_file" ]
	then
		# dh file is required
		help_note="Use --dh=<file_name> to specify an alternate dh file."
		default_dh_file="$EASYRSA_PKI/dh.pem"
		EASYRSA_DH_FILE="${EASYRSA_DH_FILE:-"$default_dh_file"}"
		[ -f "$EASYRSA_DH_FILE" ] || die "\
Diffy Hellman parameters file missing: $EASYRSA_DH_FILE
$help_note"
	fi
	unset help_note

	# get the serial number of the certificate from openssl
	crt_serial=""
	openssl_crt_serial

	# Check .inline file does not exist
	if [ "$EASYTLS_BATCH" ]
	then
		rm -f "$inline_file"
	else
		[ -f "$inline_file" ] && die "Inline file exists: $inline_file"
	fi

	# Build .inline file
	{	printf "%s\n" "# File name base: $name"
		printf "%s\n" "# Serial number: $crt_serial"
		printf "%s\n" ""
		printf "%s\n" "<cert>"
		cat "$crt_file"
		printf "%s\n" "</cert>"
		printf "%s\n" ""
		printf "%s\n" "<key>"

		if [ "$no_x509_key" ]
		then
			printf "%s\n" \
			" * Replace this line with your complete x509 key file *"
		else
			cat "$key_file"
		fi

		printf "%s\n" "</key>"
		printf "%s\n" ""
		printf "%s\n" "<ca>"
		cat "$ca_file"
		printf "%s\n" "</ca>"
		printf "%s\n" ""

		if [ "$inline_dh_file" ]
		then
			printf "%s\n" "<dh>"
			cat "$EASYRSA_DH_FILE"
			printf "%s\n" "</dh>"
			printf "%s\n" ""
		fi

	} > "$inline_file" || die "Failed to create inline file: $inline_file"

	# Update INLINE index
	# Only if this is the root caller
	[ ! $silent_base ] && inline_index_update add

	[ ! $silent_base ] && notice "Inline base file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_base ()

# Append TLS auth file to base file
inline_tls_auth ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			0|1)	key_direction="$1" ;;
			add-dh)	cmd_opts="$cmd_opts add-dh" ;;
			nokey)	cmd_opts="$cmd_opts nokey" ;;
			*) 	warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	tls_auth_key="$EASYTLS_PKI/tls-auth.key"
	inline_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_auth_key" ] || \
		die "TLS key file does not exist: $tls_auth_key"

	case "$key_direction" in
		0|1)
			# Using user specified --key-direction
			:
		;;
		*)
			# No key-direction found, not inlining --key-direction
			[ $silent_inline ] || \
				warn "TLS-auth key-direction missing"
			no_key_direction=1
		;;
	esac

	# Inline base file
	silent_base=1
	inline_base "$name" $cmd_opts

	{	printf "%s\n" "# TLS auth"
		printf "%s\n" ""

		if [ ! $no_key_direction ]
		then
			printf "%s\n" "key-direction $key_direction"
			printf "%s\n" ""
		fi

		printf "%s\n" "<tls-auth>"
		cat "$tls_auth_key"
		printf "%s\n" "</tls-auth>"
		printf "%s\n" ""
	} >> "$inline_file" || die "Failed to create inline file: $inline_file"

	# Hash inline file and add hash to index
	inline_index_update add

	[ ! $silent_inline ] && \
		notice "Inline TLS auth file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_tls_auth ()

# Append TLS crypt file to base file
inline_tls_crypt_v1 ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			add-dh) cmd_opts="$cmd_opts add-dh" ;;
			nokey) cmd_opts="$cmd_opts nokey" ;;
			*) warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	tls_file="$EASYTLS_PKI/tls-crypt.key"
	inline_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_file" ] || die "TLS key file does not exist: $tls_file"

	# Inline base file
	silent_base=1
	inline_base "$name" $cmd_opts

	{	printf "%s\n" "# TLS crypt"
		printf "%s\n" ""
		printf "%s\n" "<tls-crypt>"
		cat "$tls_file"
		printf "%s\n" "</tls-crypt>"
		printf "%s\n" ""
	} >> "$inline_file" || die "Failed to create inline file: $inline_file"

	# Hash inline file and add hash to index
	inline_index_update add

	[ ! $silent_inline ] && \
		notice "Inline TLS crypt file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_tls_crypt_v1 ()

# Append TLS crypt v2 file to base file
inline_tls_crypt_v2 ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			add-dh) cmd_opts="$cmd_opts add-dh" ;;
			nokey) cmd_opts="$cmd_opts nokey" ;;
			*) warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	tls_file="$EASYTLS_PKI/$name-tls-crypt-v2.key"
	inline_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_file" ] || die "TLS key file does not exist: $tls_file"
	[ -f "$inline_file" ] && die "Inline file already exist: $inline_file"

	# Inline base file
	silent_base=1
	inline_base "$name" $cmd_opts

	{	printf "%s\n" "# TLS crypt v2"
		printf "%s\n" ""
		printf "%s\n" "<tls-crypt-v2>"
		cat "$tls_file"
		printf "%s\n" "</tls-crypt-v2>"
		printf "%s\n" ""
	} >> "$inline_file" || die "Failed to create inline file: $inline_file"

	# Hash inline file and add hash to index
	inline_index_update add

	[ ! $silent_inline ] && \
		notice "Inline TLS crypt v2 file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_tls_crypt_v2 ()


############################################################################
#
# EASYTLS BUILD Section
#

# Create TLS auth file
build_tls_auth ()
{
	# This is allowed without a complete Easy-RSA PKI
	# Verify Easy-TLS and Easy-RSA have been correctly setup
	verify_tls_init

	# Verify OpenVPN version and use correct syntax to --genkey
	case $openvpn_version in
	2.5) build_string="--genkey tls-auth" ;;
	2.4) build_string="--genkey --secret" ;;
	*) die "Unsupported OpenVPN version $openvpn_version" ;;
	esac

	key_file="$EASYTLS_PKI/tls-auth.key"

	[ -f "$key_file" ] && \
		die "TLS auth key already exists: $key_file"

	"$EASYTLS_OPENVPN" $build_string "$key_file" || \
		die "Failed to create TLS auth key: $key_file"

	notice "TLS auth key created: $key_file"
} # => build_tls_auth ()

# Create TLS crypt v1 file
build_tls_crypt_v1 ()
{
	# This is allowed without a complete Easy-RSA PKI
	# Verify Easy-TLS and Easy-RSA have been correctly setup
	verify_tls_init

	# Verify OpenVPN version and use correct syntax to --genkey
	case $openvpn_version in
	2.5) build_string="--genkey tls-crypt" ;;
	2.4) build_string="--genkey --secret" ;;
	*) die "Unsupported OpenVPN version $openvpn_version" ;;
	esac

	key_file="$EASYTLS_PKI/tls-crypt.key"

	[ -f "$key_file" ] && \
		die "TLS crypt v1 key already exists: $key_file"

	"$EASYTLS_OPENVPN" $build_string "$key_file" || \
		die "Failed to create TLS crypt v1 key: $key_file"

	notice "TLS crypt v1 key created: $key_file"
} # => build_tls_crypt_v1 ()

# Create TLS crypt v2 server file
build_tls_crypt_v2_server ()
{
	[ $# -ge 1 ] || die "Required option(s): <server_filename_base>"

	# This is allowed without a complete Easy-RSA PKI
	# Verify Easy-TLS and Easy-RSA have been correctly setup
	verify_tls_init

	# Verify OpenVPN version - Requires openvpn version 2.5
	[ "$openvpn_version" = "2.5" ] || die "OpenVPN version 2.5 required."

	# and use correct syntax to --genkey
	build_string="--genkey tls-crypt-v2-server"

	srv_name="$1"
	srv_cert="$EASYRSA_PKI/issued/$srv_name.crt"
	key_file="$EASYTLS_PKI/$srv_name-tls-crypt-v2.key"

	[ -f "$srv_cert" ] || \
		die "Easy-TLS requires that the x509 certificate has been built.
Missing file: $srv_cert"

	[ -f "$key_file" ] && die "Server file already exists: $key_file"

	"$EASYTLS_OPENVPN" $build_string "$key_file" || \
		die "Failed to create tls-crypt-v2-server key: $key_file"

	notice "TLS crypt v2 server key created: $key_file"
} # => build_tls_crypt_v2_server ()

# Create TLS crypt v2 client file
build_tls_crypt_v2_client ()
{
	[ $# -ge 2 ] || \
	die "Required option(s): <server_filename_base> <client_filename_base>"

	[ $# -eq 2 ] || \
	warn "Ignoring unknown option(s): $3 $4 $5 .. etc."

	# Verify Easy-TLS and Easy-RSA have been correctly setup
	verify_tls_init

	# Need the CA
	verify_ca_init

	# Verify OpenVPN version - Requires openvpn version 2.5
	[ "$openvpn_version" = "2.5" ] || die "OpenVPN version 2.5 required."

	# and use correct syntax to --genkey
	build_string="--genkey tls-crypt-v2-client"

	ca_cert="$EASYRSA_PKI/ca.crt"
	srv_name="$1"
	srv_cert="$EASYRSA_PKI/issued/$srv_name.crt"
	cli_name="$2"
	cli_cert="$EASYRSA_PKI/issued/$cli_name.crt"
	shift 2

	[ "$srv_name" = "$cli_name" ] && \
		die "Server name cannot be the same as the client name."

	[ -f "$srv_cert" ] || \
		die "Easy-TLS requires that the x509 certificate has been built.
Missing srv file: $srv_cert"

	[ -f "$cli_cert" ] || \
		die "Easy-TLS requires that the x509 certificate has been built.
Missing cli file: $cli_cert"

	in_file="$EASYTLS_PKI/$srv_name-tls-crypt-v2.key"
	key_file="$EASYTLS_PKI/$cli_name-tls-crypt-v2.key"

	[ -f "$in_file" ] || die "Server key does not exist: $in_file"
	[ -f "$key_file" ] && die "Client key already exists: $key_file"

	metadata=""
	b64_metadata=""
	b64_enc_metadata

	"$EASYTLS_OPENVPN" --tls-crypt-v2 "$in_file" \
		$build_string "$key_file" "$b64_metadata" || \
		die "Failed to create tls-crypt-v2-client key: $key_file"

	notice "TLS crypt v2 client key created: $key_file"
} # => build_tls_crypt_v2_client ()

# Base64 encode metadata fields
b64_enc_metadata ()
{
	# metadata strings:
	#
	# If you are going to do it then do it right
	#
	# 1.  'metadata_version_easytls'
	#
	# 2.a CA Fingerprint, contiguous single field
	#     `openssl output` Change space to underscore
	#
	# 3.  Client certificate serial, contiguous single field
	#     `openssl output` Drop the 'serial='
	#
	# 4.  Client CommonName:
	#
	# 5.  Creation date of this key:
	#     %s     seconds since 1970-01-01 00:00:00 UTC
	#
	# 6.  Custom Group string:
	#     contiguous single field

	# metadata_version
	metadata_version='metadata_version_easytls'

	# CA fingerprint
	ca_fingerprint="$(fn_ca_fingerprint)"

	# Push CA Fingerprint to Easytls lock
	easytls_lock="$ca_fingerprint"

	# Performance
	if [ $save_cache_id ]
	then
		save_cache_id
	fi

	# get the serial number of the certificate from openssl
	crt_file="$cli_cert"
	crt_serial=""
	openssl_crt_serial

	# Set creation date
	key_date="$(date +%s)"

	# Build metadata
	metadata="$metadata_version $easytls_lock $crt_serial $cli_name $key_date"
	# Append --custom-group
	if [ -n "$EASYTLS_TLSCV2_CG" ]
	then
		metadata="$metadata $EASYTLS_TLSCV2_CG"
	fi

	[ $EASYTLS_TRAVIS_CI ] && debug_metadata

	[ $EASYTLS_VERBOSE ] && printf "%s\n" "metadata: $metadata"
	# Base64 encode metadata
	b64_metadata="$(printf "%s" "$metadata"|"$EASYRSA_OPENSSL" enc -e -a -A)"
} # => b64_enc_metadata ()

# Generate CA fingerprint
fn_ca_fingerprint ()
{
	"$EASYRSA_OPENSSL" x509 -in "$ca_cert" -noout -fingerprint | \
		 sed 's/ /_/g'
} # => fn_ca_fingerprint ()

# DEBUG metadata
debug_metadata ()
{
	metadata_debug="$EASYTLS_PKI/tls-crypt-v2-$cli_name.mdd"
	printf "%s\n" "$metadata" > "$metadata_debug"
}

# Save the ID
save_cache_id ()
{
	# Performance enhancement
	printf "%s\n" "$easytls_lock" > "$EASYTLS_CA_IDENTITY" || \
		die "Failed to create CA Identify: $EASYTLS_CA_IDENTITY"
}


############################################################################
#
# DISABLED LIST Section
#

# Manage tls-crypt-v2-verify default tls/disabled_list.txt
tls_crypt_v2_verify_disable_list ()
{
	name="$2"
	crt_file="$EASYRSA_PKI/issued/$name.crt"
	[ -f "$crt_file" ] || die "Cannot find certificate: $crt_file"

	# get the serial number of the certificate from openssl
	crt_serial=""
	openssl_crt_serial

	# Check list for duplicates
	serial_disabled_status="$(search_disabled_list)"
	[ $serial_disabled_status -lt 2 ] || die "Serial is duplicated"

	# Serial number disable or enable and check
	case $1 in
	disable) # Add serial number to the list
		serial_disabled_status="$(search_disabled_list)"
		if [ $serial_disabled_status -eq 0 ]
		then
			disabled_list_updated=1
			printf "%s\n" "$crt_serial $name" >> \
			"$EASYTLS_DISABLED_LIST"
		fi
		serial_disabled_status="$(search_disabled_list)"
		[ $serial_disabled_status -eq 1 ] || die "Serial disabled failed"
	;;
	enable) # Remove serial number from the list
		serial_disabled_status="$(search_disabled_list)"
		if [ $serial_disabled_status -eq 1 ]
		then
			disabled_list_updated=1
			sed -i "/^${crt_serial}[[:blank:]]${name}$/d" \
			"$EASYTLS_DISABLED_LIST"
		fi
		serial_disabled_status="$(search_disabled_list)"
		[ $serial_disabled_status -eq 0 ] || die "Serial enabled failed"
	;;
	*) die "tls_crypt_v2_verify action invalid: $1"
	;;
	esac

	# Update time-stamp
	update_text="# Updated: $(date) -- $1: $name"
	sed -i '/^# Updated:.*$/d' "$EASYTLS_DISABLED_LIST"
	printf "%s\n" "$update_text" >> "$EASYTLS_DISABLED_LIST"
	if [ $disabled_list_updated ]
	then
		notice "Updated disabled list: $name ${1}d"
	else
		notice "No change: $name is already ${1}d"
	fi
} # => tls_crypt_v2_verify_disable_list ()

# Search disabled list for serial number
search_disabled_list ()
{
	grep -c "^${crt_serial}[[:blank:]]${name}$" "$EASYTLS_DISABLED_LIST"
}

############################################################################
#
# EASYTLS SETUP Section
#

# vars setup
# Here sourcing of 'vars' if present occurs. If not present, defaults are used
# to support running without a sourced config format
vars_setup()
{
	# Try to locate a 'vars' file in order of location preference.
	# If one is found, source it
	vars=

	# set up program path
	prog_file="$0"
	prog_dir="${prog_file%/*}"
	prog_vars="${prog_dir}/vars"
	# set up PKI path
	pki_vars="${EASYRSA_PKI:-$PWD/pki}/vars"

	# command-line path:
	if [ ! -z "$EASYRSA_VARS_FILE" ]; then
	  if [ ! -f "$EASYRSA_VARS_FILE" ]; then
		# If the --vars option does not point to a file
		# then show helpful error.
			die "The file '$EASYRSA_VARS_FILE' was not found."
		fi
		vars="$EASYRSA_VARS_FILE"
	# PKI location, if present:
	elif [ -f "$pki_vars" ]; then
		vars="$pki_vars"
	# EASYRSA, if defined:
	elif [ -n "$EASYRSA" ] && [ -f "$EASYRSA/vars" ]; then
		vars="$EASYRSA/vars"
	# program location:
	elif [ -f "$prog_vars" ]; then
		vars="$prog_vars"
	# vars of last resort ./vars
	elif [ -f "./vars" ]; then
		vars="./vars"
		warn "'./vars' of last resort !"
	fi
	
	# If a vars file was located, source it
	# If $EASYRSA_NO_VARS is defined (not blank) this is skipped
	if [ -z "$EASYRSA_NO_VARS" ] && [ -n "$vars" ]; then
		EASYRSA_CALLER=1
		. "$vars"
		# Make this a verbose only noteice
		#notice "Note: using Easy-RSA configuration from: $vars"
	fi
	
	# Set defaults, preferring existing env-vars if present
	set_var
	set_var EASYRSA			"$prog_dir"
	set_var EASYRSA_OPENSSL		"openssl"
	set_var EASYRSA_PKI		"$PWD/pki"
	set_var EASYRSA_TEMP_DIR	"$EASYRSA_PKI"
	set_var EASYRSA_INDEX		"$EASYRSA_PKI/index.txt"

	set_var EASYTLS_PKI		"$EASYRSA_PKI/easytls"
	set_var EASYTLS_INLINE_INDEX	"$EASYTLS_PKI/easytls-inline-index.txt"
	set_var EASYTLS_OPENVPN		"openvpn"
	set_var EASYTLS_DISABLED_LIST	"$EASYTLS_PKI/easytls-disabled.txt"
	set_var EASYTLS_CA_IDENTITY	"$EASYTLS_PKI/easytls-ca-identity.txt"
	set_var EASYTLS_CA_RANDOM	"$EASYTLS_PKI/easytls-ca-random.txt"

	# Assign value to $EASYRSA_TEMP_DIR_session and work around
	# Windows mktemp bug when parent dir is missing
	if [ -z "$EASYRSA_TEMP_DIR_session" ]; then
		if [ -d "$EASYRSA_TEMP_DIR" ]; then
			EASYRSA_TEMP_DIR_session="$(mktemp_make_temp)"
		else
			# Directory does not exist then we have not run init-pki
			mkdir -p "$EASYRSA_TEMP_DIR" || \
				die "Cannot create $EASYRSA_TEMP_DIR"

			EASYRSA_TEMP_DIR_session="$(mktemp_make_temp)"
			rm -rf "$EASYRSA_TEMP_DIR"
		fi
	fi
} # vars_setup()

# mktemp return temp_dir name
mktemp_make_temp ()
{
	mktemp -du "$EASYRSA_TEMP_DIR/easy-rsa-$$.XXXXXX"
} # => mktemp_make_temp ()

# variable assignment by indirection when undefined; merely exports
# the variable when it is already defined (even if currently null)
# Sets $1 as the value contained in $2 and exports (may be blank)
set_var()
{
	[ $# -eq 0 ] && return
	var=$1
	shift
	value="$*"
	eval "export $var=\"\${$var-$value}\""
} #=> set_var()

# Set the Easy-TLS version
easy_tls_version ()
{
	EASYTLS_VERSION="1.27"
	print "Easy-TLS version: $EASYTLS_VERSION"
} # => easy_tls_version ()

############################################################################
#
# EASYTLS COMMAND Section
#

########################################
# Invocation entry point:


# Be secure with a restrictive umask
[ -z "$EASYTLS_NO_UMASK" ] && umask 077

# Parse options
while :; do
	# Separate option from value:
	opt="${1%%=*}"
	val="${1#*=}"
	empty_ok="" # Empty values are not allowed unless excepted

	case "$opt" in
	--batch)
		empty_ok=1
		export EASYTLS_BATCH=1 ;;
	--pki-dir)
		export EASYRSA_PKI="$val" ;;
	--vars)
		export EASYRSA_VARS_FILE="$val" ;;
	--verbose)
		empty_ok=1
		export EASYTLS_VERBOSE=1 ;;
	--silent)
		empty_ok=1
		export EASYTLS_SILENT=1 ;;
	--dh)
		export EASYRSA_DH_FILE="$val" ;;
	--custom-group)
		export EASYTLS_TLSCV2_CG="$val" ;;
	--openvpn)
		export EASYTLS_OPENVPN="$val" ;;
	--disable-auto-check)
		empty_ok=1
		auto_check_disabled=1 ;;
	--cache-id)
		empty_ok=1
		save_cache_id=1 ;;
	--exp-secure)
		empty_ok=1
		export EASYTLS_SECURE=1 ;;
	*)
		break ;;
	esac

	# fatal error when no value was provided
	if [ ! $empty_ok ] && { [ "$val" = "$1" ] || [ -z "$val" ]; }; then
		die "Missing value to option: $opt"
	fi

	shift
done

# Intelligent env-var detection and auto-loading:
vars_setup

# Register cleanup on EXIT
trap "cleanup" EXIT
# When SIGHUP, SIGINT, SIGQUIT, SIGABRT and SIGTERM,
# explicitly exit to signal EXIT (non-bash shells)
trap "exit 1" 1
trap "exit 2" 2
trap "exit 3" 3
trap "exit 6" 6
trap "exit 14" 15

# determine how we were called, then hand off to the function responsible
cmd="$1"
[ -n "$1" ] && shift # scrape off command
case "$cmd" in
	init-tls)
		init_tls "$@"
		;;
	build-tls-auth)
		build_tls_auth "$@"
		;;
	build-tls-crypt)
		build_tls_crypt_v1 "$@"
		;;
	build-tls-crypt-v2-server)
		build_tls_crypt_v2_server "$@"
		;;
	build-tls-crypt-v2-client)
		build_tls_crypt_v2_client "$@"
		;;
	inline-base)
		inline_base "$@"
		;;
	inline-tls-auth)
		inline_tls_auth "$@"
		;;
	inline-tls-crypt)
		inline_tls_crypt_v1 "$@"
		;;
	inline-tls-crypt-v2)
		inline_tls_crypt_v2 "$@"
		;;
	inline-remove)
		inline_remove "$@"
		;;
	inline-renew)
		inline_renew "$@"
		;;
	inline-status)
		inline_status "$@"
		;;
	inline-show)
		inline_show "$@"
		;;
	inline-index-rebuild)
		inline_index_rebuild "$@"
		;;
	inline-expire)
		inline_expire "$@"
		;;
	cert-expire)
		cert_expire "$@"
		;;
	disable)
		tls_crypt_v2_verify_disable_list "disable" "$@"
		;;
	enable)
		tls_crypt_v2_verify_disable_list "enable" "$@"
		;;
	version|-v|--version)
		easy_tls_version
		exit 0
		;;
	""|help|-h|--help|--usage)
		cmd_help "$1"
		exit 0
		;;
	*)
		die "Unknown command '$cmd'. Run without commands for help."
		;;
esac

# EasyTLS auto-check
inline_auto_check

# vim: ft=sh nu ai sw=8 ts=8 noet
