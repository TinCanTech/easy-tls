#!/bin/sh

# Easy-TLS -- A Shell-based Easy-RSA extension utility to help manage
#               * OpenVPN specific TLS keys
#               * Easy-RSA based x509 security credentials
#               * Verified 'inline' combined OpenVPN node packages
#
# Copyright (C) 2020 Richard Bonhomme (Friday 13th of March 2020)
# https://github.com/TinCanTech
# tincanteksup@gmail.com
# All Rights reserved.
#
# This code is released under version 2 of the GNU GPL
# See LICENSE of this project for full licensing details.
#
# Acknowledgement:
# This utility is "written in the style of" and "borrows heavily from" Easy-RSA
# See: https://github.com/OpenVPN/easy-rsa
#
# Easy-TLS requirements:
# + Easy-RSA Version 3.X
# + OpenVPN Version 2.X
#



# Help/usage output to stdout
usage()
{
	# command help:
	print "
Easy-TLS usage and overview

NOTE: Easy-TLS requires that you have a working EasyRSA PKI in place.

USAGE: easytls [options] COMMAND [command-options]

A list of commands is shown below. To get detailed usage and help for a
command, run:
  ./easytls help COMMAND

For a listing of options that can be supplied before the command, use:
  ./easytls help options

Here is the list of commands available with a short syntax reminder. Use the
'help' command above to get full usage details.

  init-tls
  build-tls-auth
  build-tls-crypt
  build-tls-crypt-v2-server <filename_base>
  build-tls-crypt-v2-client <server_filename_base> <client_filename_base>
  build-inline-base <filename_base>
  build-inline-tls-auth <filename_base> <key_direction>
  build-inline-tls-crypt <filename_base>
  build-inline-tls-crypt-v2 <filename_base>
  remove-inline <filename_base>
  status-inline [update?]
  test-inline (Requires root) (TODO)
"

	# collect/show dir status:
	err_source="Not defined: vars autodetect failed and no value provided"
	work_dir="${EASYRSA:-$err_source}"
	pki_dir="${EASYRSA_PKI:-$err_source}"
	tls_dir="${EASYTLS_PKI:-$err_source}"
	print "\
DIRECTORY STATUS (commands would take effect on these locations)
  EASYRSA: $work_dir
      PKI: $pki_dir
      TLS: $tls_dir
"
} # => usage()

# Detailed command help
# When called with no args, calls usage(), otherwise shows help for a command
cmd_help()
{
	text=""
	opts=""
	case "$1" in
		init-tls) text="
  init-tls
      Removes & re-initializes the TLS key dir" ;;
		build-tls-auth) text="
  build-tls-auth
      Create an OpenVPN TLS auth PSK (tls-auth.key)" ;;
		build-tls-crypt) text="
  build-tls-crypt
      Create an OpenVPN TLS crypt PSK (tls-crypt.key)" ;;
		build-tls-crypt-v2-server) text="
  build-tls-crypt-v2-server <filename_base>
      Create an OpenVPN TLS crypt V2 Server key" ;;
		build-tls-crypt-v2-client) text="
  build-tls-crypt-v2-client <filename_base>
      Create an OpenVPN TLS crypt V2 Client key" ;;
		build-inline-base) text="
  build-inline-base <filename_base>
      Create a complete OpenVPN node package from Easy-RSA files only
      for VPN node <filename_base>" ;;
		build-inline-tls-auth) text="
  build-inline-tls-auth <filename_base> <key_direction>
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS auth file
      <key_direction> either '0' (For server) or '1' (For client)" ;;
		build-inline-tls-crypt) text="
  build-inline-tls-crypt <filename_base>
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS crypt file" ;;
		build-inline-tls-crypt-v2) text="
  build-inline-tls-crypt-v2 <filename_base>
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS crypt v2 file" ;;
		remove-inline) text="
  remove-inline <filename_base>
      Delete <filename_base>.inline when Easy-RSA certificate is revoked" ;;
		status) text="
  status [update]
      Compare Easy-RSA certificate(s) to Easy-TLS inline(s) status
      update - rebuild inline-index.tls" ;;
		options)
			opt_usage ;;
		"")
			usage ;;
		*) text="
  Unknown command: '$1' (try without commands for a list of commands)" ;;
	esac

	# display the help text
	print "$text"
	[ -n "$opts" ] && print "
      cmd-opts is an optional set of command options from this list:
$opts"
} # => cmd_help()


# Options usage
opt_usage()
{
	print "
Easy-TLS Global Option Flags

The following options may be provided before the command. Options specified
at runtime override env-vars and any 'vars' file in use. Unless noted,
non-empty values to options are mandatory.

General options:

--batch         : set automatic (no-prompts when possible) mode
--pki-dir=DIR   : declare the PKI directory
--vars=FILE     : define a specific 'vars' file to use for Easy-RSA config
--tls-dir=DIR   : declare the TLS directory

"
} # => opt_usage()

# Wrapper around printf - clobber print since it's not POSIX anyway
print() { printf "%s\n" "$*"; }

# Exit fatally with a message to stderr
# present even with EASYRSA_BATCH as these are fatal problems
die()
{
	easy_tls_version
	print "
Easy-TLS error:

$1" 1>&2
	exit "${2:-1}"
} # => die()

# remove temp files and do terminal cleanups
cleanup()
{
	[ -z "$EASYRSA_TEMP_DIR_session" ] || rm -rf "$EASYRSA_TEMP_DIR_session"
	(stty echo 2>/dev/null) || { (set -o echo 2>/dev/null) && set -o echo; }
	echo "" # just to get a clean line
} # => cleanup()

# non-fatal warning output
warn()
{
	[ ! "$EASYTLS_BATCH" ] && \
		print "
$1" 1>&2
} # => warn()

# informational notices to stdout
notice()
{
	[ ! "$EASYTLS_BATCH" ] && \
		print "
$1"
} # => notice()

# intent confirmation helper func
# returns without prompting in EASYTLS_BATCH
confirm()
{
	[ "$EASYTLS_BATCH" ] && return
	prompt="$1"
	value="$2"
	msg="$3"
	input=""
	print "
$msg

Type the word '$value' to continue, or any other input to abort."
	printf %s "  $prompt"
	read input
	[ "$input" = "$value" ] && return
	notice "Aborting without confirmation."
	exit 9
} # => confirm()

vars_source_check() {
	# Check for defined EASYRSA_PKI
	[ -n "$EASYRSA_PKI" ] || die "\
EASYRSA_PKI env-var undefined"
} # => vars_source_check()

# Basic sanity-check of PKI init and complain if missing
verify_pki_init () {
	help_note="Run easyrsa without commands for usage and command help."

	# check that the pki dir exists
	vars_source_check
	[ -d "$EASYRSA_PKI" ] || die "\
Easy-TLS requires that you have initialised your Easy-RSA PKI.

Easy-RSA error:

EASYRSA_PKI does not exist (perhaps you need to run init-pki)?
Expected to find the EASYRSA_PKI at: $EASYRSA_PKI
$help_note"

	# verify expected dirs present:
	for i in private reqs; do
		[ -d "$EASYRSA_PKI/$i" ] || die "\
Easy-TLS requires that you have initialised your Easy-RSA PKI.

Easy-RSA error:

Missing expected directory: $i (perhaps you need to run init-pki?)
$help_note"
	done
} # => verify_pki_init()

# Verify core CA files present
verify_ca_init () {
	help_note="Run without commands for usage and command help."

	# First check the PKI has been initialized
	verify_pki_init

	# Verify expected files are present. Allow files to be regular files
	# (or symlinks), but also pipes, for flexibility with ca.key
	for i in serial index.txt index.txt.attr ca.crt private/ca.key; do
		if [ ! -f "$EASYRSA_PKI/$i" ] && [ ! -p "$EASYRSA_PKI/$i" ]; then
			[ "$1" = "test" ] && return 1
			die "\
Easy-TLS TLS crypt v2 requires that you have built your EASY-RSA PKI node certificates.

Easy-RSA error:

Missing expected CA file: $i (perhaps you need to run build-ca?)
$help_note"
		fi
	done

	# When operating in 'test' mode, return success.
	# test callers don't care about CA-specific dir structure
	#[ "$1" = "test" ] && return 0

	# verify expected CA-specific dirs:
	for i in issued certs_by_serial
	do
		[ -d "$EASYRSA_PKI/$i" ] || die "\
Easy-RSA error:

Missing expected CA dir: $i (perhaps you need to run build-ca?)
$help_note"
	done

	# explicitly return success for callers
	return 0

} # => verify_ca_init()

# Verify Openvpn is available
verify_openvpn ()
{
	if which "$EASYTLS_OPENVPN" > /dev/null
	then
		return 0
	else
		die "OpenVPN not found: $EASYTLS_OPENVPN"
	fi
} # => verify_openvpn ()

# Verify Openvpn version, 2.5 required for TLS crypt v2, 2.4 required for TLS crypt v1
verify_openvpn_version ()
{
	EASYTLS_OPENVPN_VERSION_REQ_MAJOR="$1"
	[ -z "$EASYTLS_OPENVPN_VERSION_REQ_MAJOR" ] && die "Openvpn Major Version required not set."
	EASYTLS_OPENVPN_VERSION="$("$EASYTLS_OPENVPN" --version | grep ^OpenVPN | awk '{print $2}')"
	EASYTLS_OPENVPN_VERSION_INTS="$(printf "%s" "$EASYTLS_OPENVPN_VERSION" | sed "s/[^0123456789]/\ /g")"

	# SC2039: In POSIX sh, lexicographical < is undefined.

	EASYTLS_OPENVPN_VERSION_MAIN="$(printf "%s" "$EASYTLS_OPENVPN_VERSION_INTS" | awk '{print $1}')"
	EASYTLS_OPENVPN_VERSION_MAJOR="$(printf "%s" "$EASYTLS_OPENVPN_VERSION_INTS" | awk '{print $2}')"
	EASYTLS_OPENVPN_VERSION_MINOR="$(printf "%s" "$EASYTLS_OPENVPN_VERSION_INTS" | awk '{print $3}')"

	EASYTLS_OPENVPN_VERSION_MAIN="${EASYTLS_OPENVPN_VERSION_MAIN:-0}"
	EASYTLS_OPENVPN_VERSION_MAJOR="${EASYTLS_OPENVPN_VERSION_MAJOR:-0}"
	EASYTLS_OPENVPN_VERSION_MINOR="${EASYTLS_OPENVPN_VERSION_MINOR:-0}"

	[ $EASYTLS_OPENVPN_VERSION_MAIN -lt 2 ] && die "Openvpn 2.5 required, Found $EASYTLS_OPENVPN_VERSION"
	[ $EASYTLS_OPENVPN_VERSION_MAJOR -lt $EASYTLS_OPENVPN_VERSION_REQ_MAJOR ] && \
		die "Openvpn 2.$EASYTLS_OPENVPN_VERSION_REQ_MAJOR required, Found $EASYTLS_OPENVPN_VERSION"
	[ $EASYTLS_OPENVPN_VERSION_MINOR -lt 0 ] && die "Openvpn 2.X.X required, Found $EASYTLS_OPENVPN_VERSION"
} # => verify_openvpn_version ()

# Verify TLS has been initialised
verify_tls_init ()
{
	verify_openvpn
	[ -d "$EASYTLS_PKI" ] || die "TLS has not been initialised, run init-tls"
} # => verify_tls_init ()

# init-tls backend:
init_tls ()
{
	# Easy-TLS requires that your Easy-RSA PKI is initialised
	verify_pki_init
	# If EASYTLS_PKI exists, confirm before we rm -rf (skiped with EASYTLS_BATCH)
	if [ -d "$EASYTLS_PKI" ]; then
		confirm "Confirm removal: " "yes" "
WARNING!!!

You are about to remove the EASYTLS_PKI at: $EASYTLS_PKI
and initialize a fresh TLS PKI here."
		# now remove it:
		rm -rf "$EASYTLS_PKI" || die "Removal of TLS dir failed. Check/correct errors above"
	fi

	# Create tls dir in Easyrsa PKI dir
	mkdir -p "$EASYTLS_PKI" || die "Failed to create TLS dir (permissions?)"

	# Create tls dir index file
	printf "%s" > "$EASYTLS_INLINE_INDEX"

	notice "\
init-tls complete; you may now create TLS keys.
Your newly created TLS dir is: $EASYTLS_PKI
"
	return 0
} # => init_tls ()

# Show differences between Easy-TLS vs Easy-RSA cert revokation
status_inline ()
{
	EASYRSA_INDEX="$EASYRSA_PKI/index.txt"
	[ -f "$EASYRSA_INDEX" ] || die "Missing Easy-RSA: $EASYRSA_INDEX"

	easyrsa_valid_serial_list=""
	easyrsa_revoked_serial_list=""
	easytls_valid_serial_list=""
	#easytls_revoked_serial_list="" # Not used

	# List Easy-RSA Valid certs
	status_easyrsa_valid

	# List Easy-RSA Revoked certs
	status_easyrsa_revoked

	[ -f "$EASYTLS_INLINE_INDEX" ] || return

	# List Easy-TLS Valid certs
	status_easytls_valid

	# List Easy-TLS Revoked certs
	#status_easytls_revoked # Not used

	# List mismatches
	status_easytls_mismatch
} #=> status ()

# Print Valid certs from Easy-RSA
status_easyrsa_valid ()
{
	print "Easy-RSA: Valid certificates:"
	grep "^V" "$EASYRSA_INDEX" | awk '{ print $5 " " $3 }' | sed "s\`^/CN=\`\`g" | \
		awk '{ print "  Certificate CN: " $1 " is Valid - Serial number:" $2 }'
	temp_var="$(grep "^V" "$EASYRSA_INDEX" | awk '{ print $3 }')"
	easyrsa_valid_serial_list="$(print $temp_var | sed "s\`\n\`\ \`g")"
	print

	#print "$easyrsa_valid_serial_list"
	#print

	#foobar="$(print "$easyrsa_valid_serial_list" | sed "s\`\n\`\ \`g")"
	#print $foobar


} # => status_easyrsa_valid ()

# Print Revoked certs from Easy-RSA
status_easyrsa_revoked ()
{
	print "Easy-RSA: Revoked certificates:"
	grep "^R" "$EASYRSA_INDEX" | awk '{ print $6 " " $4 }' | sed "s\`^/CN=\`\`g" | \
		awk '{ print "  Certificate CN: " $1 " is Revoked - Serial number:" $2 }'
	temp_var="$(grep "^R" "$EASYRSA_INDEX" | awk '{ print $4 }')"
	easyrsa_revoked_serial_list="$(print $temp_var | sed "s\`\n\`\ \`g")"
	print

	#print "$easyrsa_revoked_serial_list"
	#print
} # => status_easyrsa_revoked ()

# Print Valid certs from Easy-TLS
status_easytls_valid ()
{
	print "Easy-TLS: Known inline files:"
	grep -v "^$" "$EASYTLS_INLINE_INDEX" | \
		awk '{ print "  Inline file CN: " $1 " is Valid - Serial number:" $2 }'
	temp_var="$(awk '{ print $2 }' "$EASYTLS_INLINE_INDEX")"
	easytls_valid_serial_list="$(print $temp_var | sed "s\`\n\`\ \`g")"
	print

	#print "$easytls_valid_serial_list"
	#print
} # => status_easytls_valid ()

# Print Revoked certs from Easy-TLS
status_easytls_revoked ()
{
	print "Easy-TLS: Revoked inline files:"
	print "  Easy-TLS does not Revoke certificates."
	print "  If the certificate has been revoked in Easy-RSA then use:"
	print "  'remove-inline <filename_base>' to delete inline file."
	print "* renew (TODO)" # TODO
} # => status_easytls_revoked ()

# Check Easy-TLS valid vs Easy-RSA revoked
status_easytls_mismatch ()
{
	print "Easy-TLS: Invalid inline files:"
	for i in $easytls_valid_serial_list
	do
		search_for_mismatch="$(print $easyrsa_revoked_serial_list | grep -c $i)"
		case $search_for_mismatch in
			0)
				:
			;;

			1)
				temp_error=1
				temp_var="$(grep "$i" "$EASYTLS_INLINE_INDEX")" # "
				# "
				print "  $temp_var"
			;;

			*)
				temp_errors=1
				temp_var="$(grep "$i" "$EASYTLS_INLINE_INDEX")" # "
				# "
				print "  multiple mismatch: $temp_var"
		esac
	done
	[ $temp_error ] && warn "Use 'easytls remove-inline <filename_base>' to delete invalid inline files."
	[ $temp_errors ] && warn "Duplicate records detected! Use 'easytls rebuild-inline-index' to attempt a re-index."
} # => status_easytls_mismatch

# Keep an index file for inline certs to manage revoke/renew
update_inline_index ()
{
	update_index_action="$1"
	easytls_index_backup="$EASYTLS_INLINE_INDEX.bkp"
	easytls_index_temp="$EASYTLS_INLINE_INDEX.tmp"
	[ -f "$EASYTLS_INLINE_INDEX" ] || \
		die "update_inline_index () Missing: $EASYTLS_INLINE_INDEX"

	cp -f "$EASYTLS_INLINE_INDEX" "$easytls_index_backup"

	case "$update_index_action" in
		add)
			{ printf "%s\n" "$name $crt_serial"
			} >> "$EASYTLS_INLINE_INDEX" || \
				die "Failed to update $EASYTLS_INLINE_INDEX"
		;;
		del)
			{ sed "s\`^"$name".*$\`\`g" "$easytls_index_backup"
			} > "$easytls_index_temp" || \
				die "Failed to update $EASYTLS_INLINE_INDEX"
			grep -v "^$" "$easytls_index_temp" > "$EASYTLS_INLINE_INDEX"
		;;
		*)
			die "Unknown index action: $update_index_action"
		;;
	esac
	rm -f "$easytls_index_backup" "$easytls_index_temp"
}

# Check that the requested certificate is not revoked before inline
build_inline_cert_status ()
{
	pki_index="$EASYRSA_PKI/index.txt"
	[ -f "$pki_index" ] || die "Missing Easy-RSA: $pki_index"

	crt_valid="$(grep "$name" "$pki_index" | grep -c "^V")"
	[ $crt_valid -eq 1 ] || return 1
} # => build_inline_cert_status ()

# Create inline credentials file from Easy-RSA PKI
build_inline_base ()
{
	# TODO: Improve build_inline integration. eg: renew/revoke
	verify_ca_init
	name="$1"
	ca_file="$EASYRSA_PKI/ca.crt"
	crt_file="$EASYRSA_PKI/issued/$name.crt"
	key_file="$EASYRSA_PKI/private/$name.key"
	out_file="$EASYTLS_PKI/$name.inline"
	help_note="Run easytls status to verify certificate revokation."

	[ -f "$crt_file" ] || die "\
Certificate file missing or revoked: $crt_file
$help_note"

	[ -f "$key_file" ] || die "\
Key file missing or revoked: $key_file
$help_note"

	# get the serial number of the certificate -> serial=XXXX
	crt_serial="$("$EASYRSA_OPENSSL" x509 -in "$crt_file" -noout -serial)"
	# remove the serial= part -> we only need the XXXX part
	crt_serial=${crt_serial##*=}

	# Check that the requested certificate is not revoked before inline
	#build_inline_cert_status || die "Certificate is revoked: $crt_file"

	if [ "$EASYTLS_BATCH" ]
	then
		rm -f "$out_file"
	else
		[ -f "$out_file" ] && die "Inline file exists: $out_file"
	fi

	{	printf "%s\n" "# File name base: $name"
		printf "%s\n" ""
		printf "%s\n" "<cert>"
		cat "$crt_file"
		printf "%s\n" "</cert>"
		printf "%s\n" ""
		printf "%s\n" "<key>"
		cat "$key_file"
		printf "%s\n" "</key>"
		printf "%s\n" ""
		printf "%s\n" "<ca>"
		cat "$ca_file"
		printf "%s\n" "</ca>"
		printf "%s\n" ""
	} > "$out_file" || die "Failed to create inline file: $out_file"

	# Update INLINE index
	update_inline_index add

	notice "Inline base file created: $out_file"
} # => build_inline_base ()

# Append TLS auth file to base file
build_inline_tls_auth ()
{
	verify_ca_init
	name="$1"
	key_dir="$2"
	tls_file="$EASYTLS_PKI/tls-auth.key"
	out_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_file" ] || die "TLS key file does not exist: $tls_file"
	case "$key_dir" in
		0|1) : ;;
		*) die "Key direction must be 0 (For server) or 1 (For client)." ;;
	esac

	build_inline_base "$name"

	{	printf "%s\n" "# TLS auth"
		printf "%s\n" ""
		printf "%s\n" "key-direction $key_dir"
		printf "%s\n" ""
		printf "%s\n" "<tls-auth>"
		cat "$tls_file"
		printf "%s\n" "</tls-auth>"
		printf "%s\n" ""
	} >> "$out_file" || die "Failed to create inline file: $out_file"

	notice "Inline TLS auth file created: $out_file"
} # => build_inline_tls_auth ()

# Append TLS crypt file to base file
build_inline_tls_crypt ()
{
	verify_ca_init
	name="$1"
	tls_file="$EASYTLS_PKI/tls-crypt.key"
	out_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_file" ] || die "TLS key file does not exist: $tls_file"

	build_inline_base "$name"

	{	printf "%s\n" "# TLS crypt"
		printf "%s\n" ""
		printf "%s\n" "<tls-crypt>"
		cat "$tls_file"
		printf "%s\n" "</tls-crypt>"
		printf "%s\n" ""
	} >> "$out_file" || die "Failed to create inline file: $out_file"

	notice "Inline TLS crypt file created: $out_file"
} # => build_inline_tls_crypt ()

# Append TLS crypt v2 file to base file
build_inline_tls_crypt_v2 ()
{
	verify_ca_init
	name="$1"
	tls_file="$EASYTLS_PKI/tls-crypt-v2-$name.key"
	out_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_file" ] || die "TLS key file does not exist: $tls_file"
	[ -f "$out_file" ] && die "TLS Inline file already exist: $out_file"

	EASYTLS_BATCH=1
	build_inline_base "$name"
	unset EASYTLS_BATCH

	{	printf "%s\n" "# TLS crypt v2"
		printf "%s\n" ""
		printf "%s\n" "<tls-crypt-v2>"
		cat "$tls_file"
		printf "%s\n" "</tls-crypt-v2>"
		printf "%s\n" ""
	} >> "$out_file" || die "Failed to create inline file: $out_file"

	notice "Inline TLS crypt v2 file created: $out_file"
} # => build_inline_tls_crypt_v2 ()

# Creat TLS auth file
build_tls_auth ()
{
	# This is allowed without a complete Easy-RSA PKI
	# Verify Easy-TLS and Easy-RSA have been correctly setup
	verify_tls_init
	EASYRSA_TLS_AUTH_KEY="$EASYTLS_PKI/tls-auth.key"

	[ -f "$EASYRSA_TLS_AUTH_KEY" ] && \
		die "TLS auth key already exists: $EASYRSA_TLS_AUTH_KEY"

	"$EASYTLS_OPENVPN" --genkey --secret "$EASYRSA_TLS_AUTH_KEY" || \
		die "Failed to create TLS auth key: $EASYRSA_TLS_AUTH_KEY"

	notice "TLS auth key created: $EASYRSA_TLS_AUTH_KEY"
} # => build_tls_auth ()

# Create TLS crypt v1 file
build_tls_crypt_v1 ()
{
	# Requires openvpn version 2.4
	verify_openvpn_version 4

	# This is allowed without a complete Easy-RSA PKI
	# Verify Easy-TLS and Easy-RSA have been correctly setup
	verify_tls_init

	EASYRSA_TLS_CRYPT_V1_KEY="$EASYTLS_PKI/tls-crypt.key"

	[ -f "$EASYRSA_TLS_CRYPT_V1_KEY" ] && \
		die "TLS crypt v1 key already exists: $EASYRSA_TLS_CRYPT_V1_KEY"

	"$EASYTLS_OPENVPN" --genkey --secret "$EASYRSA_TLS_CRYPT_V1_KEY" || \
		die "Failed to create TLS crypt v1 key: $EASYRSA_TLS_CRYPT_V1_KEY"

	notice "TLS crypt v1 key created: $EASYRSA_TLS_CRYPT_V1_KEY"
} # => build_tls_crypt_v1 ()

# Create TLS crypt v2 server file
build_tls_crypt_v2_server ()
{
	# Requires openvpn version 2.5
	verify_openvpn_version 5

	# Verify Easy-RSA has been correctly setup
	verify_ca_init

	srv_name="$1"
	EASYRSA_TLS_CRYPT_V2_SERVER_KEY="$EASYTLS_PKI/tls-crypt-v2-$srv_name.key"

	[ -n "$srv_name" ] || die "Server name required."

	[ -f "$EASYRSA_PKI/issued/$srv_name.crt" ] || \
		die "Easy-TLS requires that the Easy-RSA server certificate has been created.
Missing file: $EASYRSA_PKI/issued/$srv_name.crt"

	[ -f "$EASYRSA_TLS_CRYPT_V2_SERVER_KEY" ] && \
		die "Server file already exists: $EASYRSA_TLS_CRYPT_V2_SERVER_KEY"
	"$EASYTLS_OPENVPN" --genkey tls-crypt-v2-server "$EASYRSA_TLS_CRYPT_V2_SERVER_KEY" || \
		die "Failed to create tls-crypt-v2-server key: $EASYRSA_TLS_CRYPT_V2_SERVER_KEY"

	notice "TLS crypt v2 server key created: $EASYRSA_TLS_CRYPT_V2_SERVER_KEY"
} # => build_tls_crypt_v2_server ()

# Create TLS crypt v2 client file
build_tls_crypt_v2_client ()
{
	# Requires openvpn version 2.5
	verify_openvpn_version 5

	# Verify Easy-RSA has been correctly setup
	verify_ca_init

	srv_name="$1"
	cli_name="$2"
	[ -n "$srv_name" ] || die "Server name required."
	[ -n "$cli_name" ] || die "Client name required."
	[ "$srv_name" = "$cli_name" ] && die "Server name cannot be the same as the client name."

	EASYRSA_TLS_CRYPT_V2_SERVER_KEY="$EASYTLS_PKI/tls-crypt-v2-$srv_name.key"
	EASYRSA_TLS_CRYPT_V2_CLIENT_KEY="$EASYTLS_PKI/tls-crypt-v2-$cli_name.key"

	[ -f "$EASYRSA_PKI/issued/$cli_name.crt" ] || \
		die "Easy-TLS requires that the Easy-RSA client certificate has been created.
Missing file: $EASYRSA_PKI/issued/$cli_name.crt"

	[ -f "$EASYRSA_TLS_CRYPT_V2_SERVER_KEY" ] || \
		die "Server file does not exist: $EASYRSA_TLS_CRYPT_V2_SERVER_KEY"
	[ -f "$EASYRSA_TLS_CRYPT_V2_CLIENT_KEY" ] && \
		die "Client file already exists: $EASYRSA_TLS_CRYPT_V2_CLIENT_KEY"
	"$EASYTLS_OPENVPN" --tls-crypt-v2 "$EASYRSA_TLS_CRYPT_V2_SERVER_KEY" \
		--genkey tls-crypt-v2-client "$EASYRSA_TLS_CRYPT_V2_CLIENT_KEY" || \
		die "Failed to create tls-crypt-v2-client key: $EASYRSA_TLS_CRYPT_V2_CLIENT_KEY"

	notice "TLS crypt v2 client key created: $EASYRSA_TLS_CRYPT_V2_CLIENT_KEY"
} # => build_tls_crypt_v2_client ()

# Remove .inline file
remove_inline ()
{
	name="$1"
	inline_file="$EASYTLS_PKI/$name.inline"
	#EASYRSA_TLS_INLINE_REVOKED="$EASYTLS_PKI/revoked/$name.inline"

	[ -f "$inline_file" ] || die "Missing: $inline_file"

	#confirm "remove"

	rm "$inline_file" || die "Failed to remove: $inline_file"

	update_inline_index del

	notice "Inline file removed: $inline_file"
}

# vars setup
# Here sourcing of 'vars' if present occurs. If not present, defaults are used
# to support running without a sourced config format
vars_setup() {
	# Try to locate a 'vars' file in order of location preference.
	# If one is found, source it
	vars=

	# set up program path
	prog_file="$0"
	prog_file2="$(which -- "$prog_file" 2>/dev/null)" && prog_file="$prog_file2"
	prog_file2="$(readlink -f "$prog_file" 2>/dev/null)" && prog_file="$prog_file2"
	prog_dir="${prog_file%/*}"
	prog_vars="${prog_dir}/vars"
	# set up PKI path
	pki_vars="${EASYRSA_PKI:-$PWD/pki}/vars"

	# command-line path:
	if [ ! -z "$EASYRSA_VARS_FILE" ]; then
	  if [ ! -f "$EASYRSA_VARS_FILE" ]; then
		  # If the --vars option does not point to a file, show helpful error.
			die "The file '$EASYRSA_VARS_FILE' was not found."
		fi
		vars="$EASYRSA_VARS_FILE"
	# PKI location, if present:
	elif [ -f "$pki_vars" ]; then
		vars="$pki_vars"
	# EASYRSA, if defined:
	elif [ -n "$EASYRSA" ] && [ -f "$EASYRSA/vars" ]; then
		vars="$EASYRSA/vars"
	# program location:
	elif [ -f "$prog_vars" ]; then
		vars="$prog_vars"
	fi
	
	# If a vars file was located, source it
	# If $EASYRSA_NO_VARS is defined (not blank) this is skipped
	if [ -z "$EASYRSA_NO_VARS" ] && [ -n "$vars" ]; then
		EASYRSA_CALLER=1
		. "$vars"
		notice "\
Note: using Easy-RSA configuration from: $vars"
	fi
	
	# Set defaults, preferring existing env-vars if present
	set_var
	set_var EASYRSA			"$prog_dir"
	set_var EASYRSA_OPENSSL		"openssl"
	set_var EASYRSA_PKI		"$PWD/pki"
	set_var EASYRSA_TEMP_DIR	"$EASYRSA_PKI"

	set_var EASYTLS_PKI		"$EASYRSA_PKI/tls"
	set_var EASYTLS_INLINE_INDEX	"$EASYTLS_PKI/inline-index.tls"
	# TODO: Revert back to "openvpn" when v2.5 is released
	set_var EASYTLS_OPENVPN	"/home/tct/openvpn/master/src/openvpn/openvpn"

	# Assign value to $EASYRSA_TEMP_DIR_session and work around Windows mktemp bug when parent dir is missing
	if [ -z "$EASYRSA_TEMP_DIR_session" ]; then
		if [ -d "$EASYRSA_TEMP_DIR" ]; then
			EASYRSA_TEMP_DIR_session="$(mktemp -du "$EASYRSA_TEMP_DIR/easy-rsa-$$.XXXXXX")"
		else
			# If the directory does not exist then we have not run init-pki
			mkdir -p "$EASYRSA_TEMP_DIR" || die "Cannot create $EASYRSA_TEMP_DIR (permission?)"
			EASYRSA_TEMP_DIR_session="$(mktemp -du "$EASYRSA_TEMP_DIR/easy-rsa-$$.XXXXXX")"
			rm -rf "$EASYRSA_TEMP_DIR"
		fi
	fi

} # vars_setup()

# variable assignment by indirection when undefined; merely exports
# the variable when it is already defined (even if currently null)
# Sets $1 as the value contained in $2 and exports (may be blank)
set_var() {
	[ $# -eq 0 ] && return
	var=$1
	shift
	value="$*"
	eval "export $var=\"\${$var-$value}\""
} #=> set_var()

# Set the Easy-TLS version
easy_tls_version ()
{
	EASYTLS_VERSION="0.7"
	print "Easy-TLS version: $EASYTLS_VERSION"
} # => easy_tls_version ()

########################################
# Invocation entry point:


# Be secure with a restrictive umask
[ -z "$EASYTLS_NO_UMASK" ] && umask 077

# Parse options
while :; do
	# Separate option from value:
	opt="${1%%=*}"
	val="${1#*=}"
	empty_ok="" # Empty values are not allowed unless excepted

	case "$opt" in
	--batch)
		empty_ok=1
		export EASYTLS_BATCH=1 ;;
	--pki-dir)
		export EASYRSA_PKI="$val" ;;
	--vars)
		export EASYRSA_VARS_FILE="$val" ;;
	--tls-dir)
		export EASYTLS_PKI="$val" ;;
	*)
		break ;;
	esac

	# fatal error when no value was provided
	if [ ! $empty_ok ] && { [ "$val" = "$1" ] || [ -z "$val" ]; }; then
		die "Missing value to option: $opt"
	fi

	shift
done

# Intelligent env-var detection and auto-loading:
vars_setup

# Register cleanup on EXIT
trap "cleanup" EXIT
# When SIGHUP, SIGINT, SIGQUIT, SIGABRT and SIGTERM,
# explicitly exit to signal EXIT (non-bash shells)
trap "exit 1" 1
trap "exit 2" 2
trap "exit 3" 3
trap "exit 6" 6
trap "exit 14" 15

# Upgrade: EasyRSA v2.x to EasyRSA v3.x
# Upgrade: EasyRSA < v3.0.6 to v3.0.6+
#up23_manage_upgrade_23

# determine how we were called, then hand off to the function responsible
cmd="$1"
[ -n "$1" ] && shift # scrape off command
case "$cmd" in
	init-tls)
		init_tls "$@"
		;;
	build-tls-auth)
		build_tls_auth "$@"
		;;
	build-tls-crypt)
		build_tls_crypt_v1 "$@"
		;;
	build-tls-crypt-v2-server)
		build_tls_crypt_v2_server "$@"
		;;
	build-tls-crypt-v2-client)
		build_tls_crypt_v2_client "$@"
		;;
	build-inline-base)
		build_inline_base "$@"
		;;
	build-inline-tls-auth)
		build_inline_tls_auth "$@"
		;;
	build-inline-tls-crypt)
		build_inline_tls_crypt_v1 "$@"
		;;
	build-inline-tls-crypt-v2)
		build_inline_tls_crypt_v2 "$@"
		;;
	remove-inline)
		remove_inline "$@"
		;;
	status-inline)
		status_inline "$@"
		;;
	version|-v|--version)
		easy_tls_version
		exit 0
		;;
	""|help|-h|--help|--usage)
		cmd_help "$1"
		exit 0
		;;
	*)
		die "Unknown command '$cmd'. Run without commands for usage help."
		;;
esac

# vim: ft=sh nu ai sw=8 ts=8 noet
