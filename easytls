#!/bin/sh

# Copyright - negotiable
copyright ()
{
cat << VERBATUM_COPYRIGHT_HEADER_INCLUDE_NEGOTIABLE
# Easy-TLS -- A Shell-based Easy-RSA extension utility to help manage
#               * OpenVPN specific TLS keys
#               * Easy-RSA based x509 security credentials
#               * Verified 'inline' combined OpenVPN node packages
#
# Copyright (C) 2020 Richard Bonhomme (Friday 13th of March 2020)
# https://github.com/TinCanTech/easy-tls
# tincanteksup@gmail.com
# All Rights reserved.
#
# This code is released under version 2 of the GNU GPL
# See LICENSE of this project for full licensing details.
#
# Acknowledgement:
# This utility is "written in the style of" and "borrows heavily from" Easy-RSA
#
# Easy-TLS is inspired by syzzer
# See: https://github.com/OpenVPN/openvpn/blob/master/doc/tls-crypt-v2.txt
#
VERBATUM_COPYRIGHT_HEADER_INCLUDE_NEGOTIABLE
}

# Easy-TLS requirements:
# + Easy-RSA Version 3.0.5
# + OpenVPN Version 2.5
#


# Help/usage output to stdout
usage()
{
	# command help:
	print '
Easy-TLS usage and overview

USAGE: easytls [options] COMMAND [command-options]

A list of commands is shown below. To get detailed usage and help for a
command, use:
  ./easytls help COMMAND

For a listing of options that can be supplied before the command, use:
  ./easytls help options

For a list of abbreviated command names, use:
  ./easytls help abb

For a list of configurable options, use:
  ./easytls help config

Here is the list of commands available with a short syntax reminder.
Use the "help" command above to get full usage details.

  config
  init-tls
  build-tls-auth
  build-tls-crypt
  build-tls-crypt-v2-server <server_filename_base>
  build-tls-crypt-v2-client
        <server_filename_base> <client_filename_base> <HW-ADDR> <HW-ADDR>
  save-id
  status [ cmd-opts ]
  inline-tls-auth <filename_base> <key_direction> [ cmd-opts ]
  inline-tls-crypt <filename_base> [ cmd-opts ]
  inline-tls-crypt-v2 <filename_base> [ cmd-opts ]
  inline-remove <filename_base>
  inline-show <filename_base>
  inline-index-rebuild
  inline-expire <filename_base>
  cert-expire <filename_base> | <ca>
  d|disable <filename_base>
  e|enable <filename_base>
  disabled-list-rehash
  import-key <file-type> <file-name> <commonName>

NOTE: Easy-TLS requires that you have a working EasyRSA PKI in place.
NOTE: Easy-TLS requires that you have OpenVPN installed.

EasyTLS also has a useful Howto with expanded help and examples:
https://github.com/TinCanTech/easy-tls/blob/master/EasyTLS-Howto-ii.md'

	# collect/show dir status:
	err_source="Not defined: vars autodetect failed and no value provided"
	work_dir="${EASYRSA:-$err_source}"
	pki_dir="${EASYRSA_PKI:-$err_source}"
	tls_dir="${EASYTLS_PKI:-$err_source}"
	print "
DIRECTORY STATUS (commands would take effect on these locations)
  EASYRSA: $work_dir
      PKI: $pki_dir
      TLS: $tls_dir"
} # => usage()

# Detailed command help
# When called with no args, calls usage(), otherwise shows help for a command
cmd_help()
{
	text=""
	opts=""
	case "$1" in
		init-tls) text="
  init-tls
      Removes & re-initializes the TLS key dir" ;;
		bta|build-tls-auth) text="
  build-tls-auth
      Create an OpenVPN TLS auth PSK (tls-auth.key)" ;;
		btc|build-tls-crypt) text="
  build-tls-crypt
      Create an OpenVPN TLS crypt PSK (tls-crypt.key)" ;;
		btc2s|btcv2s|build-tls-crypt-v2-server) text="
  build-tls-crypt-v2-server <server_filename_base>
      Create an OpenVPN TLS crypt V2 Server key" ;;
		btv2c|btcv2c|build-tls-crypt-v2-client) text="
  build-tls-crypt-v2-client
        <server_filename_base> <client_filename_base> <HW-ADDR> <HW-ADDR>

      Create an OpenVPN TLS crypt V2 Client key

      The metadata can also be used to specify Hardware Addresses which this
      key is allowed to be used from.  Use easytls-cryptv2-client-connect.sh
      to verify the HW-ADDR.

      Note: Both scripts are required to successfully verify Hardware." ;;
		sid|save-id) text="
  save-id [ no options ]
      Save the CA-Identity to easytls/easytls-ca-identity.txt
      CA-Identity is the Hex ONLY value of the CA finger print.
      This can then by used by easytls-cryptv2-verify.sh as a time-saver
      by not needing to load openssl to generate the CA fingerprint.
      Combining this with 'easytls-cryptv2-verify.sh --verify-via-index',
      openssl binary never needs to be loaded by easytls-cryptv2-verify.sh
      See EasyTLS Howto for an example." ;;
		s|status) text="
  status [ cmd-opts ]
      Compare Easy-RSA certificate(s) to Easy-TLS inline(s) status"
			opts="
	val|valid   - List only Easy-RSA valid certificates
	rev|revoked - List only Easy-RSA revoked certificates
	inl|inline  - List only Easy-TLS inline files
	inv|invalid - List only Easy-TLS invalid inline files
	ren|renewed - List only Easy-RSA renewed certificates" ;;
		ita|inline-tls-auth) text="
  inline-tls-auth <filename_base> <key_direction> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS auth file
      <key_direction> '0' or '1' (key-direction is mandatory)"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		itc|inline-tls-crypt) text="
  inline-tls-crypt <filename_base> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS crypt file"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		itv2|itcv2|inline-tls-crypt-v2) text="
  inline-tls-crypt-v2 <filename_base> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS crypt v2 file"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option
        no-md   - Do not add public metadata details to inline file
        add-hw  - Include hardware address in metadata details" ;;
		irm|irv|inline-remove) text="
  inline-remove <filename_base>
      Delete <filename_base>.inline when Easy-RSA certificate is revoked" ;;
		is|inline-show) text="
  inline-show <filename_base>
      Copy <filename_base>.inline to stdout" ;;
		inline-index-rebuild) text="
  inline-index-rebuild
      Rebuild easytls-index.txt
      If you need to do this then you may have found a bug, please
      raise an issue https://github.com/TinCanTech/easy-tls/issues" ;;
		ix|inline-expire) text="
  inline-expire <filename_base>
      Display inline expiry date for <filename_base>"
			opts="
        If no <filename_base> is given then list all inline expiry dates" ;;
		cx|cert-expire) text="
  cert-expire <filename_base> | <ca>
      Display certificate expiry date for <filename_base>"
			opts="
        If <filename_base> is 'ca' then show ca.crt expiry
        If no <filename_base> is given then list all certificate expiry dates" ;;
		d|disable) text="
  d|disable <filename_base>
      Add serial number for <filename_base> to the disabled list
      for immediate use by the easytls-cryptv2-verify.sh script" ;;
		e|enable) text="
  e|enable <filename_base>
      Remove serial number for <filename_base> from the disabled list
      for immediate use by the easytls-cryptv2-verify.sh script" ;;
		disabled-list-rehash) text="
  disabled-list-rehash
       Rehash the disabled-list if the current hash is corrupted.
       Does not rebuild the disabled-list. If there is an error in the list
       then edit the list manually and rehash it with 'disabled-list-rehash'" ;;
		import-key) text="
  import-key <key-type> <key-name> <commonName>
      Import a pre-existing TLS key <key-name> to EasyTLS directory.

      <key-type> is one of the supported TLS key types:
      tls-auth, tls-crypt or tls-crypt-v2.

      Examples (Using default PKI directory):

      Importing TLS-Auth or TLS-Crypt keys renames the key file as shown:

        * 'import-key tls-auth ./ta.key'
          Imported key name: ./pki/easytls/tls-auth.key

        * 'import-key tls-crypt ./tc.key'
          Imported key name: ./pki/easytls/tls-crypt.key

      TLS-crypt-v2 keys must be named after the commonName of the entity:
      (Default <commonName> is <key-name>)

        * 'import-key tls-crypt-v2 ./serv-v2.key server'
          Imported key name: ./pki/easytls/server-tls-crypt-v2.key

        * 'import-key tls-crypt-v2 ./cli2-v2.key client02'
          Imported key name: ./pki/easytls/client02-tls-crypt-v2.key" ;;

		options)
			opt_usage ;;
		abb)
			opt_abbreviations ;;
		cf|cfg|config)
			opt_config ;;
		"")
			usage ;;
		*) text="
  Unknown command: '$1' (try without commands for a list of commands)" ;;
	esac

	# display the help text
	[ -n "$text" ] && print "$text"
	[ -n "$opts" ] && print "
      cmd-opts is an optional set of command options from this list:
$opts"
	return 0
} # => cmd_help()

# Options usage
opt_usage()
{
	print '
Easy-TLS Global Option Flags

The following options may be provided before the command. Options specified
at runtime override env-vars and any "vars" file in use. Unless noted,
non-empty values to options are mandatory.

General options:

--openvpn="FILE"   : The full (or relative) <path-to> and <file-name-of>
                     your preferred openvpn(.exe) executable openvpn file.
--no-auto-check    : For performance you can disable auto-check.
--batch            : Set automatic (no-prompts when possible) mode.
--verbose          : Verbose output.
--silent           : Silence all message output except prompts.
--pki-dir=DIR      : Declare the EasyRSA PKI directory.
--vars=FILE        : Define a specific "vars" file to use for Easy-RSA config.
--dh=FILE          : Define an alternate Diffy Hellman parameters file.
--inline           : When building a TLS Crypt V2 key, also build the Inline file.
                     This only accepts default options for inline-tls-crypt-v2.

--custom-group=XYZ

      <CUSTOM-GROUP> is an optional single word which will be used
      in .inline files to identify the group to which this PKI belongs.
      Also added to TLS-Crypt-V2 client key metadata.

      The <CUSTOM-GROUP> can also be matched against in easytls-cryptv2-verify.sh
      by using the command line switch --c|custom-group=XYZ

--sub-key-name=Name

      This allows for one single X509 client certificate to have multiple
      TLS Crypt V2 client keys associated with it.  For example, the same
      X509 certificate can be used from different locations with unique
      TLS crypt V2 keys.
'
} # => opt_usage()

# Option abbreviations
opt_abbreviations ()
{
	print '
Easy-TLS abbreviations:

  config_file                   - cf | cfg
  init-tls                      - init
  build                         - No abbreviation
  build-tls-auth                - bta
  build-tls-crypt               - btc
  build-tls-crypt-v2-server     - btv2s | btcv2s
  build-tls-crypt-v2-client     - btv2c | btcv2c
  save-id                       - sid
  status                        - s
  inline                        - No abbreviation
  inline-tls-auth               - ita
  inline-tls-crypt              - itc
  inline-tls-crypt-v2           - itv2 | itcv2
  inline-remove                 - irm | irv
  inline-show                   - is
  inline-index-rebuild          - No abbreviation
  inline-expire                 - ix
  cert-expire                   - cx
  disable                       - d
  enable                        - e
  disabled-list-rehash          - No abbreviation
  import-key                    - No abbreviation
'
}

# Option abbreviations
opt_config ()
{
	print '
Easy-TLS configurable options:

  ac|auto.check on|off
     Toggle auto.check on|off.

  cg|custom.group NAME
     Save the Custom Group NAME - NAME must be a single contiguous word.
     Once set and used to build any TLS-Crypt-V2 Client keys, this NAME
     cannot be changed.

     When using easytls-crypt-v2-verify.sh in your openvpn server, if you
     change it then your current keys will no longer be able to connect.

  co|custom.openvpn "/full/path/to/openvpn(.exe)"
     Save your custom openvpn binary location.
     EG: /usr/local/bin/openvpn (Qutotes are not required)
         "C:/Program Files/OpenVPN/mybin/openvpn.exe"
         (Quotes are required for spaces and "\" must be "/")

  im|inline.metadata on|off
     Toggle inline-file metadata on|off.
'
}

# Wrapper around printf - clobber print since it's not POSIX anyway
print() { printf "%s\n" "$*"; }

# Exit fatally with a message to stderr
# present even with EASYTLS_BATCH as these are fatal problems
die()
{
	easytls_version
	print "
Easy-TLS error:

$help_note

$1" 1>&2
	exit "${2:-1}"
} # => die()

# Specific error messages from sub-functions which do not use die()
error_msg ()
{
	print "ERROR: $1"
}

# remove temp files and do terminal cleanups
cleanup()
{
	[ -z "$EASYRSA_TEMP_DIR_session" ] || rm -rf "$EASYRSA_TEMP_DIR_session"
	(stty echo 2>/dev/null) || { (set -o echo 2>/dev/null) && set -o echo; }
	[ $EASYTLS_SILENT ] || echo "" # just to get a clean line
} # => cleanup()

# non-fatal warning output
warn()
{
	[ "$EASYTLS_SILENT" ] && return
		print "
WARNING:
  $1
" 1>&2
} # => warn()

# informational notices to stdout
notice()
{
	[ "$EASYTLS_SILENT" ] && return
		print "
$1"
} # => notice()

# intent confirmation helper func
# returns without prompting in EASYTLS_BATCH
confirm()
{
	[ "$EASYTLS_BATCH" ] && return
	prompt="$1"
	value="$2"
	msg="$3"
	input=""
	print "
$msg

Type the word '$value' to continue, or any other input to abort."
	printf %s "  $prompt"
	read input
	[ "$input" = "$value" ] && return
	notice "Aborting without confirmation."
	exit 9
} # => confirm()

vars_source_check() {
	# Check for defined EASYRSA_PKI
	[ -n "$EASYRSA_PKI" ] || die "\
EASYRSA_PKI env-var undefined"
} # => vars_source_check()

# Basic sanity-check of PKI init and complain if missing
verify_pki_init () {
	help_note="Run easyrsa without commands for usage and command help."

	# check that the pki dir exists
	vars_source_check
	[ -d "$EASYRSA_PKI" ] || die "\
Easy-TLS requires that you have initialised your Easy-RSA PKI.

Easy-RSA error:

EASYRSA_PKI does not exist (perhaps you need to run init-pki)?
Expected to find the EASYRSA_PKI at: $EASYRSA_PKI
$help_note"

	# verify expected dirs present:
	for i in private reqs; do
		[ -d "$EASYRSA_PKI/$i" ] || die "\
Easy-TLS requires that you have initialised your Easy-RSA PKI.

Easy-RSA error:

Missing expected directory: $i (perhaps you need to run init-pki?)
$help_note"
	done
} # => verify_pki_init()

# Verify core CA files present
verify_ca_init () {
	help_note="Run without commands for usage and command help."

	# First check the PKI has been initialized
	verify_pki_init

	# Verify expected files are present. Allow files to be regular files
	# (or symlinks), but also pipes, for flexibility with ca.key
	for i in serial index.txt index.txt.attr ca.crt private/ca.key; do
		if [ ! -f "$EASYRSA_PKI/$i" ] && [ ! -p "$EASYRSA_PKI/$i" ]; then
			#[ "$1" = "test" ] && return 1
			die "\
Easy-TLS TLS-crypt-v2 requires that you have built your EASY-RSA PKI.

Easy-RSA error:

Missing expected CA file: $i (perhaps you need to run build-ca?)
$help_note"
		fi
	done

	# When operating in 'test' mode, return success.
	# test callers don't care about CA-specific dir structure
	#[ "$1" = "test" ] && return 0

	# verify expected CA-specific dirs:
	for i in issued certs_by_serial
	do
		[ -d "$EASYRSA_PKI/$i" ] || die "\
Easy-TLS TLS-crypt-v2 requires that you have built your EASY-RSA PKI.

Easy-RSA error:

Missing expected CA dir: $i (perhaps you need to run build-ca?)
$help_note"
	done

	# explicitly return success for callers
	return 0

} # => verify_ca_init()

############################################################################
#
# EASYTLS MANAGEMENT Section
#

# Verbose messages
easytls_verbose ()
{
	[ $EASYTLS_VERBOSE ] || return 0
	verbose_message="$*"
	[ -z "$verbose_message" ] && print "" && return 0
	print "* $verbose_message"
}

# Configurable options
easytls_config ()
{
	# Missing config file is fatal
	[ -f "$EASYTLS_CONFIG_FILE" ] || die "Missing config file"

	case "$1" in
		ac|auto.check)
			cfg_opt="auto.check"
			cfg_val=$2
		;;
		cg|custom.group)
			cfg_opt="custom.group"
			cfg_val=$2
		;;
		id|ca.id)
			cfg_opt="ca.id"
			cfg_val=$2
		;;
		co|custom.openvpn)
			cfg_opt="custom.openvpn"
			cfg_val=$2
		;;
		im|inline.metadata)
			cfg_opt="inline.metadata"
			cfg_val=$2
		;;
		'')
			# Show config
			cat "$EASYTLS_CONFIG_FILE"
			return 0
		;;
		*)
			print "Unknown option: $1"
			return 1
		;;
	esac

	case "$cfg_opt" in
		auto.check|inline.metadata)
			case "$cfg_val" in
				on|off)
					:
				;;
				*)
					die "Unsupported value for $opt: $val"
				;;
			esac
		;;
		custom.group)
			# Cannot be empty
			[ -z "$cfg_val" ] && die "Unsupported value for $cfg_opt: $cfg_val"
			# spaces ?
			test_val="${cfg_val%% *}"
			[ "$cfg_val" = "$test_val" ] || \
				die "Unsupported value for $cfg_opt: $cfg_val"
		;;
		custom.openvpn)
			if [ -n "$cfg_val" ]
			then
				# Test for file
				[ -f "$cfg_val" ] || die "Missing: $cfg_val"
			fi
		;;
		ca.id)
			[ -n "$EASYTLS_MASTER_ID" ] && \
				die "The CA-ID cannot be changed"
		;;
		*)
			die "config oops!"
		;;
	esac

	# Write config
	easytls_config_update || die "Error updating config."
	config_file_save_hash || die "Error hashing config."
}

# Update config
easytls_config_update ()
{
	sed -i \
	-e "s\`^${cfg_opt}[[:blank:]]=[[:blank:]].*$\`${cfg_opt} = ${cfg_val}\`g" \
	"$EASYTLS_CONFIG_FILE" || return 1
}

# Use config
easytls_config_use ()
{
	# If the config file does not exist then Do not error
	[ -f "$EASYTLS_CONFIG_FILE" ] || return 0

	config_verify_hash || {
		error_msg "Config file hash failed."
		return 1
		}

	easytls_verbose "Load Config"

	config_error=0
	# Cannot use IFS because Windows/sh/read needs to recognise CRLF as well
	# It is simplest to rely on Windows/sh/read default which does CRLF or NL
	# Any writes to config and Windows/sed converts all CRLF to NL anyway
	while read -r cfg_opt cfg_equ cfg_val
	do
		# These settings do not change command line
		case "$cfg_opt" in
			auto.check)
				case "$cfg_val" in
					off)	set_var auto_check_disabled 1 ;;
					on)		: ;;
					*)		config_error=2 ;;
				esac
				;;
			inline.metadata)
				case "$cfg_val" in
					off)	set_var no_metadata 1 ;;
					on)		: ;;
					*)		config_error=3 ;;
				esac
				;;
			custom.group)
				set_var EASYTLS_TLSCV2_CG "$cfg_val"
				;;
			custom.openvpn)
				set_var EASYTLS_OPENVPN "$cfg_val"
				;;
			ca.id)
				# This is set explicitly here to protect config
				export EASYTLS_MASTER_ID="$cfg_val"
		esac

		# Just for shellcheck
		[ "$cfg_equ" = "=" ] || config_error=4

	done < "$EASYTLS_CONFIG_FILE"
	return "$config_error"
}

# Verify the config file hash
config_verify_hash ()
{
	# The config file may not exist
	[ -f "$EASYTLS_CONFIG_FILE" ] || return 0

	# If the config file exists then the hash must exist
	[ -f "$EASYTLS_CONFIG_HASH" ] || {
		error_msg "config_verify_hash - Missing Config Hash: $EASYTLS_CONFIG_HASH"
		return 1
		}

	# Read the saved hash
	config_saved_hash="$(cat "$EASYTLS_CONFIG_HASH")"

	# Generate the current hash
	generate_file_hash "$EASYTLS_CONFIG_FILE" || {
		error_msg "config_verify_hash - Config file failed to generate hash."
		return 1
		}

	config_current_hash="$generated_hash"
	# Verify hash match
	[ "$config_saved_hash" = "$config_current_hash" ] || {
		error_msg "config_verify_hash - Verify hash match failed."
		return 1
		}

	easytls_verbose "Config file hash check OK"
}

# Hash config-file
config_file_save_hash ()
{
	# Generate the current hash
	generate_file_hash "$EASYTLS_CONFIG_FILE" || {
		error_msg "config_file_save_hash: Failed to hash: $EASYTLS_CONFIG_FILE"
		return 1
		}

	config_current_hash="$generated_hash"
	# Save the current hash
	printf '%s\n' "$config_current_hash" > "$EASYTLS_CONFIG_HASH" || {
		error_msg "config_file_save_hash - Save the current hash failed."
		return 1
		}

	easytls_verbose "Config file hash saved OK"
}

# Verify Openvpn is available
verify_openvpn ()
{
	# Find openvpn or openvpn.exe
	help_note="See ./easytls help options - Option: --openvpn"

	# extract openvpn version
	openvpn_version="$("$EASYTLS_OPENVPN" --version)"
	case "${openvpn_version%% *}" in
		OpenVPN) : ;;
		*) die "Missing or invalid OpenVPN" ;;
	esac

	openvpn_version="${openvpn_version#OpenVPN }"
	openvpn_version="${openvpn_version%% *}"
	openvpn_version="${openvpn_version%_*}"
	[ ${#openvpn_version} -gt 3 ] && openvpn_version="${openvpn_version%.*}"
	case "$openvpn_version" in
		2.5|2.6) : ;;
		2.4) : ;;
		*) die "Unsupported OpenVPN version: $openvpn_version" ;;
	esac
	unset help_note
} # => verify_openvpn ()

# Verify TLS has been initialised
verify_tls_init ()
{
	help_note="Use './easytls init-tls' to initialise"
	[ -d "$EASYTLS_PKI" ] || die "EasyTLS has not been initialised"
	[ -f "$EASYTLS_INLINE_INDEX" ] || die "EasyTLS has not been initialised"
	[ -f "$EASYTLS_IL_INDEX_HASH" ] || die "EasyTLS has not been initialised"
	[ -f "$EASYTLS_DISABLED_LIST" ] || die "EasyTLS has not been initialised"
	[ -f "$EASYTLS_DISABLED_HASH" ] || die "EasyTLS has not been initialised"
	unset help_note
} # => verify_tls_init ()

# init-tls backend:
init_tls ()
{
	# Easy-TLS requires that your Easy-RSA PKI is initialised
	verify_pki_init
	# If EASYTLS_PKI exists, confirm before we rm -rf
	# skipped with EASYTLS_BATCH
	if [ -d "$EASYTLS_PKI" ]; then
		confirm "Confirm removal: " "yes" "
WARNING!!!

You are about to remove the EASYTLS_PKI at: $EASYTLS_PKI
and initialize a fresh TLS PKI here."
		# now remove it:
		rm -rf "$EASYTLS_PKI" \
		|| die "Removal of TLS dir failed. Check/correct errors above"
	fi

	# Create tls dir in Easyrsa PKI dir
	mkdir -p "$EASYTLS_PKI" || die "Failed to create TLS dir (permissions?)"

	# Create data dir in easytls dir
	mkdir -p "$EASYTLS_DATA_DIR" || die "Failed to create data dir (permissions?)"

	# Create metadata dir in easytls dir
	mkdir -p "$EASYTLS_MD_DIR" || die "Failed to create metadata dir (permissions?)"

	# Create tls dir index file
	head_text="# EasyTLS inline-index - Created: $(date)"
	printf '%s\n' "$head_text" > "$EASYTLS_INLINE_INDEX" \
		|| die "Failed to create inline-index"

	# Create inline-index hash file
	inline_index_save_index_hash || die "Failed to create inline-index Hash."

	# Create config file
	{
		#printf '%s\n' "batch.mode = off"
		printf '%s\n' "ca.id = "
		printf '%s\n' "custom.group = "
		printf '%s\n' "auto.check = on"
		printf '%s\n' "inline.metadata = on"
		printf '%s\n' "custom.openvpn = "
	} > "$EASYTLS_CONFIG_FILE" || die "Failed to create config-file"

	# Create config file hash
	config_file_save_hash || die "Failed to create config-file Hash."
	save_id || warn "Failed to Save ID."

	# Create disabled list
	head_text="# EastTLS disabled-list - Created: $(date)"
	printf '%s\n' "$head_text" > "$EASYTLS_DISABLED_LIST" \
		|| die "Failed to create disabled-list"

	# Create disabled list hash file
	disabled_list_save_hash || die "Failed to create disabled-list Hash."

	notice "\
init-tls complete; you may now create TLS keys and .inline files.
Your newly created TLS dir is: $EASYTLS_PKI
"
	notice "To configure your custom group now, use:
	 'easytls config custom.group YOUR_GROUP"
} # => init_tls ()

# Auto-check for invalid inline files
# Run on exit to avoid "chicken and egg" with init-tls
inline_auto_check ()
{
	[ $auto_check_disabled ] && return 0
	index_size="$(grep -c '^.*$' "$EASYTLS_INLINE_INDEX")"
	[ $index_size -gt 50 ] && \
		warn "EasyTLS: 50+ .inline files found, use --disable-auto-check"

	auto_check=1
	easytls_verbose ""
	easytls_verbose "auto-check"

	# Check for revoked EasyRSA certs
	# which still have an inline file
	status invalid || die "inline_auto_check: status invalid error"
	[ $revoked_mismatch_count -eq 0 ] || \
		warn "EasyTLS: Invalid .inline files found: Revoked certs."

	# Check serial number for renewed EasyRSA certs
	# which do not match inline files
	status renewed || die "inline_auto_check: status renewed error"
	[ $renewed_mismatch_count -eq 0 ] || \
		warn "EasyTLS: Invalid .inline files found: Renewed certs."

	# Check inline-index hash
	inline_index_verify_index_hash || warn "inline-index is corrupt"

	# Check disabled-list hash
	disabled_list_verify_hash || warn "Disabled list is corrupt."

	unset auto_check
	easytls_verbose "auto-check complete."
} # => inline_auto_check ()

# Show Easy-TLS inlines and Easy-RSA certificates
# Report invalid inline files due to certificate revokation
# Report duplicate CNs in EasyRSA due to certificate renewal
status ()
{
	[ $auto_check ] || auto_check_disabled=1
	subsection="$1"

	#verify_ca_init

	ersa_valid_cn_list=""
	ersa_valid_serial_list=""
	ersa_revoked_cn_list=""
	ersa_revoked_serial_list=""
	#easytls_valid_cn_list=""
	etls_valid_name_list=""
	etls_valid_serial_list=""
	#easytls_revoked_serial_list="" # Not used

	if [ -n "$subsection" ]
	then
		case "$subsection" in
		val|valid)
			status_easyrsa_valid || return 1
		;;
		rev|revoked)
			status_easyrsa_revoked || return 1
		;;
		inl|inline)
			#verify_tls_init
			status_easytls_inline || return 1
		;;
		inv|invalid)
			silent_status=1
			status_easyrsa_valid || return 1
			status_easyrsa_revoked || return 1
			#verify_tls_init
			status_easytls_inline || return 1
			unset silent_status
			status_easytls_invalid || return 1
		;;
		ren|renewed)
			silent_status=1
			status_easyrsa_valid || return 1
			status_easyrsa_revoked || return 1
			#verify_tls_init
			status_easytls_inline || return 1
			unset silent_status
			status_easyrsa_renewed || return 1
		;;
		dis|disabled)
			status_disabled_list || return 1
		;;
		*)
			print "Unknown status option"
			return 1
		;;
		esac
		return 0
	fi

	print "Easy-RSA: Valid X509 certificates:"
	status_easyrsa_valid
	[ -z "$ersa_valid_serial_list" ] && \
		print "  No Valid X509 certificates found"

	print "Easy-RSA: Revoked X509 certificates:"
	status_easyrsa_revoked
	[ -z "$ersa_revoked_serial_list" ] && \
		print "  No Revoked X509 certificates found"

	#verify_tls_init

	print "Easy-TLS: Known inline files:"
	status_easytls_inline
	[ -z "$etls_valid_serial_list" ] && \
		print "  No inline files found"

	#print "Easy-TLS: Revoked inline files:"
	#status_easytls_revoked

	print "Easy-TLS: Invalid inline files:"
	status_easytls_invalid
	if [ $revoked_mismatch_count -gt 0 ]
	then
		print "  Invalid inline files are caused by revoked X509 Certificates"
		print "  To solve this use: ./easytls inline-remove <filename-base>"
	else
		print "  No invalid inline files found"
	fi

	print "Easy-TLS: .inline serial number mismatches:"
	status_easyrsa_renewed
	if [ $renewed_mismatch_count -gt 0 ]
	then
		print "  Mismatches are caused by X509 Certificates"
		print "  which have not been completely renewed by EasyRSA"
		print "  To solve this use: caution.."
	else
		print "  No mismatches found"
	fi

	# Check inline-index hash
	inline_index_verify_index_hash || warn "inline-index is corrupt"

	# Check inline-index hash
	config_verify_hash || warn "Config file hash failed."

	# Verify disabled list Hash
	disabled_list_verify_hash || warn "Disabled list is corrupt."

	easytls_verbose "Status complete"
} #=> status ()

# Format status output
status_output ()
{
	awk '{
		if (NF == 4)
		print "  Common-Name " $1 "\t  Serial-number " $2 "\t  Sub-key " $4
		else
		print "  Common-Name " $1 "\t  Serial-number " $2
		}'
}

# Format status CN
status_cn ()
{
	sed -e 's`^.*/CN=``g' -e 's`/.*$``g'
}

# Extract Valid records from openssl index.txt by crt_serial
status_valid_extract_cn ()
{
	grep "^V.*[[:blank:]]${i}[[:blank:]]" "$EASYRSA_INDEX" | status_cn
}

# Extract Revoked records from openssl index.txt by crt_serial
status_revoked_extract_cn ()
{
	grep "^R.*[[:blank:]]${i}[[:blank:]]" "$EASYRSA_INDEX" | status_cn
}

# Search ersa revoked serial list for etls valid serial
status_search_revoked_serial_list()
{
	printf '%s\n' "$ersa_revoked_serial_list" | grep -c "^${inline_serial}$"
}

# List the invalid inline file record by serial number
# Do not terminate regex with $ because we need to allow for subs
status_invalid_inline_list ()
{
	grep "^${name}[[:blank:]]${inline_serial}[[:blank:]]${inline_hash}" \
		"$EASYTLS_INLINE_INDEX" | status_output
}

# Print Valid certs from Easy-RSA
status_easyrsa_valid ()
{
	[ -f "$EASYRSA_INDEX" ] || return 0
	ersa_valid_serial_list="$(grep '^V' "$EASYRSA_INDEX"|awk '{print $3}')"
	for i in $ersa_valid_serial_list
	do
		ersa_valid_cn="$(status_valid_extract_cn)"
		ersa_valid_cn_list="$ersa_valid_cn_list $ersa_valid_cn"
		[ $silent_status ] || print "$ersa_valid_cn $i" | status_output
	done
} # => status_easyrsa_valid ()

# Print Revoked certs from Easy-RSA
status_easyrsa_revoked ()
{
	[ -f "$EASYRSA_INDEX" ] || return 0
	ersa_revoked_serial_list="$(grep '^R' "$EASYRSA_INDEX"|awk '{print $4}')"
	for i in $ersa_revoked_serial_list
	do
		ersa_revoked_cn="$(status_revoked_extract_cn)"
		ersa_revoked_cn_list="$ersa_revoked_cn_list $ersa_revoked_cn"
		[ $silent_status ] || print "$ersa_revoked_cn $i" | status_output
	done
} # => status_easyrsa_revoked ()

# Print known inline files from Easy-TLS
status_easytls_inline ()
{
	[ -f "$EASYTLS_INLINE_INDEX" ] || return 0
	etls_valid_name_list="$(inline_index_common_name_sub_name_list)"
	etls_valid_serial_list="$(inline_index_serial_number_list)"
	etls_valid_il_hash_list="$(inline_index_ilhash_number_list)"
	[ $silent_status ] || sed /^#/d "$EASYTLS_INLINE_INDEX" | status_output
} # => status_easytls_valid ()

# Print Revoked certs from Easy-TLS
status_easytls_revoked ()
{
	print "  Easy-TLS does not Revoke certificates."
	print "  If the certificate has been revoked in Easy-RSA then use:"
	print "  'inline-remove <filename_base>' to delete the inline file."
} # => status_easytls_revoked ()

# Check Easy-TLS valid vs Easy-RSA revoked
status_easytls_invalid ()
{
	[ $index_rebuild ] && [ -z "$etls_valid_il_hash_list" ] && \
		die "empty etls_valid_il_hash_list"

	revoked_mismatch_count=0
	for i in $etls_valid_il_hash_list
	do
		known_inline_hash="$i"
		[ -z "$known_inline_hash" ] && die "status invalid: known_inline_hash ?"

		# This needs to handle duplicate-ish names.
		name="$(inline_index_ilhash_to_common_name)"
		sub_name="$(inline_index_ilhash_to_sub_name)"

		if [ -z "$sub_name" ]
		then
			# No sub name present
			inline_file="$EASYTLS_PKI/$name.inline"
		else
			# Append '-$sub_name' to inline file name
			inline_file="$EASYTLS_PKI/$name-$sub_name.inline"
		fi
		[ -f "$inline_file" ] || die "Missing inline_file: $inline_file ?"

		inline_serial="$(inline_index_ilhash_to_serial)"

		# Clear inline_hash from previous loop
		unset inline_hash
		# Check the .inline HASH
		verify_inline_hash || die "Failed HASH: $inline_file"

		mismatches="$(status_search_revoked_serial_list)"
		case $mismatches in
		0)
		# No mismatches found
			:
		;;
		1)
			revoked_mismatch_count=$((revoked_mismatch_count+1))
			[ $auto_check ] || status_invalid_inline_list
		;;
		*)
			warn "EasyRSA duplicate records detected!"
			[ $((mismatches)) -gt 1 ] || \
				die "Error in mismatches: $mismatches"
		;;
		esac
	done
} # => status_easytls_invalid ()

# Print Renewed certs from Easy-RSA if they are inlined
status_easyrsa_renewed ()
{
	renewed_mismatch_count=0
	# REMEMBER: If there is no inline file for a cert
	# then EasyTLS does not care if the cert is renewed

	for i in $etls_valid_name_list
	do

	name=$i
	inline_file="$EASYTLS_PKI/$name.inline"
	[ -f "$inline_file" ] || die "Not found: inline_file = $inline_file"
	# Inline serial
	inline_serial=""
	inline_crt_serial

	crt_file="$EASYRSA_PKI/issued/$name.crt"
	if [ -f "$crt_file" ]
	then

		# Certificate serial
		crt_serial=""
		openssl_crt_serial

		if [ "$inline_serial" = "$crt_serial" ]
		then
			# serial match, inline is upto date
			:
		else
			# serial mismatch, cert has been renewed in EasyRSA
			renewed_mismatch_count=$((renewed_mismatch_count+1))
			if [ $silent_status ]
			then
				# No output
				:
			else
				[ $auto_check ] || {
				print "  Common-Name $name"
				print "    Inline-Serial $inline_serial"
				print "    Cert-Serial   $crt_serial"
				}
			fi
		fi
	else
		# EasyRSA renew is broken
		# cert is probably revoked
		:
	fi

	# End of for loop
	done

} # => status_easyrsa_renewed ()

# List disabled client keys
status_disabled_list()
{
	cat "$EASYTLS_DISABLED_LIST" | status_output
}

# Verify certificate purpose
cert_purpose ()
{
	"$EASYRSA_OPENSSL" x509 -in "$1" -noout -purpose | grep -q "$2"
} # => cert_purpose ()

# Cut to only certificate enddate
crt_expire_date_only ()
{
	crt_expire="$("$EASYRSA_OPENSSL" x509 -in "$crt_file" -noout -enddate)"
	crt_expire="${crt_expire##*=}"
} # => crt_expire_date_only ()

# Extract enddate from .inline certificate
inline_expire_date_only ()
{
	inline_expire="$(grep '^[[:blank:]]\+Not After : ' "$inline_file")"
	inline_expire="${inline_expire##*: }"
} # => inline_expire_date_only ()

# Get a list of commonNames from inline-index
inline_index_common_name_list ()
{
	awk '{if ($1 ~ /[^#]/) print $1 " "}' "$EASYTLS_INLINE_INDEX"
}

# Get a list of serial_numbers from inline-index
inline_index_serial_number_list ()
{
	awk '{if ($1 ~ /[^#]/) print $2 " "}' "$EASYTLS_INLINE_INDEX"
}

# Get a list of inline hashes from inline-index
inline_index_ilhash_number_list ()
{
	awk '{if ($1 ~ /[^#]/) print $3 " "}' "$EASYTLS_INLINE_INDEX"
}

# Get a list of Common_name + Sub-key name from inline-index
inline_index_common_name_sub_name_list ()
{
	awk '{if($1 ~ /[^#]/)
		 {if(NF == 4) {print $1 "-" $4 " ";} else {print $1 " ";}}
		 }' "$EASYTLS_INLINE_INDEX"
}

# Get x509 certificate expiry date
cert_expire ()
{
	name="$1"

	verify_ca_init

	if [ "$name" = "ca" ]
	then
		crt_file="$EASYRSA_PKI/ca.crt"
		[ -f "$crt_file" ] || die "Missing: $crt_file"
		crt_expire_date_only
		print " Certificate: ca.crt   Expire-date: $crt_expire"
	elif [ -n "$name" ]
	then
		crt_file="$EASYRSA_PKI/issued/$name.crt"
		[ -f "$crt_file" ] || die "Missing: $crt_file"
		crt_expire_date_only
		print " Certificate: $name.crt   Expire-date: $crt_expire"
	else
		easyrsa_valid_list="$(grep '^V' "$EASYRSA_INDEX"|status_cn)"
		for name in $easyrsa_valid_list
		do
			crt_file="$EASYRSA_PKI/issued/$name.crt"
			[ -f "$crt_file" ] || die "Missing: $crt_file"
			crt_expire_date_only
		print " Certificate: $name.crt   Expire-date: $crt_expire"
		done
		crt_file="$EASYRSA_PKI/ca.crt"
		[ -f "$crt_file" ] || die "Missing: $crt_file"
		crt_expire_date_only
		print " Certificate: ca.crt   Expire-date: $crt_expire"
	fi
} # => cert_expire ()

# Get inline certificate expiry date
inline_expire ()
{
	name="$1"

	verify_tls_init

	if [ -n "$name" ]
	then
		inline_file="$EASYTLS_PKI/$name.inline"
		[ -f "$inline_file" ] || die "Missing: $inline_file"
		inline_expire_date_only
		print " Certificate: $name.inline   Expire-date: $inline_expire"
	else
	# Get a list of Valid names from easytls-inline-index
	etls_valid_name_list="$(inline_index_common_name_sub_name_list)"
		for name in $etls_valid_name_list
		do
			inline_file="$EASYTLS_PKI/$name.inline"
			[ -f "$inline_file" ] || die "Missing: $inline_file"
			inline_expire_date_only
		print " Inline-file: $name.inline   Expire-date: $inline_expire"
		done
	fi
} # => inline_expire ()

# Keep an inline-index file for inline certs to manage revoke/renew
inline_index_update ()
{
	[ $# -ge 1 ] || die "Required option(s): <update_index_action>"
	update_index_action="$1"

	verify_tls_init

	# Verify inline-index Hash
	inline_index_verify_index_hash || die "inline-index is corrupt"

	case "$update_index_action" in
	add)
		# Add the inline_serial not the crt_serial
		# Inline serial
		inline_serial=""
		inline_crt_serial

		# If this HASH is set then another function is responsible for it
		[ "$inline_hash" ] && \
			die "Do not allow a HASH here: inline_index_update add"

		# Create new HASH
		generate_file_hash "$inline_file" || \
			die "inline_index_update add: Failed to hash: $inline_file"
		inline_hash="$generated_hash"

		# Create new record
		new_record="$name $inline_serial $inline_hash"
		[ $EASYTLS_TLSCV2_SUBKNAME ] && \
			new_record="$new_record $EASYTLS_TLSCV2_SUBKNAME"
		printf "%s\n" "$new_record" >> \
			"$EASYTLS_INLINE_INDEX" || \
			die "Failed to update $EASYTLS_INLINE_INDEX"

		easytls_verbose "  ADD: $new_record"
	;;
	del)
		# Note: Inline HASH is unique, regardless of --sub-key-name
		# Identify old record
		old_record="${name}[[:blank:]]${inline_serial}[[:blank:]]${inline_hash}"

		# Find old record
		grep "^${old_record}" "$EASYTLS_INLINE_INDEX" 1>/dev/null || {
			help_note="Missing record: $old_record"
			die "inline_index_update del: Failed to find old record"
			}

		# Remove old record
		easytls_verbose "  DEL: $old_record"
		sed -i -e "/^${old_record}.*$/d" "$EASYTLS_INLINE_INDEX" || {
			help_note="Missing record: $old_record"
			die "inline_index_update del: Failed write"
			}
	;;
	*)
		die "Unknown index action: $update_index_action"
	;;
	esac

	# Keep a hash of the inline-index
	inline_index_save_index_hash || Die "Failed to update inline-index hash"

	easytls_verbose "Inline Index Update complete!"
} # => inline_index_update ()

# Verify current inline-index hash
inline_index_verify_index_hash ()
{
	[ -f "$EASYTLS_IL_INDEX_HASH" ] || {
		error_msg "inline_index_verify_index_hash - Missing index file."
		return 1
		}

	# Read the saved hash
	inline_index_saved_hash="$(cat "$EASYTLS_IL_INDEX_HASH")"

	# Generate the current hash
	generate_file_hash "$EASYTLS_INLINE_INDEX" || {
		error_msg "inline_index_verify_index_hash - generate_file_hash"
		return 1
		}

	inline_index_current_hash="$generated_hash"
	# Verify hash match
	[ "$inline_index_saved_hash" = "$inline_index_current_hash" ] || {
		error_msg "inline_index_verify_index_hash - Verify hash match"
		return 1
		}

	easytls_verbose "Inline-index hash check OK"
}

# Save new inline-index hash
inline_index_save_index_hash ()
{
	# Generate the current hash
	generate_file_hash "$EASYTLS_INLINE_INDEX" || {
		error_msg "inline_index_save_index_hash - Generate the current hash"
		return 1
		}

	inline_index_current_hash="$generated_hash"
	# Save the current hash
	printf '%s\n' "$inline_index_current_hash" > "$EASYTLS_IL_INDEX_HASH" || {
		error_msg "inline_index_save_index_hash - Save the current hash"
		return 1
		}

	easytls_verbose "Inline-index hash saved OK"
}

# Generate SHA1 file hash
generate_file_hash ()
{
	# Test for file
	[ -f "$1" ] || {
		error_msg "generate_file_hash - Missing file: $1"
		return 1
		}

	# What ever openssl says ..
	openssl_hash="$("$EASYRSA_OPENSSL" sha1 -r "$1")"

	# Assume it is a valid HASH
	generated_hash="${openssl_hash%% *}"

	# Test it
	printf '%s' "$generated_hash" | grep -q '^[[:xdigit:]]\{40\}$' || {
		error_msg "generate_file_hash - Invalid hash: $generated_hash"
		return 1
		}

	# Hash OK
	return 0
}

# Check inline-file hash
verify_inline_hash ()
{
	# This is a check so check everything here
	# every value and file must exist at this time
	# Try to logically illiminate the need for these checks

	[ -z "$name" ] && \
		die "verify_inline_hash: Missing value: name"
	#easytls_verbose "name: $name"

	# May not require this
	#[ -z "$crt_serial" ] && \
	#	die "verify_inline_hash: Missing value: crt_serial"

	# Must have inline_serial
	[ -z "$inline_serial" ] && \
		die "verify_inline_hash: Missing value: inline_serial"
	#easytls_verbose "inline_serial: $inline_serial"

	# Should not have this HASH, that is the reason to do this check
	# If we already have a HASH then something else is wrong
	[ -n "$inline_hash" ] && \
		die "verify_inline_hash: Found value: inline_hash $inline_hash"
	#easytls_verbose "inline_hash: $inline_hash"

	# Already have inline_serial so this file MUST exist so remove test
	# Not so during an index rebuild
	[ -z "$inline_file" ] && \
		die "verify_inline_hash: Missing value: inline_file"
	[ -f "$inline_file" ] || \
		die "verify_inline_hash: Missing file: $inline_file"
	#easytls_verbose "inline_file: $inline_file"

	# generate current file HASH
	generate_file_hash "$inline_file" || \
		die "verify_inline_hash: Failed to hash: $inline_file"
	real_hash="$generated_hash"
	#easytls_verbose "real_hash: $generated_hash"

	# Search for current HASH
	find_hash="$(inline_index_search_inline_hash)"

	case "$find_hash" in
	0)
		# HASH check failed
		help_note="HASH incorrect for: $inline_file"
	;;
	1)
		# This is the correct HASH so set it
		# If this does not work in another function
		# then control it from that function
		inline_hash="$real_hash"

		# HASH is correct
		return 0
	;;
	*) help_note="HASH check unknown error: $find_hash"
	;;
	esac

	# There is only one way out of this..
	return 1
} # => verify_inline_hash ()

# Get serial number from inline index file using Common name as key
inline_index_common_name_to_serial ()
{
	# TODO: This could be effected by duplicate names from easyrsa
	# This function is defunct but keep it for the EasyRSA early warning
	# Other functions could be effected
	# https://github.com/TinCanTech/easy-tls/issues/48
	# Maybe close this as "EasyRSA leaves an indeterminate grace period for
	# partially renewed certs to be completely renewed by revoking the old cert"
	# EasyTLS can work with that
	#grep "^${name}[[:blank:]].*$" \
	#	"$EASYTLS_INLINE_INDEX" | awk '{print $2}'
	script="{if(\$1 ~ /^${name}\$/) print \$2}"
	awk "$script" "$EASYTLS_INLINE_INDEX"
	unset script
}

# Get Common name from inline index file using serial number as key
inline_index_serial_to_common_name ()
{
	Target_File="${1:-"$EASYTLS_INLINE_INDEX"}"
	script="{if(\$2 ~ /^${inline_serial}\$/) print \$1}"
	awk -P "$script" "$Target_File"
	unset script
}

# Get Common name from inline index file using inline hash as key
inline_index_ilhash_to_common_name ()
{
	script="{if(\$3 ~ /^${known_inline_hash}\$/) print \$1}"
	awk "$script" "$EASYTLS_INLINE_INDEX"
	unset script
}

# Get sub name from inline index file using inline hash as key
inline_index_ilhash_to_sub_name ()
{
	script="{if(\$3 ~ /^${known_inline_hash}\$/) print \$4}"
	awk "$script" "$EASYTLS_INLINE_INDEX"
	unset script
}

# Get cert serial number from inline index file using inline hash as key
inline_index_ilhash_to_serial ()
{
	script="{if(\$3 ~ /^${known_inline_hash}\$/) print \$2}"
	awk "$script" "$EASYTLS_INLINE_INDEX"
	unset script
}

# Search for hash
inline_index_search_inline_hash ()
{
	# Do not need to search for --sub-key-name
	# because inline file HASH ${real_hash} is unique
	grep -c "^${name}[[:blank:]]${inline_serial}[[:blank:]]${real_hash}" \
		"$EASYTLS_INLINE_INDEX"
}

# Does this .inline file name already have an index record
inline_index_search_valid_cn_list ()
{
	printf '%s\n' "$etls_inline_record_list" | \
		grep -c "[[:blank:]]${name}[[:blank:]]"
}

# Dragon be here ! - Extract CN from openssl index.txt
inline_index_openssl_valid_cn_list ()
{
	grep '^V.*$' "$EASYRSA_INDEX" | \
		sed -e 's`^.*/CN=``g' -e 's`/emailAddress=.*$``g'
}

# Get common_name from inline file
inline_crt_common_name ()
{
	inline_common_name="$(grep '^# EasyTLS - File name base: .*$' "$inline_file")"
	inline_common_name="${inline_common_name##*base: }"
}

# Get serial number from inline file
inline_crt_serial ()
{
	inline_serial="$(grep '^# Serial number: .*$' "$inline_file")"
	inline_serial="${inline_serial##*number: }"
}

# Get and format openssl serial number output
openssl_crt_serial ()
{
	# get the serial number of the certificate -> serial=XXXX
	crt_serial="$("$EASYRSA_OPENSSL" x509 -in "$crt_file" -noout -serial)"
	# remove the serial= part -> we only need the XXXX part
	crt_serial=${crt_serial##*=}
}

# Extract the CommonName from openssl -subject
openssl_crt_cn ()
{
	"$EASYRSA_OPENSSL" x509 -in "$crt_file" \
		-noout -subject -nameopt sep_multiline | \
		grep '^[[:blank:]]*CN=.*$' | \
		sed 's/^[[:blank:]]*CN=//g'
}

# Check inline hash and Copy inline to stdout
inline_show ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	name="$1"
	inline_file="$EASYTLS_PKI/$name.inline"

	verify_tls_init

	[ -f "$inline_file" ] || die "Missing: $inline_file"

	# Inline serial
	inline_serial=""
	inline_crt_serial

	#Check inline hash
	verify_inline_hash || die "Failed HASH: $inline_file"

	# Copy inline to stdout
	cat "$inline_file" || die "Failed to open: $inline_file"
} # => inline_show ()

# Remove .inline file
inline_remove ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	name="$1"
	inline_file="$EASYTLS_PKI/$name.inline"
	[ $EASYTLS_TLSCV2_SUBKNAME ] && \
		inline_file="$EASYTLS_PKI/$name-$EASYTLS_TLSCV2_SUBKNAME.inline"

	verify_tls_init

	[ -f "$inline_file" ] || die "Missing: $inline_file"

	# Get cert serial number from inline file
	inline_serial=""
	inline_crt_serial

	# Confirm remove
	[ ! $silent_remove ] && \
		confirm  "Remove inline file ? " "yes" "Remove: $inline_file"

	# Check .inline HASH prior to removal
	verify_inline_hash || die "inline_remove Failed HASH: $inline_file"

	# Update the index first
	inline_index_update del

	rm "$inline_file" || die "Failed to remove: $inline_file"

	# Inline file and record deleted - Forget the HASH
	# Otherwise 'inline_renew add' still has the HASH
	# Logically, this *cannot* be removed -- tct
	unset inline_hash

	[ ! $silent_remove ] && notice "Inline file removed: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_remove ()

# Rebuild inline index
inline_index_rebuild ()
{
	# TODO
	# TODO WARNING, inline_index_rebuild is a work in progress
	# TODO

	verify_tls_init

	# Do not over write current easytls-inline-index.txt.backup
	[ -f "$EASYTLS_INLINE_INDEX.backup" ] && \
		die "Backup file already exists: $EASYTLS_INLINE_INDEX.backup"

	# Do not over write current easytls-inline-index.hash.backup
	[ -f "$EASYTLS_IL_INDEX_HASH.backup" ] && \
		die "Backup file already exists: $EASYTLS_IL_INDEX_HASH.backup"

	# Warn!
	confirm "Rebuild inline index file ? " "yes" \
		"WARNING: You are about to rebuild easytls-index.txt"

	# Backup current easytls-inline-index.txt
	cp "$EASYTLS_INLINE_INDEX" "$EASYTLS_INLINE_INDEX.backup" || \
		die "Failed to backup: $EASYTLS_INLINE_INDEX"

	# Backup current easytls-inline-index.hash.backup
	cp "$EASYTLS_IL_INDEX_HASH" "$EASYTLS_IL_INDEX_HASH.backup" || \
		die "Failed to backup: $EASYTLS_IL_INDEX_HASH"

	# Check openssl index.txt
	[ -f "$EASYRSA_INDEX" ] || die "Missing: $EASYRSA_INDEX"

	# Flag for functions which need to know the index is being rebuilt
	index_rebuild=1

	# Get list of inline file names by extracting CN and sub from index
	etls_inline_CNsub_name_list="$(inline_index_common_name_sub_name_list)"

	# Create tls dir index file
	head_text="# EastTLS inline-index - Created: $(date)"
	printf '%s\n' "$head_text" > "$EASYTLS_INLINE_INDEX" || \
		inline_index_rebuild_reset "Failed to create inline-index"

	# Create inline-index hash file
	inline_index_save_index_hash || \
		inline_index_rebuild_reset "Failed to create inline-index Hash."

	# Create records from EasyTLS index names
	for i in $etls_inline_CNsub_name_list
	do
		# Reset flag
		unset add_inline_record

		# Clear the previous HASH
		unset inline_hash

		# THIS CAN GO
		# If the name is not a single word then the certificate
		# has been renewed in EasyRSA, which means:
		# There are two Valid record in openssl index.txt
		# with the same CommonName
		# Mitigate this disaster here
		#name="$(printf "%s" "$i" | awk 1 ORS=' ')"
		#name="${name%% *}"

		inline_file="$EASYTLS_PKI/$i.inline"
		[ -f "$inline_file" ] || \
			inline_index_rebuild_reset "Missing Inline file: $inline_file"

		inline_serial=""
		inline_crt_serial
		easytls_verbose "inline_serial: ^$inline_serial^"
		[ -z "$inline_serial" ] && \
			inline_index_rebuild_reset "inline_index_rebuild: No inline_serial"

		inline_common_name=""
		inline_crt_common_name
		easytls_verbose "inline_common_name: ^$inline_common_name^"
		[ -z "$inline_common_name" ] && \
			inline_index_rebuild_reset \
				"inline_index_rebuild: No inline_common_name"

		if [ "$i" = "$inline_common_name" ]
		then
			unset sub_name
			unset EASYTLS_TLSCV2_SUBKNAME
		else
			# This is ugly and needs to be re-thought
			sub_name="${i##"${inline_common_name}-"}"
			EASYTLS_TLSCV2_SUBKNAME="$sub_name"
		fi

		name="$inline_common_name"
		[ -z "$name" ] && inline_index_rebuild_reset "No name"
		easytls_verbose "name: ^$name^"

		# If the x509 cert is missing the inline file still has a copy.
		# The cert may have been revoked and this will create an invalid
		# record which can be removed with `inline-remove`
		crt_file="$EASYRSA_PKI/issued/$name.crt"
		[ -f "$crt_file" ] || warn "Missing crt_file: $crt_file"

		# If there is an inline file for this name
		# then recreate the inline easytls-index record
		# EasyTLS User can remove/create a new inline file
		# Note: The extra space ..
		[ -f "$inline_file" ] && {
			add_inline_record=1
			etls_inline_record_list="$etls_inline_record_list $name "
			}

		# Add the record
		[ $add_inline_record ] && inline_index_update add
		:
	done

	# Inform
	notice "Inline index file successfully rebuilt: $EASYTLS_INLINE_INDEX"
	notice "Use 'easytls status' to confirm."
	print
} # => inline_index_rebuild ()

inline_index_rebuild_reset ()
{
	cp -f "$EASYTLS_INLINE_INDEX.backup" "$EASYTLS_INLINE_INDEX"
	rm -f "$EASYTLS_INLINE_INDEX.backup"

	cp -f "$EASYTLS_IL_INDEX_HASH.backup" "$EASYTLS_IL_INDEX_HASH"
	rm -f "$EASYTLS_IL_INDEX_HASH.backup"

	die "Inline index rebuild failed."
}


############################################################################
#
# EASYTLS INLINE Section
#

# Renew .inline file
inline_renew ()
{
	# Easy-RSA certificate renewal is broken, do not use it.
	error_msg "Easy-TLS does not support inline-renew."
	error_msg "Use: 'easytls inline-remove' to delete the old inline file"
	error_msg "and then create a new inline file for the new certificate."
	return 1

	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			0|1)	key_direction="$1" ;;
			add-dh)	cmd_opts="$cmd_opts add-dh" ;;
			nokey)	cmd_opts="$cmd_opts nokey" ;;
			*)	warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	inline_file="$EASYTLS_PKI/$name.inline"
	crt_file="$EASYRSA_PKI/issued/$name.crt"

	[ -f "$inline_file" ] || die "inline_renew: Missing: $inline_file"
	[ -f "$crt_file" ] || die "inline_renew: Missing: $crt_file"
	openssl_crt_serial

	# Collect the attributes of .inline file
	inline_is_base="$(grep -c '^# EasyTLS - File name base:.*$' "$inline_file")"
	inline_is_tlsauth="$(grep -c '^<tls-auth>$' "$inline_file")"
	inline_is_tlscrypt="$(grep -c '^<tls-crypt>$' "$inline_file")"
	inline_is_tlscryptv2="$(grep -c '^<tls-crypt-v2>$' "$inline_file")"

	# Verify .inline is valid
	[ $inline_is_base -eq 1 ] || \
		die "File is not valid .inline: $inline_file"
	one_type=$((inline_is_tlsauth+inline_is_tlscrypt+inline_is_tlscryptv2))
	[ $one_type -le 1 ] || die "File is not valid .inline: $inline_file"

	# Determine the type of .inline file
	inline_type="tls-base"
	[ $inline_is_tlsauth -eq 1 ] && inline_type="tls-auth"
	[ $inline_is_tlscrypt -eq 1 ] && inline_type="tls-crypt"
	[ $inline_is_tlscryptv2 -eq 1 ] && inline_type="tls-crypt-v2"

	# If --key-direction is specified in command line but does not match
	# current inline setting then issue a warning
	if [ "$inline_type" = "tls-auth" ] && [ $key_direction ]
	then
		# Determine inline <key-direction>
		is_key_dir="$(inline_renew_key_direction)"
		case "$is_key_dir" in
		0|1)
			# Verify if command line wants to change inline
			[ $key_direction -eq $is_key_dir ] || \
			warn "Command line will change inline key-direction"
		;;
		*)
			# Assume key-direction is missing from inline
			warn "TLS-auth key-direction missing"
		;;
		esac
	fi

	# Auto-detect --key-direction if not specified in command line
	# default to current inline file or no_key_direction
	if [ "$inline_type" = "tls-auth" ] && [ ! $key_direction ]
	then
		# Determine inline <key-direction>
		is_key_dir="$(inline_renew_key_direction)"
		case "$is_key_dir" in
			0|1)	key_direction="$is_key_dir" ;;
			*)	warn "TLS-auth key-direction missing" ;;
		esac
	fi

	# Confirm renew type
	confirm "Renew inline file ? " "yes" \
		"Renew: $inline_file as Type: $inline_type"

	# Make a backup of inline file incase renew fails
	[ -f "$inline_file.backup" ] && \
		die "Backup already exists: $inline_file.backup"
	cp "$inline_file" "$inline_file.backup" || \
		die "Unable to create backup: $inline_file.backup"

	# Remove the old .inline file
	# .inline HASH is checked prior to removal
	silent_remove=1
	inline_remove "$name"

	# Disable completion notices from sub processes
	silent_inline=1

	# Build the new .inline file
	case "$inline_type" in
		tls-base)
			silent_base=1
			inline_base "$name" $cmd_opts
			inline_index_update add
		;;
		tls-auth)
			inline_tls_auth "$name" "$key_direction" $cmd_opts
		;;
		tls-crypt)
			inline_tls_crypt_v1 "$name" $cmd_opts
		;;
		tls-crypt-v2)
			inline_tls_crypt_v2 "$name" $cmd_opts
		;;
		*)
			die "Unknown error inline_type: $inline_type"
		;;
	esac

	# Renew successful, remove the backup
	rm -f "$inline_file.backup"

	notice "Inline $inline_type file renewed: $inline_file"
} # => inline_renew ()

# Get current inline key direction
inline_renew_key_direction ()
{
	grep '^key-direction [01]$' "$inline_file" | awk '{print $2}'
}

# Create inline credentials file from Easy-RSA PKI
inline_base ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	while [ -n "$1" ]; do
		case "$1" in
			nokey) no_x509_key=1 ;;
			add-dh) inline_dh_file=1 ;;
			*) warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	ca_file="$EASYRSA_PKI/ca.crt"
	crt_file="$EASYRSA_PKI/issued/$name.crt"
	key_file="$EASYRSA_PKI/private/$name.key"
	[ -z "$inline_file" ] && inline_file="$EASYTLS_PKI/$name.inline"
	help_note="Run 'easytls status' to verify certificate revokation."

	[ -f "$crt_file" ] || die "\
Certificate file missing or revoked: $crt_file
$help_note"

	if [ "$no_x509_key" ]
	then
		# Key file is not required
		:
	else
		# Key file is required
		[ -f "$key_file" ] || die "\
Key file missing or revoked: $key_file
$help_note"
	fi

	if [ "$inline_dh_file" ]
	then
		# dh file is required
		help_note="Use --dh=<file_name> to specify an alternate dh file."
		default_dh_file="$EASYRSA_PKI/dh.pem"
		EASYRSA_DH_FILE="${EASYRSA_DH_FILE:-"$default_dh_file"}"
		[ -f "$EASYRSA_DH_FILE" ] || die "\
Diffy Hellman parameters file missing: $EASYRSA_DH_FILE
$help_note"
	fi
	unset help_note

	# get the serial number of the certificate from openssl
	crt_serial=""
	openssl_crt_serial

	# Check .inline file does not exist
	if [ "$EASYTLS_BATCH" ]
	then
		rm -f "$inline_file"
	else
		[ -f "$inline_file" ] && die "Inline file exists: $inline_file"
	fi

	# Build .inline file
	{
		# Add Custom Group if defined
		[ $EASYTLS_TLSCV2_CG ] && printf "%s\n" "# $EASYTLS_TLSCV2_CG"

		printf "%s\n" "# EasyTLS - File name base: $name"
		printf "%s\n" "# Serial number: $crt_serial"
		printf "%s\n" ""
		printf "%s\n" "<cert>"
		cat "$crt_file"
		printf "%s\n" "</cert>"
		printf "%s\n" ""
		printf "%s\n" "<key>"

		if [ "$no_x509_key" ]
		then
			printf "%s\n" \
			" * Replace this line with your complete x509 key file *"
		else
			cat "$key_file"
		fi

		printf "%s\n" "</key>"
		printf "%s\n" ""
		printf "%s\n" "<ca>"
		cat "$ca_file"
		printf "%s\n" "</ca>"
		printf "%s\n" ""

		if [ "$inline_dh_file" ]
		then
			printf "%s\n" "<dh>"
			cat "$EASYRSA_DH_FILE"
			printf "%s\n" "</dh>"
			printf "%s\n" ""
		fi

	} > "$inline_file" || die "Failed to create inline file: $inline_file"

	# Update INLINE index
	# Only if this is the root caller
	[ ! $silent_base ] && inline_index_update add

	[ ! $silent_base ] && notice "Inline base file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_base ()

# Append TLS auth file to base file
inline_tls_auth ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			0|1)	key_direction="$1" ;;
			add-dh)	cmd_opts="$cmd_opts add-dh" ;;
			nokey)	cmd_opts="$cmd_opts nokey" ;;
			*) 	warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	tls_auth_key="$EASYTLS_PKI/tls-auth.key"
	inline_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_auth_key" ] || \
		die "TLS key file does not exist: $tls_auth_key"

	case "$key_direction" in
		0|1)
			# Using user specified --key-direction
			:
		;;
		*)
			# No key-direction found
			die "key-direction is required! Server=0, client=1."
		;;
	esac

	# Inline base file
	silent_base=1
	inline_base "$name" $cmd_opts

	{	printf "%s\n" "# TLS auth"
		printf "%s\n" ""
		printf "%s\n" "key-direction $key_direction"
		printf "%s\n" ""
		printf "%s\n" "<tls-auth>"
		cat "$tls_auth_key"
		printf "%s\n" "</tls-auth>"
		printf "%s\n" ""
	} >> "$inline_file" || die "Failed to create inline file: $inline_file"

	# Hash inline file and add hash to index
	inline_index_update add

	[ ! $silent_inline ] && \
		notice "Inline TLS auth file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_tls_auth ()

# Append TLS crypt file to base file
inline_tls_crypt_v1 ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			add-dh) cmd_opts="$cmd_opts add-dh" ;;
			nokey) cmd_opts="$cmd_opts nokey" ;;
			*) warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	tls_file="$EASYTLS_PKI/tls-crypt.key"
	inline_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_file" ] || die "TLS key file does not exist: $tls_file"

	# Inline base file
	silent_base=1
	inline_base "$name" $cmd_opts

	{	printf "%s\n" "# TLS crypt"
		printf "%s\n" ""
		printf "%s\n" "<tls-crypt>"
		cat "$tls_file"
		printf "%s\n" "</tls-crypt>"
		printf "%s\n" ""
	} >> "$inline_file" || die "Failed to create inline file: $inline_file"

	# Hash inline file and add hash to index
	inline_index_update add

	[ ! $silent_inline ] && \
		notice "Inline TLS crypt file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_tls_crypt_v1 ()

# Append TLS crypt v2 file to base file
inline_tls_crypt_v2 ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			add-dh) cmd_opts="$cmd_opts add-dh" ;;
			nokey) cmd_opts="$cmd_opts nokey" ;;
			no-md) no_metadata=1 ;;
			add-hw) add_hardware=1 ;;
			*) warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	tls_file="$EASYTLS_PKI/$name-tls-crypt-v2.key"
	metadata_file="$EASYTLS_MD_DIR/$name-tls-crypt-v2.metadata"
	inline_file="$EASYTLS_PKI/$name.inline"

	sub_name="$name-$EASYTLS_TLSCV2_SUBKNAME"
	[ $EASYTLS_TLSCV2_SUBKNAME ] && {
		tls_file="$EASYTLS_PKI/$sub_name-tls-crypt-v2.key"
		metadata_file="$EASYTLS_MD_DIR/$sub_name-tls-crypt-v2.metadata"
		inline_file="$EASYTLS_PKI/$sub_name.inline"
		}

	[ -f "$tls_file" ] || die "TLS key file does not exist: $tls_file"
	[ -f "$inline_file" ] && die "Inline file already exist: $inline_file"
	if [ -f "$metadata_file" ]
	then
		# Get metadata and remove unwanted fields:
		# easytls, CA-Identity and hw-ad
		metadata_string="$(cat "$metadata_file")"
		metadata_string="${metadata_string#* }"
		metadata_string="${metadata_string#* }"
		[ $add_hardware ] || metadata_string="${metadata_string% *}"

		# Get the CA serial number
		ca_cert="$EASYRSA_PKI/ca.crt"
		ca_serial="$(fn_ca_serial)"
		ca_serial="${ca_serial#*=}"
	else
		no_metadata=1
	fi

	# Inline base file
	silent_base=1
	inline_base "$name" $cmd_opts

	{	printf "%s\n" "# TLS crypt v2"
		printf "%s\n" ""
		[ $no_metadata ] || {
			printf '%s\n' "# CA serial: $ca_serial"
			printf '%s\n' "# Key metadata:"
			printf '%s\n' "# $metadata_string"
			printf "%s\n" ""
			}
		printf "%s\n" "<tls-crypt-v2>"
		cat "$tls_file"
		printf "%s\n" "</tls-crypt-v2>"
		printf "%s\n" ""
	} >> "$inline_file" || die "Failed to create inline file: $inline_file"

	# Hash inline file and add hash to index
	inline_index_update add

	[ ! $silent_inline ] && \
		notice "Inline TLS crypt v2 file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_tls_crypt_v2 ()


############################################################################
#
# EASYTLS BUILD Section
#

# Create TLS auth file
build_tls_auth ()
{
	# This is allowed without a complete Easy-RSA PKI
	# Verify Easy-TLS has been correctly setup
	verify_tls_init

	# Verify OpenVPN version and use correct syntax to --genkey
	verify_openvpn
	case $openvpn_version in
	2.5|2.6) build_string="--genkey tls-auth" ;;
	2.4) build_string="--genkey --secret" ;;
	*) die "Unsupported OpenVPN version $openvpn_version" ;;
	esac

	key_file="$EASYTLS_PKI/tls-auth.key"

	[ -f "$key_file" ] && \
		die "TLS auth key already exists: $key_file"

	"$EASYTLS_OPENVPN" $build_string "$key_file" || \
		die "Failed to create TLS auth key: $key_file"

	notice "TLS auth key created: $key_file"
} # => build_tls_auth ()

# Create TLS crypt v1 file
build_tls_crypt_v1 ()
{
	# This is allowed without a complete Easy-RSA PKI
	# Verify Easy-TLS has been correctly setup
	verify_tls_init

	# Verify OpenVPN version and use correct syntax to --genkey
	verify_openvpn
	case $openvpn_version in
	2.5|2.6) build_string="--genkey tls-crypt" ;;
	2.4) build_string="--genkey --secret" ;;
	*) die "Unsupported OpenVPN version $openvpn_version" ;;
	esac

	key_file="$EASYTLS_PKI/tls-crypt.key"

	[ -f "$key_file" ] && \
		die "TLS crypt v1 key already exists: $key_file"

	"$EASYTLS_OPENVPN" $build_string "$key_file" || \
		die "Failed to create TLS crypt v1 key: $key_file"

	notice "TLS crypt v1 key created: $key_file"
} # => build_tls_crypt_v1 ()

# Create TLS crypt v2 server file
build_tls_crypt_v2_server ()
{
	[ $# -ge 1 ] || die "Required option(s): <server_filename_base>"

	# Verify Easy-TLS and Easy-RSA have been correctly setup
	# This key does not require EasyRSA PKI
	# but for the client metadata this script does
	# So make CA a requirement for both server and client
	verify_ca_init

	# Verify OpenVPN version and use correct syntax to --genkey
	verify_openvpn
	case $openvpn_version in
	2.5|2.6) build_string="--genkey tls-crypt-v2-server" ;;
	*) die "Unsupported OpenVPN version $openvpn_version" ;;
	esac

	srv_name="$1"
	srv_cert="$EASYRSA_PKI/issued/$srv_name.crt"
	key_file="$EASYTLS_PKI/$srv_name-tls-crypt-v2.key"

	[ -f "$srv_cert" ] || \
		die "Easy-TLS requires that the x509 certificate has been built.
Missing file: $srv_cert"

	cert_purpose "$srv_cert" 'SSL server : Yes' || \
		die "Certificate must be a Server: $srv_cert"

	[ -f "$key_file" ] && die "Server file already exists: $key_file"

	"$EASYTLS_OPENVPN" $build_string "$key_file" || \
		die "Failed to create tls-crypt-v2-server key: $key_file"

	notice "TLS crypt v2 server key created: $key_file"

	if [ $EASYTLS_BINLINE ]
	then
		inline_tls_crypt_v2 "$srv_name" || warn "Failed to build Inline file!"
	fi

	# Explicit return success
	return 0
} # => build_tls_crypt_v2_server ()

# Create TLS crypt v2 client file
build_tls_crypt_v2_client ()
{
	[ $# -ge 2 ] || \
	die "Required option(s): <server_filename_base> <client_filename_base>"

	# Verify Easy-TLS and Easy-RSA have been correctly setup
	# This key does not require EasyRSA PKI
	# but for the client metadata this script does
	# So make CA a requirement for both server and client
	verify_ca_init

	# Verify OpenVPN version and use correct syntax to --genkey
	verify_openvpn
	case $openvpn_version in
	2.5|2.6) build_string="--genkey tls-crypt-v2-client" ;;
	*) die "Unsupported OpenVPN version $openvpn_version" ;;
	esac

	ca_cert="$EASYRSA_PKI/ca.crt"
	srv_name="$1"
	srv_cert="$EASYRSA_PKI/issued/$srv_name.crt"
	shift

	cli_name="$1"
	cli_cert="$EASYRSA_PKI/issued/$cli_name.crt"
	shift

	# don't do that ..
	[ "$srv_name" = "$cli_name" ] && \
		die "Server name cannot be the same as the client name."

	[ -f "$srv_cert" ] || \
		die "Easy-TLS requires that the x509 certificate has been built.
Missing srv file: $srv_cert"

	[ -f "$cli_cert" ] || \
		die "Easy-TLS requires that the x509 certificate has been built.
Missing cli file: $cli_cert"

	cert_purpose "$cli_cert" 'SSL client : Yes' || \
		die "Certificate must be a Client: $cli_cert"

	in_file="$EASYTLS_PKI/$srv_name-tls-crypt-v2.key"
	key_file="$EASYTLS_PKI/$cli_name-tls-crypt-v2.key"
	metadata_debug="$EASYTLS_MD_DIR/$cli_name-tls-crypt-v2.metadata"

	[ $EASYTLS_TLSCV2_SUBKNAME ] && {
		key_file="$EASYTLS_PKI/$cli_name-$EASYTLS_TLSCV2_SUBKNAME-tls-crypt-v2.key"
		metadata_debug="$EASYTLS_MD_DIR/$cli_name-$EASYTLS_TLSCV2_SUBKNAME-tls-crypt-v2.metadata"
	}

	[ -f "$in_file" ] || die "Server key does not exist: $in_file"
	[ -f "$key_file" ] && die "Client key already exists: $key_file"

	# Capture HW addresses
	EASYTLS_TLSCV2_HWLIST=""
	while [ -n "$1" ]; do
		# Needs to allow multiples. EG: eth & wifi
		EASYTLS_TLSCV2_HWADDR="$1"
		# Verify this is a 12 digit hex only value
		# and add it to the HWLIST
		hw_addr_hex_check "$EASYTLS_TLSCV2_HWADDR" || \
			die "Invalid Hardware Address: $EASYTLS_TLSCV2_HWADDR"
		shift
	done

	# Confirm metadata Custom-Group
	[ $EASYTLS_TLSCV2_CG ] && {
		confirm "Is the Custom-Group field correct ? " "yes" \
		"Custom-Group field for metadata: $EASYTLS_TLSCV2_CG"
		}

	# Confirm --sub-key-name)
	[ -n "$EASYTLS_TLSCV2_SUBKNAME" ] && {
		confirm "Is the Sub-key-name correct ? " "yes" \
		"Sub-key-name field for metadata: $EASYTLS_TLSCV2_SUBKNAME"
		}

	# Confirm metadata Hardware-Address(es)
	[ -n "$EASYTLS_TLSCV2_HWLIST" ] && {
		notice "All Hardware-Addresses are valid length hexidecimal values."
		confirm "Is the Hardware-Address field correct ? " "yes" \
		"Hardware-Address field for metadata: $EASYTLS_TLSCV2_HWLIST"
		}

	metadata=""
	b64_metadata=""
	b64_enc_metadata

	"$EASYTLS_OPENVPN" --tls-crypt-v2 "$in_file" \
		$build_string "$key_file" "$b64_metadata" || \
		die "Failed to create tls-crypt-v2-client key: $key_file"

	notice "TLS crypt v2 client key created: $key_file"

	if [ $EASYTLS_BINLINE ]
	then
		inline_tls_crypt_v2 "$cli_name" || warn "Failed to build Inline file!"
	fi

	# Explicit return success
	return 0
} # => build_tls_crypt_v2_client ()

# Verify the input is a 12 digit hex value and export it to the HW list
hw_addr_hex_check ()
{
	temp_hw_addr="$(printf '%s' "$1" | \
		sed -e 's/\://g' -e 's/\-//g' -e 'y/abcdef/ABCDEF/')"

	[ 12 -eq ${#temp_hw_addr} ] || {
		help_note="Hardware Address must be 12 digits exactly!"
		return 1
		}
	printf '%s\n' "$temp_hw_addr" | grep -q '^[[:xdigit:]]\{12\}$' || {
		help_note="Hardware Address must be hexidecimal digits!"
		return 1
		}
	export EASYTLS_TLSCV2_HWLIST="${EASYTLS_TLSCV2_HWLIST} ${temp_hw_addr}"
	return 0
}

# Base64 encode metadata fields
b64_enc_metadata ()
{
	# metadata strings:
	#
	# All fields are single contiguous words
	#
	# 1.  "easytls-$EASYTLS_VERSION"
	#     easytls-cryptv2-verify.sh only uses the 'easytls' part
	#
	# 2   CA Identity
	#     `openssl output`; Drop decription and remove colons ':' (Hex only field)
	#
	# 3.  Client certificate serial
	#     `openssl output`; Drop the 'serial=' (Hex only field)
	#
	# 4.  Client CommonName
	#
	# 5.  Creation date of this key:
	#     %s     seconds since 1970-01-01 00:00:00 UTC
	#
	# 6.  Custom Group string
	#     Default: EASYTLS
	#
	# 7.  Sub-key Name
	#     Default: NOSUBKEY
	#
	# 8.  Option - TBD
	#     Default: OPT
	#
	# 9.  Hardware Address string:
	#     Default: 000000000000 (This is a simple place holder only)
	#

	# metadata_version
	metadata_version="easytls-$EASYTLS_VERSION"

	# CA Identity
	generate_ca_identity

	# get the serial number of the certificate from openssl
	crt_file="$cli_cert"
	crt_serial=""
	openssl_crt_serial

	# Set creation date
	key_date="$(date +%s)"

	# Build metadata
	metadata="$metadata_version $ca_identity $crt_serial $cli_name $key_date"

	# Append --custom-group
	if [ -n "$EASYTLS_TLSCV2_CG" ]
	then
		metadata="$metadata $EASYTLS_TLSCV2_CG"
	else
		metadata="$metadata EASYTLS"
	fi

	# Append --sub-key-name
	if [ -n "$EASYTLS_TLSCV2_SUBKNAME" ]
	then
		metadata="$metadata $EASYTLS_TLSCV2_SUBKNAME"
	else
		metadata="$metadata NOSUBKEY"
	fi

	# Append opt field (Usage is to be decided)
	if [ -n "$EASYTLS_TLSCV2_OPT" ]
	then
		metadata="$metadata $EASYTLS_TLSCV2_OPT"
	else
		metadata="$metadata OPT"
	fi

	# Append --hw-addr
	if [ -n "$EASYTLS_TLSCV2_HWLIST" ]
	then
		MD_HW_LIST=''
		for i in $EASYTLS_TLSCV2_HWLIST
		do
			MD_HW_LIST="${MD_HW_LIST}+${i}"
		done
		metadata="$metadata ${MD_HW_LIST}+"
	else
		metadata="$metadata 000000000000"
	fi

	# Save metadata in plain text
	save_metadata

	easytls_verbose "metadata: $metadata"
	# Base64 encode metadata
	b64_metadata="$(printf "%s" "$metadata"|"$EASYRSA_OPENSSL" enc -e -a -A)"
} # => b64_enc_metadata ()

# Generate CA Identity from CA fingerprint
generate_ca_identity ()
{
	# Set the CA
	ca_cert="$EASYRSA_PKI/ca.crt"

	# CA fingerprint
	ca_fingerprint="$(fn_ca_fingerprint)"
	easytls_verbose "CA fingerprint: $ca_fingerprint"

	# CA Identity
	ca_identity="$(fn_ca_identity)"
	easytls_verbose "CA Identity: $ca_identity"
} # => generate_ca_identity ()

# Collect CA serial number
fn_ca_serial ()
{
	"$EASYRSA_OPENSSL" x509 -in "$ca_cert" -noout -serial
}

# Collect CA fingerprint
fn_ca_fingerprint ()
{
	"$EASYRSA_OPENSSL" x509 -in "$ca_cert" -noout -fingerprint
}

# Collect CA Identity
fn_ca_identity ()
{
	printf '%s' "$ca_fingerprint" | sed -e 's/^.*=//g' -e 's/://g'
}

# Save metadata
save_metadata ()
{
	printf "%s\n" "$metadata" > "$metadata_debug"
}

# Save the ID
save_id ()
{
	# Verify Easy-TLS and Easy-RSA have been correctly setup
	# Need the CA
	verify_ca_init

	# Generate CA Identity from CA fingerprint
	generate_ca_identity

	printf "%s\n" "$ca_identity" > "$EASYTLS_CA_IDENTITY" || \
		die "Failed to create CA Identify: $EASYTLS_CA_IDENTITY"

	easytls_config id "$ca_identity"

	notice "Saved CA Identify: $EASYTLS_CA_IDENTITY"
}


############################################################################
#
# DISABLED-LIST Section
#

# Manage easytls/disabled-list.txt - Used by easytls-cryptv2-verify.sh
disabled_list_manager ()
{
	action="$1"

	# Allow the list to be rehashed
	case $action in
	rehash)
		# This needs more work to recreate the date stamps.
		disabled_list_update_and_hash || die "Failed to rehash disabled-list."
		notice "disabled-list rehash successful."
		return 0
	;;
	esac

	name="$2"
	crt_file="$EASYRSA_PKI/issued/$name.crt"
	[ -f "$crt_file" ] || die "Cannot find certificate: $crt_file"

	# TODO: should this be PKI init ?
	#verify_pki_init
	verify_tls_init

	# Verify disabled-list Hash
	disabled_list_verify_hash || die "Disabled list is corrupt."

	# get the serial number of the certificate from openssl
	# https://github.com/TinCanTech/easy-tls/issues/80
	crt_serial=""
	openssl_crt_serial

	# Append --sub-key-name
	if [ -n "$EASYTLS_TLSCV2_SUBKNAME" ]
	then
		name="$name $EASYTLS_TLSCV2_SUBKNAME"
	else
		name="$name NOSUBKEY"
	fi

	# Check disabled-list for duplicates
	disabled_list_serial_status="$(disabled_list_serial_search)"
	[ $disabled_list_serial_status -lt 2 ] || die "Serial is duplicated"

	# 'disable' or 'enable' 'serial + name + --sub-key-name'
	case $action in
	disable) # Add serial number to the disabled-list
		if [ $disabled_list_serial_status -eq 0 ]
		then
			printf '%s\n' "$crt_serial $name" >> \
				"$EASYTLS_DISABLED_LIST" || \
				die "Failed to update disabled-list."

			# Verify serial was added
			disabled_list_serial_status="$(disabled_list_serial_search)"
			[ $disabled_list_serial_status -eq 1 ] || \
				die "disabled-list error add"
			disabled_list_updated=1
		else
			# serial is already disabled
			:
		fi
	;;
	enable) # Remove serial number from the disabled-list
		if [ $disabled_list_serial_status -eq 1 ]
		then
			sed -i "/^${crt_serial}[[:blank:]]${name}$/d" \
				"$EASYTLS_DISABLED_LIST" || \
				die "Failed to update disabled-list."

			# Verify serial was removed
			disabled_list_serial_status="$(disabled_list_serial_search)"
			[ $disabled_list_serial_status -eq 0 ] || \
				die "disabled-list error del"
			disabled_list_updated=1
		else
			# serial is already enabled
			:
		fi
	;;
	*) die "disabled-list action invalid: $1"
	;;
	esac

	# Update and/or Notify
	if [ $disabled_list_updated ]
	then
		disabled_list_update_and_hash
		notice "Updated disabled-list: $name ${1}d"
	else
		notice "No change: $name is already ${1}d"
	fi
} # => disabled_list_manager ()

# Search disabled-list for serial number
disabled_list_serial_search ()
{
	grep -c "^${crt_serial}[[:blank:]]${name}$" "$EASYTLS_DISABLED_LIST"
}

# Update disabled-list footer and hash
disabled_list_update_and_hash ()
{
	# Update time-stamp
	update_text="# Updated: $(date) -- $action: $name"
	sed -i -e '/^# Updated: .*$/d' "$EASYTLS_DISABLED_LIST" || {
		error_msg "disabled_list_update_and_hash - Failed sed"
		return 1
		}

	printf '%s\n' "$update_text" >> "$EASYTLS_DISABLED_LIST" || {
		error_msg "disabled_list_update_and_hash - Failed printf"
		return 1
		}

	# Save new disabled-list Hash
	disabled_list_save_hash || {
		error_msg "Failed to save disabled-list Hash"
		return 1
		}
}

# Verify current disable-list hash
disabled_list_verify_hash ()
{
	# Missing disabled-list is ok
	[ -f "$EASYTLS_DISABLED_HASH" ] || return 0

	# Read the saved hash
	disabled_list_saved_hash="$(cat "$EASYTLS_DISABLED_HASH")"

	# Generate the current hash
	generate_file_hash "$EASYTLS_DISABLED_LIST" || {
		error_msg "disabled_list_verify_hash: Hash failed: $EASYTLS_DISABLED_LIST"
		return 1
		}

	# Set current hash
	disabled_list_current_hash="$generated_hash"

	# Verify hash match
	[ "$disabled_list_current_hash" = "$disabled_list_saved_hash" ] || {
		error_msg "disabled_list_verify_hash: Verify hash match failed"
		return 1
		}

	easytls_verbose "Disabled-list hash check OK"
}

# Save new disable-list hash
disabled_list_save_hash ()
{
	# Generate the current hash
	generate_file_hash "$EASYTLS_DISABLED_LIST" || {
		error_msg "disabled_list_save_hash: Hash failed: $EASYTLS_DISABLED_LIST"
		return 1
		}

	# Set current hash
	disabled_list_current_hash="$generated_hash"

	# Save the current hash
	printf '%s\n' "$disabled_list_current_hash" > "$EASYTLS_DISABLED_HASH" || {
		error_msg "disabled_list_save_hash: Write failed: $EASYTLS_DISABLED_HASH"
		return 1
		}
}


############################################################################
#
# Interactive Section
#

interactive_question ()
{
	unset EASYTLS_ANSWER
	print "$EASYTLS_QTEXT"
	read input
	EASYTLS_ANSWER="$input"
}

interactive_build ()
{
	EASYTLS_QTITLE="Easy-TLS Interactive TLS key builder:"
	print "$EASYTLS_QTITLE"
	cmd_head='
* Easy-TLS command:'
	cmd_line='build'

	# Choose Key
	EASYTLS_QTEXT='
Available key types:
[1] TLS Auth key
[2] TLS Crypt V1 key
[3] TLS Crypt V2 key for Server
[4] TLS Crypt V2 key for Client

Select the type of key to build:'
	interactive_question

	case $EASYTLS_ANSWER in
	1)	# Build TLS Auth
		cmd_line="${cmd_line}-tls-auth"
		print "$cmd_head"
		print "  ./easytls $cmd_line"
		# Build key
		build_tls_auth
	;;
	2)	# Build TLS Crypt v1
		cmd_line="${cmd_line}-tls-crypt"
		print "$cmd_head"
		print "  ./easytls $cmd_line"
		# Build key
		build_tls_crypt_v1
	;;
	3)	# Build TLS Crypt v2 Server
		# Set Server name
		cmd_line="${cmd_line}-tls-crypt-v2-server"
		EASYTLS_QTEXT='
Enter the commonName of your Server certificate:'
		interactive_question
		opt_server_name="$EASYTLS_ANSWER"
		cmd_line="${cmd_line} $opt_server_name"
		print "$cmd_head"
		print "  ./easytls $cmd_line"
		# Build key
		build_tls_crypt_v2_server "$opt_server_name"
	;;
	4)	# Build TLS Crypt v2 Client

		# Set Server name
		cmd_line="${cmd_line}-tls-crypt-v2-client"
		EASYTLS_QTEXT='
Enter the commonName of your *Server* certificate:'
		interactive_question
		opt_server_name="$EASYTLS_ANSWER"
		cmd_line="${cmd_line} $opt_server_name"

		# Set Client name
		EASYTLS_QTEXT='
Enter the commonName of your *Client* certificate:'
		interactive_question
		opt_client_name="$EASYTLS_ANSWER"
		cmd_line="${cmd_line} $opt_client_name"

		# Set custom.group name
		EASYTLS_QTEXT="
All client TLS-Crypt-V2 keys must use the same Custom Group.

You should configure your Custom Group like so:
  ./easytls config custom.group NAME

If you have configured your Custom Group or do not require a Custom Group
then leave this field blank.

Your current custom group is: ${EASYTLS_TLSCV2_CG}

Enter your Custom Group name:"
		interactive_question
		opt_customg="$EASYTLS_ANSWER"
		[ -n "$opt_customg" ] && {
			cmd_line="--custom-group=${opt_customg} ${cmd_line}"
			export EASYTLS_TLSCV2_CG="${opt_customg}"
			}

		# Set Sub-key name
		EASYTLS_QTEXT='
Each X509 Client certificate can have multiple TLS-Crypt-V2 keys,
these keys are referred to as Sub-keys.

If you do not require a Sub-key then leave this field blank.

Enter your Sub-key name:'
		interactive_question
		sub_key_name="$EASYTLS_ANSWER"
		[ -n "$sub_key_name" ] && {
			cmd_line="--sub-key-name=${sub_key_name} ${cmd_line}"
			export EASYTLS_TLSCV2_SUBKNAME="${sub_key_name}"
			}

		# Set hardware addresses
		print '
You can lock this key to specific MAC hardware addresses.

Hardware addresses can be in the form of:
* 0123456789ab or 01-23-45-67-89-AB or 01:23:45:67:89:AB

Leave this field blank to continue.
'
		EASYTLS_QTEXT='Enter a single MAC hardware address:'
		while :
		do
			interactive_question
			[ -z "$EASYTLS_ANSWER" ] && break
			opt_hardware="$opt_hardware $EASYTLS_ANSWER"
		done

		cmd_line="${cmd_line} ${opt_hardware}"
		print "$cmd_head"
		print "  ./easytls $cmd_line"

		# Build key
		build_tls_crypt_v2_client \
			"$opt_server_name" "$opt_client_name" ${opt_hardware}
	;;
	*) die "Aborted." ;;
	esac
}

interactive_inline ()
{
	EASYTLS_QTITLE="Easy-TLS Interactive Inline builder:"
	print "$EASYTLS_QTITLE"
	cmd_head='
* Easy-TLS command:'
	cmd_line='inline'

	# Choose Key
	EASYTLS_QTEXT='
[1] Inline with TLS Auth key
[2] Inline with TLS Crypt v1 key
[3] Inline with TLS Crypt v2 key
[4] Inline renewal
[5] Inline removal

Select the type of key to inline:'

	interactive_question

	case $EASYTLS_ANSWER in
	1)	# Inline TLS Auth
		cmd_line="${cmd_line}-tls-auth"

		# Set commonName
		interactive_common_name

		# Set key_dir
		interactive_key_direction

		# Set opt_nokey
		interactive_opt_nokey

		# Set opt_add_dh
		interactive_opt_add_dh

		# Set option --dh
		interactive_custom_dh

		print "$cmd_head"
		print "  ./easytls $cmd_line"

		# Build .inline
		inline_tls_auth \
			${common_name} ${key_direction} ${opt_nokey} ${opt_add_dh}
	;;
	2)	# Inline TLS Crypt v1
		cmd_line="${cmd_line}-tls-crypt"

		# Set commonName
		interactive_common_name

		# Set opt_nokey
		interactive_opt_nokey

		# Set opt_add_dh
		interactive_opt_add_dh

		# Set option --dh
		interactive_custom_dh

		print "$cmd_head"
		print "  ./easytls $cmd_line"

		# Build .inline
		inline_tls_crypt_v1 \
			${common_name} ${opt_nokey} ${opt_add_dh}
	;;
	3)	# Inline TLS Crypt v2
		cmd_line="${cmd_line}-tls-crypt-v2"

		# Set commonName
		interactive_common_name

		# Set option --sub-key-name
		interactive_sub_key_name

		# Set opt_nokey
		interactive_opt_nokey

		# Set opt_add_dh
		interactive_opt_add_dh

		# Set option --dh
		interactive_custom_dh

		# Set opt_no_md
		interactive_opt_no_md

		# Set opt_add_hw
		interactive_opt_add_hw

		print "$cmd_head"
		print "  ./easytls $cmd_line"

		# Build .inline
		inline_tls_crypt_v2 \
			${common_name} ${opt_nokey} ${opt_add_dh} ${opt_no_md} ${opt_add_hw}
	;;
	4)	# Inline renew
		print "Coming soon .."
	;;
	5)	# Inline remove
		print "Coming soon .."
	;;
	*) die "Aborted." ;;
	esac
}

# Set commonName
interactive_common_name ()
{
	unset common_name
	EASYTLS_QTEXT='
Enter the commonName of your certificate:'
	interactive_question
	common_name="$EASYTLS_ANSWER"
	cmd_line="${cmd_line} $common_name"
}

# Set option --sub-key-name
interactive_sub_key_name ()
{
	unset sub_key_name
	EASYTLS_QTEXT='
Do not set Sub-key for a Server file, Only Clients can use Sub-keys

Enter the Sub-key Name for your key:'
	interactive_question
	[ -n "$EASYTLS_ANSWER" ] && {
		sub_key_name="$EASYTLS_ANSWER"
		cmd_line="--dh=${sub_key_name} ${cmd_line}"
		export EASYTLS_TLSCV2_SUBKNAME="${sub_key_name}"
		}
}

# Set key direction
interactive_key_direction ()
{
	unset key_direction
	print '
Enter Key direction [Server=0 or Client=1]
'
	while :
	do
		EASYTLS_QTEXT='Enter 0 or 1:'
		interactive_question
		case "$EASYTLS_ANSWER" in
			0)
				key_direction=0
				break
			;;
			1)
				key_direction=1
				break
			;;
		esac
	done
	cmd_line="${cmd_line} $key_direction"
}

# Set option nokey
interactive_opt_nokey ()
{
	unset opt_nokey
	print "
Do you have the private key for certificate: $common_name ?
"
	while :
	do
		EASYTLS_QTEXT='Enter (y)es or (n)o:'
		interactive_question
		case "$EASYTLS_ANSWER" in
			Y|y|Yes|yes)
				break
			;;
			N|n|No|no)
				opt_nokey='nokey'
				cmd_line="${cmd_line} nokey"
				break
			;;
		esac
	done
}

# Set option add-dh
interactive_opt_add_dh ()
{
	print '
Do you want to inline the Diffy-Hellman parameter file ?
'
	unset opt_add_dh
	while :
	do
		EASYTLS_QTEXT='Enter (y)es or (n)o:'
		interactive_question
		case "$EASYTLS_ANSWER" in
			Y|y|Yes|yes)
				opt_add_dh='add-dh'
				cmd_line="${cmd_line} add-dh"
				break
			;;
			N|n|No|no)
				break
			;;
		esac
	done
}

# Set custom dh file
interactive_custom_dh ()
{
	[ -z "$opt_add_dh" ] && return 0
	unset opt_custom_dh
	EASYTLS_QTEXT='
If you need to use a custom Diffy-Hellman parameters file then
enter the file location and name.

Leave this blank to use the default Easy-TLS DH file.

Enter the DH file name:'
	interactive_question
	[ -n "$EASYTLS_ANSWER" ] && {
		opt_custom_dh="$EASYTLS_ANSWER"
		cmd_line="--dh=${opt_custom_dh} ${cmd_line}"
		export EASYRSA_DH_FILE="${opt_custom_dh}"
		}
}

# Set option no-md
interactive_opt_no_md ()
{
	unset opt_no_md
	print "
Do you want to include the client metadata for certificate: $common_name ?
(For Server inline files, this is ignored)
"
	while :
	do
		EASYTLS_QTEXT='Enter (y)es or (n)o:'
		interactive_question
		case "$EASYTLS_ANSWER" in
			Y|y|Yes|yes)
				break
			;;
			N|n|No|no)
				opt_no_md='no-md'
				cmd_line="${cmd_line} no-md"
				break
			;;
		esac
	done
}

# Set option add-hw
interactive_opt_add_hw ()
{
	[ -n "$opt_no_md" ] && return 0
	unset opt_add_hw
	print '
Do you want to include the hardware addresses in the client metadata ?
'
	while :
	do
		EASYTLS_QTEXT='Enter (y)es or (n)o:'
		interactive_question
		case "$EASYTLS_ANSWER" in
			Y|y|Yes|yes)
				opt_add_hw='add-hw'
				cmd_line="${cmd_line} add-hw"
				break
			;;
			N|n|No|no)
				break
			;;
		esac
	done
}


############################################################################
#
# IMPORT Section
#

# Import pre-existing TLS keys
import_key ()
{
	[ $# -ge 2 ] || \
	die "Required option(s): <file-type> <file-name>"
	key_type="$1"

	# WARNING: Cannot verify the source is actually a valid key!
	key_file="$2"
	[ -f "$key_file" ] || die "Cannot find file: $key_file"

	case "$key_type" in
	tls-auth)
		dest_key="$EASYTLS_PKI/tls-auth.key"
		[ -f "$dest_key" ] && die "Key file exists: $dest_key"
		cp "$key_file" "$dest_key" || \
			die "Failed to import file: $key_file"
		;;
	tls-crypt)
		dest_key="$EASYTLS_PKI/tls-crypt.key"
		[ -f "$dest_key" ] && die "Key file exists: $dest_key"
		cp "$key_file" "$dest_key" || \
			die "Failed to import file: $key_file"
		;;
	tls-crypt-v2)
		# Validate commonName
		default_cert_CN="${key_file%.key}"
		requested_cert_CN="${$3:-$default_cert_CN}"

		cert_file="$EASYRSA_PKI/$requested_cert_CN.crt"
		[ -f "$cert_file" ] || die "Cannot find file: $cert_file"
		actual_cert_CN="$(openssl_crt_cn)"

		if [ "$requested_cert_CN" = "$actual_cert_CN" ]
		then
			: # CN OK
		else
			help_note="Requested CN $requested_cert_CN"
			die "does not match certificate $actual_cert_CN"
		fi

		dest_key="$EASYTLS_PKI/$actual_cert_CN-tls-crypt-v2.key"
		[ -f "$dest_key" ] && die "Key file exists: $dest_key"
		cp "$key_file" "$dest_key" || \
			die "Failed to import file: $key_file"
		;;
	*)
		die "Unknown key type: $key_type"
		;;
	esac

	notice "Successfully imported $key_type key from $key_file to $dest_key"
}

############################################################################
#
# EASYTLS SETUP Section
#

# vars setup
# Here sourcing of 'vars' if present occurs. If not present, defaults are used
# to support running without a sourced config format
vars_setup()
{
	# Try to locate a 'vars' file in order of location preference.
	# If one is found, source it
	vars=

	# set up program path
	prog_file="$0"
	prog_dir="${prog_file%/*}"
	prog_vars="${prog_dir}/vars"
	# set up PKI path
	pki_vars="${EASYRSA_PKI:-$PWD/pki}/vars"

	# command-line path:
	if [ ! -z "$EASYRSA_VARS_FILE" ]; then
	  if [ ! -f "$EASYRSA_VARS_FILE" ]; then
		# If the --vars option does not point to a file
		# then show helpful error.
			die "The file '$EASYRSA_VARS_FILE' was not found."
		fi
		vars="$EASYRSA_VARS_FILE"
	# PKI location, if present:
	elif [ -f "$pki_vars" ]; then
		vars="$pki_vars"
	# EASYRSA, if defined:
	elif [ -n "$EASYRSA" ] && [ -f "$EASYRSA/vars" ]; then
		vars="$EASYRSA/vars"
	# program location:
	elif [ -f "$prog_vars" ]; then
		vars="$prog_vars"
	# vars of last resort ./vars
	elif [ -f "./vars" ]; then
		vars="./vars"
		warn "'./vars' of last resort !"
	fi

	# If a vars file was located, source it
	# If $EASYRSA_NO_VARS is defined (not blank) this is skipped
	if [ -z "$EASYRSA_NO_VARS" ] && [ -n "$vars" ]; then
		EASYRSA_CALLER=1
		. "$vars"
		# Make this a verbose only notice
		easytls_verbose "Note: using Easy-RSA configuration from: $vars"
	fi

	# Set defaults, preferring existing env-vars if present
	set_var
	set_var EASYRSA			"$prog_dir"
	set_var EASYRSA_OPENSSL		"openssl"
	set_var EASYRSA_PKI		"$PWD/pki"
	set_var EASYRSA_TEMP_DIR	"$EASYRSA_PKI"
	set_var EASYRSA_INDEX		"$EASYRSA_PKI/index.txt"

	set_var EASYTLS_PKI		"$EASYRSA_PKI/easytls"
	set_var EASYTLS_DATA_DIR	"$EASYTLS_PKI/data"
	set_var EASYTLS_CONFIG_FILE	"$EASYTLS_DATA_DIR/easytls-config.txt"
	set_var EASYTLS_CONFIG_HASH	"$EASYTLS_DATA_DIR/easytls-config.hash"
	set_var EASYTLS_MD_DIR	"$EASYTLS_PKI/metadata"
	set_var EASYTLS_INLINE_INDEX	"$EASYTLS_DATA_DIR/easytls-inline-index.txt"
	set_var EASYTLS_IL_INDEX_HASH	"$EASYTLS_DATA_DIR/easytls-inline-index.hash"
	set_var EASYTLS_OPENVPN		"openvpn"
	set_var EASYTLS_DISABLED_LIST	"$EASYTLS_PKI/easytls-disabled-list.txt"
	set_var EASYTLS_DISABLED_HASH	"$EASYTLS_DATA_DIR/easytls-disabled-list.hash"
	set_var EASYTLS_CA_IDENTITY	"$EASYTLS_PKI/easytls-ca-identity.txt"

	# Assign value to $EASYRSA_TEMP_DIR_session and work around
	# Windows mktemp bug when parent dir is missing
	if [ -z "$EASYRSA_TEMP_DIR_session" ]; then
		if [ -d "$EASYRSA_TEMP_DIR" ]; then
			EASYRSA_TEMP_DIR_session="$(mktemp_make_temp)"
		else
			# Directory does not exist then we have not run init-pki
			mkdir -p "$EASYRSA_TEMP_DIR" || \
				die "Cannot create $EASYRSA_TEMP_DIR"

			EASYRSA_TEMP_DIR_session="$(mktemp_make_temp)"
			rm -rf "$EASYRSA_TEMP_DIR"
		fi
	fi
} # vars_setup()

# mktemp return temp_dir name
mktemp_make_temp ()
{
	mktemp -du "$EASYRSA_TEMP_DIR/easy-rsa-$$.XXXXXX"
} # => mktemp_make_temp ()

# variable assignment by indirection when undefined; merely exports
# the variable when it is already defined (even if currently null)
# Sets $1 as the value contained in $2 and exports (may be blank)
set_var()
{
	[ $# -eq 0 ] && return
	var=$1
	shift
	value="$*"
	eval "export $var=\"\${$var-$value}\""
} #=> set_var()

# Set the Easy-TLS version
easytls_version ()
{
	notice "Easy-TLS version: $EASYTLS_VERSION"
} # => easy_tls_version ()

############################################################################
#
# EASYTLS COMMAND Section
#

########################################
# Invocation entry point:

EASYTLS_VERSION="1.27a"

# Be secure with a restrictive umask
[ -z "$EASYTLS_NO_UMASK" ] && umask 077

# Parse options
while :; do
	# Separate option from value:
	opt="${1%%=*}"
	val="${1#*=}"
	empty_ok="" # Empty values are not allowed unless excepted

	case "$opt" in
	--batch)
		empty_ok=1
		export EASYTLS_BATCH=1 ;;
	--pki-dir)
		export EASYRSA_PKI="$val" ;;
	--vars)
		export EASYRSA_VARS_FILE="$val" ;;
	-v|--verbose)
		empty_ok=1
		export EASYTLS_VERBOSE=1 ;;
	--silent)
		empty_ok=1
		export EASYTLS_SILENT=1 ;;
	--inline)
		empty_ok=1
		export EASYTLS_BINLINE=1 ;;
	--dh)
		export EASYRSA_DH_FILE="$val" ;;
	--custom-group)
		export EASYTLS_TLSCV2_CG="$val" ;;
	--sub-key-name)
		export EASYTLS_TLSCV2_SUBKNAME="$val" ;;
	--openvpn)
		export EASYTLS_OPENVPN="$val" ;;
	--no-auto-check)
		empty_ok=1
		auto_check_disabled=1 ;;
	*)
		break ;;
	esac

	# fatal error when no value was provided
	if [ ! $empty_ok ] && { [ "$val" = "$1" ] || [ -z "$val" ]; }; then
		die "Missing value to option: $opt"
	fi

	shift
done

# Intelligent env-var detection and auto-loading:
vars_setup

# Load config options - Does not change command line options
easytls_config_use || die "Config error"

# Register cleanup on EXIT
trap "cleanup" EXIT
# When SIGHUP, SIGINT, SIGQUIT, SIGABRT and SIGTERM,
# explicitly exit to signal EXIT (non-bash shells)
trap "exit 1" 1
trap "exit 2" 2
trap "exit 3" 3
trap "exit 6" 6
trap "exit 14" 15

# determine how we were called, then hand off to the function responsible
cmd="$1"
[ -n "$1" ] && shift # scrape off command
case "$cmd" in
	init|init-tls)
		init_tls "$@" || \
			die "Error: init_tls"
		;;
	build)
		interactive_build || \
			die "Error: build"
		;;
	inline)
		interactive_inline || \
			die "Error: inline"
		;;
	bta|build-tls-auth)
		build_tls_auth "$@" || \
			die "Error: build_tls_auth"
		;;
	btc|build-tls-crypt)
		build_tls_crypt_v1 "$@" || \
			die "Error: build_tls_crypt_v1"
		;;
	btv2s|b-tcv2s|build-tls-crypt-v2-server)
		build_tls_crypt_v2_server "$@" || \
			die "Error: build_tls_crypt_v2_server"
		;;
	btv2c|b-tcv2c|build-tls-crypt-v2-client)
		build_tls_crypt_v2_client "$@" || \
			die "Error: build_tls_crypt_v2_client"
		;;
	sid|save-id)
		save_id || \
			die "Error: save_id"
		;;
	s|status)
		status "$@" || \
			die "Error: status"
		;;
	ita|inline-tls-auth)
		inline_tls_auth "$@" || \
			die "Error: inline_tls_auth"
		;;
	itc|inline-tls-crypt)
		inline_tls_crypt_v1 "$@" || \
			die "Error: inline_tls_crypt_v1"
		;;
	itv2|itcv2|inline-tls-crypt-v2)
		inline_tls_crypt_v2 "$@" || \
			die "Error: inline_tls_crypt_v2"
		;;
	irm|irv|inline-remove)
		inline_remove "$@" || \
			die "Error: inline_remove"
		;;
	irn|irw|inline-renew)
		inline_renew "$@" || \
			die "Error: inline_renew"
		;;
	is|inline-show)
		inline_show "$@" || \
			die "Error: inline_show"
		;;
	inline-index-rebuild)
		inline_index_rebuild "$@" || \
			die "Error: inline_index_rebuild"
		;;
	ix|inline-expire)
		inline_expire "$@" || \
			die "Error: inline_expire"
		;;
	cx|cert-expire)
		cert_expire "$@" || \
			die "Error: cert_expire"
		;;
	d|disable)
		disabled_list_manager "disable" "$@" || \
			die "Error: disabled_list_manager"
		;;
	e|enable)
		disabled_list_manager "enable" "$@" || \
			die "Error: disabled_list_manager"
		;;
	disabled-list-rehash)
		disabled_list_manager "rehash" "$@" || \
			die "Error: disabled_list_manager rehash"
		;;
	import-key)
		import_key "$@" || \
			die "Error: import_key"
		;;
	cf|cfg|config)
		easytls_config "$@" || \
			die "Error: easytls_config"
		;;
	v|version)
		easytls_version || \
			die "Error: easytls_version"
		exit 0
		;;
	""|help|-h|--help|--usage)
		cmd_help "$1" || \
			die "Error: cmd_help"
		exit 0
		;;
	*)
		die "Unknown command '$cmd'. Run without commands for help."
		;;
esac

# EasyTLS auto-check
inline_auto_check || die "Error: inline_auto_check"

# vim: ft=sh nu ai sw=8 ts=8 noet
