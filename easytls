#!/bin/sh

# Copyright - negotiable
copyright ()
{
cat << VERBATUM_COPYRIGHT_HEADER_INCLUDE_NEGOTIABLE
# Easy-TLS -- A Shell-based Easy-RSA extension utility to help manage
#               * OpenVPN specific TLS keys
#               * Easy-RSA based x509 security credentials
#               * Verified 'inline' combined OpenVPN node packages
#
# Copyright (C) 2020 Richard Bonhomme (Friday 13th of March 2020)
# https://github.com/TinCanTech/easy-tls
# tincanteksup@gmail.com
# All Rights reserved.
#
# This code is released under version 2 of the GNU GPL
# See LICENSE of this project for full licensing details.
#
# Acknowledgement:
# This utility is "written in the style of" and "borrows heavily from" Easy-RSA
#
VERBATUM_COPYRIGHT_HEADER_INCLUDE_NEGOTIABLE
}

# Easy-TLS requirements:
# + Easy-RSA Version 3.X
# + OpenVPN Version 2.X
#


# Help/usage output to stdout
usage()
{
	# command help:
	print "
Easy-TLS usage and overview

USAGE: easytls [options] COMMAND [command-options]

A list of commands is shown below. To get detailed usage and help for a
command, run:
  ./easytls help COMMAND

For a listing of options that can be supplied before the command, use:
  ./easytls help options

Here is the list of commands available with a short syntax reminder.
Use the 'help' command above to get full usage details.

  init-tls
  build-tls-auth
  build-tls-crypt
  build-tls-crypt-v2-server <server_filename_base>
  build-tls-crypt-v2-client
        <server_filename_base> <client_filename_base> <CUSTOM-GROUP>
  save-id
  status [ cmd-opts ]
  inline-base <filename_base> [ cmd-opts ]
  inline-tls-auth <filename_base> <key_direction> [ cmd-opts ]
  inline-tls-crypt <filename_base> [ cmd-opts ]
  inline-tls-crypt-v2 <filename_base> [ cmd-opts ]
  inline-remove <filename_base>
  inline-renew <filename_base> [ cmd-opts ]
  inline-show <filename_base>
  inline-index-rebuild
  inline-expire <filename_base>
  cert-expire <filename_base> | <ca>
  d|disable <filename_base>
  e|enable <filename_base>
  disabled-list-rehash
  import-key <file-type> <file-name> <commonName>

NOTE: Easy-TLS requires that you have a working EasyRSA PKI in place.
NOTE: Easy-TLS requires that you have OpenVPN installed.

EasyTLS also has a useful Howto with expanded help and examples:
https://github.com/TinCanTech/easy-tls/blob/master/EasyTLS-Howto-ii.md"

	# collect/show dir status:
	err_source="Not defined: vars autodetect failed and no value provided"
	work_dir="${EASYRSA:-$err_source}"
	pki_dir="${EASYRSA_PKI:-$err_source}"
	tls_dir="${EASYTLS_PKI:-$err_source}"
	print "
DIRECTORY STATUS (commands would take effect on these locations)
  EASYRSA: $work_dir
      PKI: $pki_dir
      TLS: $tls_dir"
} # => usage()

# Detailed command help
# When called with no args, calls usage(), otherwise shows help for a command
cmd_help()
{
	text=""
	opts=""
	case "$1" in
		init-tls) text="
  init-tls
      Removes & re-initializes the TLS key dir" ;;
		build-tls-auth) text="
  build-tls-auth
      Create an OpenVPN TLS auth PSK (tls-auth.key)" ;;
		build-tls-crypt) text="
  build-tls-crypt
      Create an OpenVPN TLS crypt PSK (tls-crypt.key)" ;;
		build-tls-crypt-v2-server) text="
  build-tls-crypt-v2-server <server_filename_base>
      Create an OpenVPN TLS crypt V2 Server key" ;;
		build-tls-crypt-v2-client) text="
  build-tls-crypt-v2-client
        <server_filename_base> <client_filename_base> <CUSTOM-GROUP>

      Create an OpenVPN TLS crypt V2 Client key

      <CUSTOM-GROUP> is an optional single word which can be appended to
      the client key metadata.  This must be a single contiguous word.
      EG: TinCanTech-EasyTLS.net

      The <CUSTOM-GROUP> can also be matched against in easytls-cryptv2-verify.sh
      by using the command line switch --c|custom-group=TinCanTech-EasyTLS.net

      The metadata can also be used to specify Hardware Addresses which this key
      is allowed to be used on.  See option --hw-addr for further details." ;;
		save-id) text="
  save-id [ no options ]
      Save the CA-Identity to easytls/easytls-ca-identity.txt
      CA-Identity is the Hex ONLY value of the CA finger print.
      This can then by used by easytls-cryptv2-verify.sh as a time-saver
      by not needing to load openssl to generate the CA fingerprint.
      Combining this with 'easytls-cryptv2-verify.sh --verify-via-index',
      openssl binary never needs to be loaded by easytls-cryptv2-verify.sh
      See EasyTLS Howto for an example." ;;
		status) text="
  status [ cmd-opts ]
      Compare Easy-RSA certificate(s) to Easy-TLS inline(s) status"
			opts="
	val|valid   - List only Easy-RSA valid certificates
	rev|revoked - List only Easy-RSA revoked certificates
	inl|inline  - List only Easy-TLS inline files
	inv|invalid - List only Easy-TLS invalid inline files
	ren|renewed - List only Easy-RSA renewed certificates" ;;
		inline-base) text="
  inline-base <filename_base> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA files only
      for VPN node <filename_base>"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-tls-auth) text="
  inline-tls-auth <filename_base> <key_direction> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS auth file
      <key_direction> '0' or '1'
      (If key-direction is omitted then do not add key-direction to inline file)"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-tls-crypt) text="
  inline-tls-crypt <filename_base> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS crypt file"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-tls-crypt-v2) text="
  inline-tls-crypt-v2 <filename_base> [ cmd-opts ]
      Create a complete OpenVPN node package from Easy-RSA and Easy-TLS files
      for VPN node <filename_base> using the Easy-TLS TLS crypt v2 file"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option
        add-md  - Add public metadata details to inline file
                  The CA-Identity(private) is replaced with CA serial number" ;;
		inline-remove) text="
  inline-remove <filename_base>
      Delete <filename_base>.inline when Easy-RSA certificate is revoked" ;;
		inline-renew) text="
  inline-renew <filename_base> [ cmd-opts ]
      Renew <filename_base>.inline when Easy-RSA certificate is renewed"
			opts="
        nokey   - do not require an x509 key (default: key is required)
        add-dh  - inline Diffy Hellman parameters file
                  Default file is easyrsa3/pki/dh.pem
                  To specify an alternative file use the --dh option" ;;
		inline-show) text="
  inline-show <filename_base>
      Copy <filename_base>.inline to stdout" ;;
		inline-index-rebuild) text="
  inline-index-rebuild
      Rebuild easytls-index.txt
      If you need to do this then you may have found a bug, please
      raise an issue https://github.com/TinCanTech/easy-tls/issues" ;;
		inline-expire) text="
  inline-expire <filename_base>
      Display inline expiry date for <filename_base>"
			opts="
        If no <filename_base> is given then list all inline expiry dates" ;;
		cert-expire) text="
  cert-expire <filename_base> | <ca>
      Display certificate expiry date for <filename_base>"
			opts="
        If <filename_base> is 'ca' then show ca.crt expiry
        If no <filename_base> is given then list all certificate expiry dates" ;;
		disable) text="
  d|disable <filename_base>
      Add serial number for <filename_base> to the disabled list
      for immediate use by the easytls-cryptv2-verify.sh script" ;;
		enable) text="
  e|enable <filename_base>
      Remove serial number for <filename_base> from the disabled list
      for immediate use by the easytls-cryptv2-verify.sh script" ;;
		disabled-list-rehash) text="
  disabled-list-rehash
       Rehash the disabled-list if the current hash is corrupted.
       Does not rebuild the disabled-list. If there is an error in the list
       then edit the list manually and rehash it with 'disabled-list-rehash'" ;;
		import-key) text="
  import-key <key-type> <key-name> <commonName>
      Import a pre-existing TLS key <key-name> to EasyTLS directory.

      <key-type> is one of the supported TLS key types:
      tls-auth, tls-crypt or tls-crypt-v2.

      Examples (Using default PKI directory):

      Importing TLS-Auth or TLS-Crypt keys renames the key file as shown:

        * 'import-key tls-auth ./ta.key'
          Imported key name: ./pki/easytls/tls-auth.key

        * 'import-key tls-crypt ./tc.key'
          Imported key name: ./pki/easytls/tls-crypt.key

      TLS-crypt-v2 keys must be named after the commonName of the entity:
      (Default <commonName> is <key-name>)

        * 'import-key tls-crypt-v2 ./serv-v2.key server'
          Imported key name: ./pki/easytls/server-tls-crypt-v2.key

        * 'import-key tls-crypt-v2 ./cli2-v2.key client02'
          Imported key name: ./pki/easytls/client02-tls-crypt-v2.key" ;;

		options)
			opt_usage ;;
		"")
			usage ;;
		*) text="
  Unknown command: '$1' (try without commands for a list of commands)" ;;
	esac

	# display the help text
	[ -n "$text" ] && print "$text"
	[ -n "$opts" ] && print "
      cmd-opts is an optional set of command options from this list:
$opts"
	return 0
} # => cmd_help()

# Options usage
opt_usage()
{
	print "
Easy-TLS Global Option Flags

The following options may be provided before the command. Options specified
at runtime override env-vars and any 'vars' file in use. Unless noted,
non-empty values to options are mandatory.

General options:

--openvpn=\"FILE\"  : The full (or relative) <path-to> and <file-name-of>
                    your preferred openvpn(.exe) executable openvpn file.
--no-auto-check   : For performance you can disable auto-check.
--batch           : Set automatic (no-prompts when possible) mode.
--verbose         : Verbose output.
--silent          : Silence all message output except prompts.
--pki-dir=DIR     : Declare the EasyRSA PKI directory.
--vars=FILE       : Define a specific 'vars' file to use for Easy-RSA config.
--dh=FILE         : Define an alternate Diffy Hellman parameters file.
--hw-addr=hex     : Can only be used with 'build-tls-crypt-v2-client' to
                    define a hardware address to be saved in the metadata.
                    The hardware address field must be exactly 12 hexidecimal digits.
                    This option can be specified multiple times.  EG: Eth & Wifi"
} # => opt_usage()

# Wrapper around printf - clobber print since it's not POSIX anyway
print() { printf "%s\n" "$*"; }

# Exit fatally with a message to stderr
# present even with EASYTLS_BATCH as these are fatal problems
die()
{
	easytls_version
	print "
Easy-TLS error:

$help_note

$1" 1>&2
	exit "${2:-1}"
} # => die()

# remove temp files and do terminal cleanups
cleanup()
{
	[ -z "$EASYRSA_TEMP_DIR_session" ] || rm -rf "$EASYRSA_TEMP_DIR_session"
	(stty echo 2>/dev/null) || { (set -o echo 2>/dev/null) && set -o echo; }
	[ $EASYTLS_SILENT ] || echo "" # just to get a clean line
} # => cleanup()

# non-fatal warning output
warn()
{
	[ "$EASYTLS_SILENT" ] && return
		print "
WARNING:
  $1
" 1>&2
} # => warn()

# informational notices to stdout
notice()
{
	[ "$EASYTLS_SILENT" ] && return
		print "
$1"
} # => notice()

# intent confirmation helper func
# returns without prompting in EASYTLS_BATCH
confirm()
{
	[ "$EASYTLS_BATCH" ] && return
	prompt="$1"
	value="$2"
	msg="$3"
	input=""
	print "
$msg

Type the word '$value' to continue, or any other input to abort."
	printf %s "  $prompt"
	read input
	[ "$input" = "$value" ] && return
	notice "Aborting without confirmation."
	exit 9
} # => confirm()

vars_source_check() {
	# Check for defined EASYRSA_PKI
	[ -n "$EASYRSA_PKI" ] || die "\
EASYRSA_PKI env-var undefined"
} # => vars_source_check()

# Basic sanity-check of PKI init and complain if missing
verify_pki_init () {
	help_note="Run easyrsa without commands for usage and command help."

	# check that the pki dir exists
	vars_source_check
	[ -d "$EASYRSA_PKI" ] || die "\
Easy-TLS requires that you have initialised your Easy-RSA PKI.

Easy-RSA error:

EASYRSA_PKI does not exist (perhaps you need to run init-pki)?
Expected to find the EASYRSA_PKI at: $EASYRSA_PKI
$help_note"

	# verify expected dirs present:
	for i in private reqs; do
		[ -d "$EASYRSA_PKI/$i" ] || die "\
Easy-TLS requires that you have initialised your Easy-RSA PKI.

Easy-RSA error:

Missing expected directory: $i (perhaps you need to run init-pki?)
$help_note"
	done
} # => verify_pki_init()

# Verify core CA files present
verify_ca_init () {
	help_note="Run without commands for usage and command help."

	# First check the PKI has been initialized
	verify_pki_init

	# Verify expected files are present. Allow files to be regular files
	# (or symlinks), but also pipes, for flexibility with ca.key
	for i in serial index.txt index.txt.attr ca.crt private/ca.key; do
		if [ ! -f "$EASYRSA_PKI/$i" ] && [ ! -p "$EASYRSA_PKI/$i" ]; then
			#[ "$1" = "test" ] && return 1
			die "\
Easy-TLS TLS-crypt-v2 requires that you have built your EASY-RSA PKI.

Easy-RSA error:

Missing expected CA file: $i (perhaps you need to run build-ca?)
$help_note"
		fi
	done

	# When operating in 'test' mode, return success.
	# test callers don't care about CA-specific dir structure
	#[ "$1" = "test" ] && return 0

	# verify expected CA-specific dirs:
	for i in issued certs_by_serial
	do
		[ -d "$EASYRSA_PKI/$i" ] || die "\
Easy-TLS TLS-crypt-v2 requires that you have built your EASY-RSA PKI.

Easy-RSA error:

Missing expected CA dir: $i (perhaps you need to run build-ca?)
$help_note"
	done

	# explicitly return success for callers
	return 0

} # => verify_ca_init()

############################################################################
#
# EASYTLS MANGEMENT Section
#

# Verbose messages
easytls_verbose ()
{
	[ $EASYTLS_VERBOSE ] || return 0
	print "$@"
}

# Verify Openvpn is available
verify_openvpn ()
{
	# Find openvpn or openvpn.exe
	help_note="See ./easytls help options - Option: --openvpn"
	if [ -f "$EASYTLS_OPENVPN" ]; then
		: # OK
	elif [ -f 'C:/Program Files/OpenVPN/bin/openvpn.exe' ]; then
		EASYTLS_OPENVPN='C:/Program Files/OpenVPN/bin/openvpn.exe'
	else
		die "OpenVPN not found: $EASYTLS_OPENVPN"
	fi

	# extract openvpn version
	openvpn_version="$("$EASYTLS_OPENVPN" --version)"
	openvpn_version="${openvpn_version#OpenVPN }"
	openvpn_version="${openvpn_version%% *}"
	openvpn_version="${openvpn_version%_*}"
	[ ${#openvpn_version} -gt 3 ] && openvpn_version="${openvpn_version%.*}"
	case "$openvpn_version" in
	2.5|2.6) : ;;
	2.4) : ;;
	*) die "Unsupported OpenVPN version: $openvpn_version" ;;
	esac
	unset help_note
} # => verify_openvpn ()

# Verify TLS has been initialised
verify_tls_init ()
{
	[ -d "$EASYTLS_PKI" ] || die "EasyTLS has not been initialised"
	[ -f "$EASYTLS_INLINE_INDEX" ] || die "EasyTLS has not been initialised"
	[ -f "$EASYTLS_IL_INDEX_HASH" ] || die "EasyTLS has not been initialised"
	[ -f "$EASYTLS_DISABLED_LIST" ] || die "EasyTLS has not been initialised"
	[ -f "$EASYTLS_DISABLED_HASH" ] || die "EasyTLS has not been initialised"
} # => verify_tls_init ()

# init-tls backend:
init_tls ()
{
	# Easy-TLS requires that your Easy-RSA PKI is initialised
	verify_pki_init
	# If EASYTLS_PKI exists, confirm before we rm -rf
	# skipped with EASYTLS_BATCH
	if [ -d "$EASYTLS_PKI" ]; then
		confirm "Confirm removal: " "yes" "
WARNING!!!

You are about to remove the EASYTLS_PKI at: $EASYTLS_PKI
and initialize a fresh TLS PKI here."
		# now remove it:
		rm -rf "$EASYTLS_PKI" \
		|| die "Removal of TLS dir failed. Check/correct errors above"
	fi

	# Create tls dir in Easyrsa PKI dir
	mkdir -p "$EASYTLS_PKI" || die "Failed to create TLS dir (permissions?)"

	# Create data dir in easytls dir
	mkdir -p "$EASYTLS_DATA_DIR" || die "Failed to create data dir (permissions?)"

	# Create metadata dir in easytls dir
	mkdir -p "$EASYTLS_MD_DIR" || die "Failed to create metadata dir (permissions?)"

	# Create tls dir index file
	head_text="# EastTLS inline-index - Created: $(date)"
	printf '%s\n' "$head_text" > "$EASYTLS_INLINE_INDEX" \
		|| die "Failed to create inline-index"

	# Create inline-index hash file
	inline_index_save_index_hash || die "Failed to create inline-index Hash."

	# Create disabled list
	head_text="# EastTLS disabled-list - Created: $(date)"
	printf '%s\n' "$head_text" > "$EASYTLS_DISABLED_LIST" \
		|| die "Failed to create disabled-list"

	# Create disabled list hash file
	disabled_list_save_hash || die "Failed to create disabled-list Hash."

	notice "\
init-tls complete; you may now create TLS keys and .inline files.
Your newly created TLS dir is: $EASYTLS_PKI
"
} # => init_tls ()

# Auto-check for invalid inline files
# Run on exit to avoid "chicken and egg" with init-tls
inline_auto_check ()
{
	[ $auto_check_disabled ] && return
	index_size="$(grep -c '^.*$' "$EASYTLS_INLINE_INDEX")"
	[ $index_size -gt 50 ] && \
		warn "EasyTLS: 50+ .inline files found, use --disable-auto-check"

	auto_check=1
	# Check for revoked EasyRSA certs
	# which still have an inline file
	status invalid || die "inline_auto_check: status invalid error"
	[ $revoked_mismatch_count -eq 0 ] || \
		warn "EasyTLS: Invalid .inline files found: Revoked certs."

	# Check serial number for renewed EasyRSA certs
	# which do not match inline files
	status renewed || die "inline_auto_check: status renewed error"
	[ $renewed_mismatch_count -eq 0 ] || \
		warn "EasyTLS: Invalid .inline files found: Renewed certs."

	# Check inline-index hash
	inline_index_verify_index_hash || warn "inline-index is corrupt"

	# Check disabled-list hash
	disabled_list_verify_hash || warn "Disabled list is corrupt."

	unset auto_check
} # => inline_auto_check ()

# Show Easy-TLS inlines and Easy-RSA certificates
# Report invalid inline files due to certificate revokation
# Report duplicate CNs in EasyRSA due to certificate renewal
status ()
{
	[ $auto_check ] || auto_check_disabled=1
	subsection="$1"

	verify_ca_init

	ersa_valid_cn_list=""
	ersa_valid_serial_list=""
	ersa_revoked_cn_list=""
	ersa_revoked_serial_list=""
	#easytls_valid_cn_list=""
	etls_valid_name_list=""
	etls_valid_serial_list=""
	#easytls_revoked_serial_list="" # Not used

	if [ -n "$subsection" ]
	then
		case "$subsection" in
		val|valid)
				status_easyrsa_valid ;;
		rev|revoked)
				status_easyrsa_revoked ;;
		inl|inline)
				verify_tls_init
				status_easytls_inline ;;
		inv|invalid)
				silent_status=1
				status_easyrsa_valid
				status_easyrsa_revoked
				verify_tls_init
				status_easytls_inline
				unset silent_status
				status_easytls_invalid
				;;
		ren|renewed)
				silent_status=1
				status_easyrsa_valid
				status_easyrsa_revoked
				verify_tls_init
				status_easytls_inline
				unset silent_status
				status_easyrsa_renewed
				;;
		*)
				print "Unknown status option" ;;
		esac
		return
	fi

	print "Easy-RSA: Valid certificates:"
	status_easyrsa_valid

	print "Easy-RSA: Revoked certificates:"
	status_easyrsa_revoked

	verify_tls_init

	print "Easy-TLS: Known inline files:"
	status_easytls_inline

	#print "Easy-TLS: Revoked inline files:"
	#status_easytls_revoked

	print "Easy-TLS: Invalid inline files:"
	status_easytls_invalid

	print "Easy-RSA: Renewed certificates:"
	status_easyrsa_renewed

	# Check inline-index hash
	inline_index_verify_index_hash || warn "inline-index is corrupt"

	# Verify disabled list Hash
	disabled_list_verify_hash || warn "Disabled list is corrupt."

} #=> status ()

# Format status output
status_output ()
{
	awk '{print "  Common-Name " $1 "\t    Serial-number " $2}'
}

# Format status CN
status_cn ()
{
	sed -e 's`^.*/CN=``g' -e 's`/.*$``g'
}

# Extract Valid records from openssl index.txt by crt_serial
status_valid_extract_cn ()
{
	grep "^V.*[[:blank:]]${i}[[:blank:]]" "$EASYRSA_INDEX" | status_cn
}

# Extract Revoked records from openssl index.txt by crt_serial
status_revoked_extract_cn ()
{
	grep "^R.*[[:blank:]]${i}[[:blank:]]" "$EASYRSA_INDEX" | status_cn
}

# Search ersa revoked serial list for etls valid serial
status_search_revoked_serial_list()
{
	printf '%s\n' "$ersa_revoked_serial_list" | grep -c "^${i}$"
}

# List the invalid inline file record by serial number
status_invalid_inline_list ()
{
	grep "^${name}[[:blank:]]${i}[[:blank:]]${inline_hash}$" \
		"$EASYTLS_INLINE_INDEX" | status_output
}

# Print Valid certs from Easy-RSA
status_easyrsa_valid ()
{
	ersa_valid_serial_list="$(grep '^V' "$EASYRSA_INDEX"|awk '{print $3}')"
	for i in $ersa_valid_serial_list
	do
		ersa_valid_cn="$(status_valid_extract_cn)"
		ersa_valid_cn_list="$ersa_valid_cn_list $ersa_valid_cn"
		[ $silent_status ] || print "$ersa_valid_cn $i" | status_output
	done
} # => status_easyrsa_valid ()

# Print Revoked certs from Easy-RSA
status_easyrsa_revoked ()
{
	ersa_revoked_serial_list="$(grep '^R' "$EASYRSA_INDEX"|awk '{print $4}')"
	for i in $ersa_revoked_serial_list
	do
		ersa_revoked_cn="$(status_revoked_extract_cn)"
		ersa_revoked_cn_list="$ersa_revoked_cn_list $ersa_revoked_cn"
		[ $silent_status ] || print "$ersa_revoked_cn $i" | status_output
	done
} # => status_easyrsa_revoked ()

# Print known inline files from Easy-TLS
status_easytls_inline ()
{
	etls_valid_name_list="$(inline_index_common_name_list)"
	etls_valid_serial_list="$(inline_index_serial_number_list)"
	[ $silent_status ] || sed /^#/d "$EASYTLS_INLINE_INDEX" | status_output
} # => status_easytls_valid ()

# Print Revoked certs from Easy-TLS
status_easytls_revoked ()
{
	print "  Easy-TLS does not Revoke certificates."
	print "  If the certificate has been revoked in Easy-RSA then use:"
	print "  'inline-remove <filename_base>' to delete the inline file."
} # => status_easytls_revoked ()

# Check Easy-TLS valid vs Easy-RSA revoked
status_easytls_invalid ()
{
	revoked_mismatch_count=0
	for i in $etls_valid_serial_list
	do
		inline_serial=$i
		name="$(inline_index_serial_to_common_name)"
		inline_file="$EASYTLS_PKI/$name.inline"

		# Clear inline_hash from previous loop
		unset inline_hash
		# Check the .inline HASH
		inline_index_check_inline_hash || die "Failed HASH: $inline_file"

		mismatches="$(status_search_revoked_serial_list)"
		case $mismatches in
		0)
		# No mismatches found
			:
		;;
		1)
			revoked_mismatch_count=$((revoked_mismatch_count+1))
			[ $auto_check ] || status_invalid_inline_list
		;;
		*)
			warn "EasyRSA duplicate records detected!"
			[ $((mismatches)) -gt 1 ] || \
				die "Error in mismatches: $mismatches"
		;;
		esac
	done
} # => status_easytls_invalid ()

# Print Renewed certs from Easy-RSA if they are inlined
status_easyrsa_renewed ()
{
	renewed_mismatch_count=0
	# REMEMBER: If there is no inline file for a cert
	# then EasyTLS does not care if the cert is renewed

	for i in $etls_valid_name_list
	do

	name=$i
	inline_file="$EASYTLS_PKI/$name.inline"
	[ -f "$inline_file" ] || die "Not found: inline_file = $inline_file"
	# Inline serial
	inline_serial=""
	inline_crt_serial

	crt_file="$EASYRSA_PKI/issued/$name.crt"
	if [ -f "$crt_file" ]
	then

		# Certificate serial
		crt_serial=""
		openssl_crt_serial

		if [ "$inline_serial" = "$crt_serial" ]
		then
			# serial match, inline is upto date
			:
		else
			# serial mismatch, cert has been renewed in EasyRSA
			renewed_mismatch_count=$((renewed_mismatch_count+1))
			if [ $silent_status ]
			then
				# No output
				:
			else
				[ $auto_check ] || {
				print "  Common-Name $name"
				print "    Inline-Serial $inline_serial"
				print "    Cert-Serial   $crt_serial"
				}
			fi
		fi
	else
		# EasyRSA renew is broken
		# cert is probably revoked
		:
	fi

	# End of for loop
	done

} # => status_easyrsa_renewed ()

# Cut to only certificate enddate
crt_expire_date_only ()
{
	crt_expire="$(crt_expire_date)"
	crt_expire="${crt_expire##*=}"
} # => crt_expire_date_only ()

# Cut to only inline not after
inline_expire_date_only ()
{
	inline_expire="$(inline_expire_date)"
	inline_expire="${inline_expire##*: }"
} # => inline_expire_date_only ()

# Extract enddate from certificate
crt_expire_date ()
{
	"$EASYRSA_OPENSSL" x509 -in "$crt_file" -noout -enddate
} # => crt_expire_date ()

# Extract enddate from .inline certificate
inline_expire_date ()
{
	grep '^[[:blank:]]\+Not After : ' "$inline_file"
} # => inline_expire_date ()

# Get a list of commonNames from inline-index
inline_index_common_name_list ()
{
	awk '{if ($1 ~ /[^#]/) print $1 " "}' "$EASYTLS_INLINE_INDEX"
}

inline_index_serial_number_list ()
{
	awk '{if ($1 ~ /[^#]/) print $2 " "}' "$EASYTLS_INLINE_INDEX"
}

# Get x509 certificate expiry date
cert_expire ()
{
	name="$1"

	verify_ca_init

	if [ "$name" = "ca" ]
	then
		crt_file="$EASYRSA_PKI/ca.crt"
		[ -f "$crt_file" ] || die "Missing: $crt_file"
		crt_expire_date_only
		print " Certificate: ca.crt   Expire-date: $crt_expire"
	elif [ -n "$name" ]
	then
		crt_file="$EASYRSA_PKI/issued/$name.crt"
		[ -f "$crt_file" ] || die "Missing: $crt_file"
		crt_expire_date_only
		print " Certificate: $name.crt   Expire-date: $crt_expire"
	else
		easyrsa_valid_list="$(grep '^V' "$EASYRSA_INDEX"|status_cn)"
		for name in $easyrsa_valid_list
		do
			crt_file="$EASYRSA_PKI/issued/$name.crt"
			[ -f "$crt_file" ] || die "Missing: $crt_file"
			crt_expire_date_only
		print " Certificate: $name.crt   Expire-date: $crt_expire"
		done
		crt_file="$EASYRSA_PKI/ca.crt"
		[ -f "$crt_file" ] || die "Missing: $crt_file"
		crt_expire_date_only
		print " Certificate: ca.crt   Expire-date: $crt_expire"
	fi
} # => cert_expire ()

# Get inline certificate expiry date
inline_expire ()
{
	name="$1"

	verify_tls_init

	if [ -n "$name" ]
	then
		inline_file="$EASYTLS_PKI/$name.inline"
		[ -f "$inline_file" ] || die "Missing: $inline_file"
		inline_expire_date_only
		print " Certificate: $name.inline   Expire-date: $inline_expire"
	else
	# Get a list of Valid names from easytls-inline-index
	etls_valid_name_list="$(inline_index_common_name_list)"
		for name in $etls_valid_name_list
		do
			inline_file="$EASYTLS_PKI/$name.inline"
			[ -f "$inline_file" ] || die "Missing: $inline_file"
			inline_expire_date_only
		print " Inline-file: $name.inline   Expire-date: $inline_expire"
		done
	fi
} # => inline_expire ()

# Keep an inline-index file for inline certs to manage revoke/renew
inline_index_update ()
{
	[ $# -ge 1 ] || die "Required option(s): <update_index_action>"
	update_index_action="$1"

	verify_tls_init

	# Verify inline-index Hash
	inline_index_verify_index_hash || die "inline-index is corrupt"

	case "$update_index_action" in
	add)
		# Add the inline_serial not the crt_serial
		# Inline serial
		inline_serial=""
		inline_crt_serial

		# If this HASH is set then another function is responsible for it
		[ "$inline_hash" ] && \
			die "Do not allow a HASH here: inline_index_update add"

		# Create new HASH
		generate_file_hash "$inline_file" || \
			die "inline_index_update add: Failed to hash: $inline_file"
		inline_hash="$generated_hash"
		easytls_verbose "  ADD: $name $inline_serial $inline_hash"

		# Create new record
		printf "%s\n" "$name $inline_serial $inline_hash" >> \
			"$EASYTLS_INLINE_INDEX" || \
			die "Failed to update $EASYTLS_INLINE_INDEX"
	;;
	del)
		easytls_verbose "  DEL: $name $inline_serial $inline_hash"

		# Find old record
		grep \
		"^${name}[[:blank:]]${inline_serial}[[:blank:]]${inline_hash}$" \
			"$EASYTLS_INLINE_INDEX" 1>/dev/null || {
			help_note="Failed: inline_index_update del"
			die "Missing record: $name $inline_serial $inline_hash"
			}

		# Remove old record
		sed -i -e \
		"/^${name}[[:blank:]]${inline_serial}[[:blank:]]${inline_hash}$/d" \
			"$EASYTLS_INLINE_INDEX"
	;;
	*)
		die "Unknown index action: $update_index_action"
	;;
	esac

	# Keep a hash of the inline-index
	inline_index_save_index_hash || Die "Failed to update inline-index hash"
} # => inline_index_update ()

# Verify current inline-index hash
inline_index_verify_index_hash ()
{
	# Read the saved hash
	inline_index_saved_hash="$(cat "$EASYTLS_IL_INDEX_HASH")"
	# Generate the current hash
	generate_file_hash "$EASYTLS_INLINE_INDEX" || \
		die "inline_index_update add: Failed to hash: $EASYTLS_INLINE_INDEX"
	inline_index_current_hash="$generated_hash"
	# Verify hash match
	[ "$inline_index_saved_hash" = "$inline_index_current_hash" ] || \
		return 1
	easytls_verbose "Inline-index hash check OK"
}

# Save new inline-index hash
inline_index_save_index_hash ()
{
	# Generate the current hash
	generate_file_hash "$EASYTLS_INLINE_INDEX" || \
		die "inline_index_update add: Failed to hash: $inline_file"
	inline_index_current_hash="$generated_hash"
	# Save the current hash
	printf '%s\n' "$inline_index_current_hash" > \
		"$EASYTLS_IL_INDEX_HASH" || \
		return 1
}

# Generate SHA1 file hash
generate_file_hash ()
{
	[ -r "$1" ] || die "Cannot read: $1"
	openssl_hash="$("$EASYRSA_OPENSSL" sha1 -r "$1")" || return 1
	generated_hash="${openssl_hash%% *}"
}

# Check inline-file hash
inline_index_check_inline_hash ()
{
	# This is a check so check everything here
	# every value and file must exist at this time
	# Try to logically illiminate the need for these checks

	[ -z "$name" ] && \
		die "inline_index_check_inline_hash: Missing value: name"

	# May not require this
	#[ -z "$crt_serial" ] && \
	#	die "inline_index_check_inline_hash: Missing value: crt_serial"

	# Must have inline_serial
	[ -z "$inline_serial" ] && \
		die "inline_index_check_inline_hash: Missing value: inline_serial"

	# Should not have this HASH, that is the reason to do this check
	# If we already have a HASH then something else is wrong
	[ -n "$inline_hash" ] && \
	die "inline_index_check_inline_hash: Found value: inline_hash $inline_hash"

	[ -z "$inline_file" ] && \
		die "inline_index_check_inline_hash: Missing value: inline_file"

	# Already have inline_serial so this file MUST exist so remove test
	#[ -f "$inline_file" ] || \
	#	die "inline_index_check_inline_hash: Missing file: $inline_file"

	# generate current file HASH
	generate_file_hash "$inline_file" || \
		die "inline_index_update add: Failed to hash: $inline_file"
	real_hash="$generated_hash"

	# Search for current HASH
	find_hash="$(inline_index_search_inline_hash)"

	case "$find_hash" in
	0)
		# HASH check failed
		insert_msg="HASH incorrect for: $inline_file"
		insert_msg="Inline index HASH : $inline_hash"
		insert_msg="Inline file HASH : $real_hash"
		help_note="$insert_msg"
	;;
	1)
		# This is the correct HASH so set it
		# If this does not work in another function
		# then control it from that function
		inline_hash="$real_hash"

		# HASH is correct
		return ;;
	*) help_note="HASH check unknown error: $find_hash" ;;
	esac

	# There is only one way out of this..
	return 1
} # => inline_index_check_inline_hash ()

# Get serial number from inline index file using Common name as key
inline_index_common_name_to_serial ()
{
	# TODO: This could be effected by duplicate names from easyrsa
	# This function is defunct but keep it for the EasyRSA early warning
	# Other functions could be effected
	# https://github.com/TinCanTech/easy-tls/issues/48
	grep "^${name}[[:blank:]].*$" \
		"$EASYTLS_INLINE_INDEX" | awk '{print $2}'
}

# Get Common name from inline index file using serial number as key
inline_index_serial_to_common_name ()
{
	grep "^.*[[:blank:]]${inline_serial}[[:blank:]].*$" \
		"$EASYTLS_INLINE_INDEX" | awk '{print $1}'
}

# Search for hash
inline_index_search_inline_hash ()
{
	grep -c "^${name}[[:blank:]]${inline_serial}[[:blank:]]${real_hash}$" \
		"$EASYTLS_INLINE_INDEX"
}

# Does this .inline file name already have an index record
inline_index_search_valid_cn_list ()
{
	printf '%s\n' "$etls_inline_record_list" | \
		grep -c "[[:blank:]]${name}[[:blank:]]"
}

# Dragon be here ! - Extract CN from openssl index.txt
inline_index_openssl_valid_cn_list ()
{
	grep '^V.*$' "$EASYRSA_INDEX" | \
		sed -e 's`^.*/CN=``g' -e 's`/emailAddress=.*$``g'
}

# Get serial number from inline file
inline_crt_serial ()
{
	inline_serial="$(grep '^# Serial number: .*$' "$inline_file")"
	inline_serial="${inline_serial##*number: }"
}

# Get and format openssl serial number output
openssl_crt_serial ()
{
	# get the serial number of the certificate -> serial=XXXX
	crt_serial="$("$EASYRSA_OPENSSL" x509 -in "$crt_file" -noout -serial)"
	# remove the serial= part -> we only need the XXXX part
	crt_serial=${crt_serial##*=}
}

# Extract the CommonName from openssl -subject
openssl_crt_cn ()
{
	"$EASYRSA_OPENSSL" x509 -in "$crt_file" \
		-noout -subject -nameopt sep_multiline | \
		grep '^[[:blank:]]*CN=.*$' | \
		sed 's/^[[:blank:]]*CN=//g'
}

# Check inline hash and Copy inline to stdout
inline_show ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	name="$1"
	inline_file="$EASYTLS_PKI/$name.inline"

	verify_tls_init

	[ -f "$inline_file" ] || die "Missing: $inline_file"

	# Inline serial
	inline_serial=""
	inline_crt_serial

	#Check inline hash
	inline_index_check_inline_hash || die "Failed HASH: $inline_file"

	# Copy inline to stdout
	cat "$inline_file" || die "Failed to open: $inline_file"
} # => inline_show ()

# Remove .inline file
inline_remove ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	name="$1"
	inline_file="$EASYTLS_PKI/$name.inline"

	verify_tls_init

	[ -f "$inline_file" ] || die "Missing: $inline_file"

	# Get serial number from inline file
	inline_serial=""
	inline_crt_serial

	# Confirm remove
	[ ! $silent_remove ] && \
		confirm  "Remove inline file ? " "yes" "Remove: $inline_file"

	# Check .inline HASH prior to removal
	inline_index_check_inline_hash || die "inline_remove Failed HASH: $inline_file"

	rm "$inline_file" || die "Failed to remove: $inline_file"

	inline_index_update del

	# Inline file and record deleted - Forget the HASH
	# Otherwise 'inline_renew add' still has the HASH
	# Logically, this *cannot* be removed -- tct
	unset inline_hash

	[ ! $silent_remove ] && notice "Inline file removed: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_remove ()

# Rebuild inline index
inline_index_rebuild ()
{
	# TODO
	# TODO WARNING, inline_index_rebuild is a work in progress
	# TODO

	# Warn!
	confirm "Rebuild inline index file ? " "yes" \
		"WARNING: You are about to rebuild easytls-index.txt"

	verify_tls_init

	# Do not over write current easytls-index.txt.backup
	[ -f "$EASYTLS_INLINE_INDEX.backup" ] && \
		die "Backup file already exists: $EASYTLS_INLINE_INDEX.backup"

	# Backup current easytls-index.txt
	[ -f "$EASYTLS_INLINE_INDEX" ] && \
		cp "$EASYTLS_INLINE_INDEX" "$EASYTLS_INLINE_INDEX.backup"

	# There is no other way to do this because we need the actual files
	# Get list of files from easytls directory
	etls_inline_file_list="$(ls -1 "$EASYTLS_PKI"/*.inline)"

	# Check openssl index.txt
	[ -f "$EASYRSA_INDEX" ] || die "Missing: $EASYRSA_INDEX"

	# This is where the duplicate names creep in
	# Get list of certs from openssl index.txt
	ersa_valid_cert_list="$(inline_index_openssl_valid_cn_list)"

	# Create tls dir index file
	head_text="# EastTLS inline-index - Created: $(date)"
	printf '%s\n' "$head_text" > "$EASYTLS_INLINE_INDEX" \
		|| die "Failed to create inline-index"

	# Create inline-index hash file
	inline_index_save_index_hash || die "Failed to create inline-index Hash."

	# Create records from openssl Valid names list
	for i in $ersa_valid_cert_list
	do
		# Reset flag
		unset add_inline_record

		# Clear the previous HASH
		unset inline_hash

		# If the name is not a single word then the certificate
		# has been renewed in EasyRSA, which means:
		# There are two Valid record in openssl index.txt
		# with the same CommonName
		# Mitigate this disaster here
		name="$(printf "%s" "$i" | awk 1 ORS=' ')"
		name="${name%% *}"

		crt_serial=""
		inline_file="$EASYTLS_PKI/$name.inline"
		crt_file="$EASYRSA_PKI/issued/$name.crt"

		# If the list contains this name but there is no cert
		# then cannot recreate easytls-index
		# The EasyRSA PKI has been tainted
		help_note="EasyRSA has a record of $name but no certificate."
		[ -f "$crt_file" ] || die "Missing crt_file: $crt_file"
		unset help_note

		# If there is an inline file for this name
		# then recreate the inline easytls-index record
		# EasyTLS User can remove/create a new inline file
		# Note: The extra space ..
		[ -f "$inline_file" ] && {
			add_inline_record=1
			etls_inline_record_list="$etls_inline_record_list $name "
			}

		# If there is an inline-index record for this name
		# then do NOT add another
		if grep -q "^${name}[[:blank:]]" "$EASYTLS_INLINE_INDEX"
		then
			unset add_inline_record
		fi

		# Verify the openssl cert CN
		openssl_cert_cn="$(openssl_crt_cn)"
		[ "$name" = "$openssl_cert_cn" ] || \
			die "CommonName mismatch for :$name: :$openssl_cert_cn:"

		# This always returns the first crt_serial
		# Get the openssl crt_serial
		openssl_crt_serial

		[ $add_inline_record ] && inline_index_update add
	done

	OFS="$IFS"
	IFS='
'
	# Create records from easytls current inline files list
	for full_file_name in $etls_inline_file_list
	do
		# Reset flag
		unset add_inline_record

		# Clear the previous HASH
		unset inline_hash

		# Get name only from full file name
		# Yes, I know this is a bad idea .. raise an issue
		# https://github.com/TinCanTech/easy-tls/issues
		inline_file="$full_file_name"
		part_file_name="${full_file_name%*.inline}"
		name="${part_file_name##*/}"
		[ -f "$inline_file" ] || die "Missing: $inline_file"
		# Inline serial
		inline_serial=""
		inline_crt_serial

		# If found an un-indexed inline file then index it
		inline_file_found_indexed="$(inline_index_search_valid_cn_list)"
		[ $inline_file_found_indexed -eq 0 ] && add_inline_record=1

		[ $add_inline_record ] && inline_index_update add
	done

	IFS="$OFS"
	unset OFS

	# Inform
	notice "Inline index file successfully rebuilt: $EASYTLS_INLINE_INDEX"
	print

	# Verify
	status

} # => inline_index_rebuild ()


############################################################################
#
# EASYTLS INLINE Section
#

# Renew .inline file
inline_renew ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			0|1)	key_direction="$1" ;;
			add-dh)	cmd_opts="$cmd_opts add-dh" ;;
			nokey)	cmd_opts="$cmd_opts nokey" ;;
			*)	warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	inline_file="$EASYTLS_PKI/$name.inline"
	crt_file="$EASYRSA_PKI/issued/$name.crt"

	[ -f "$inline_file" ] || die "inline_renew: Missing: $inline_file"
	[ -f "$crt_file" ] || die "inline_renew: Missing: $crt_file"
	openssl_crt_serial

	# Collect the attributes of .inline file
	inline_is_base="$(grep -c '^# EasyTLS - File name base:.*$' "$inline_file")"
	inline_is_tlsauth="$(grep -c '^<tls-auth>$' "$inline_file")"
	inline_is_tlscrypt="$(grep -c '^<tls-crypt>$' "$inline_file")"
	inline_is_tlscryptv2="$(grep -c '^<tls-crypt-v2>$' "$inline_file")"

	# Verify .inline is valid
	[ $inline_is_base -eq 1 ] || \
		die "File is not valid .inline: $inline_file"
	one_type=$((inline_is_tlsauth+inline_is_tlscrypt+inline_is_tlscryptv2))
	[ $one_type -le 1 ] || die "File is not valid .inline: $inline_file"

	# Determine the type of .inline file
	inline_type="tls-base"
	[ $inline_is_tlsauth -eq 1 ] && inline_type="tls-auth"
	[ $inline_is_tlscrypt -eq 1 ] && inline_type="tls-crypt"
	[ $inline_is_tlscryptv2 -eq 1 ] && inline_type="tls-crypt-v2"

	# If --key-direction is specified in command line but does not match
	# current inline setting then issue a warning
	if [ "$inline_type" = "tls-auth" ] && [ $key_direction ]
	then
		# Determine inline <key-direction>
		is_key_dir="$(inline_renew_key_direction)"
		case "$is_key_dir" in
		0|1)
			# Verify if command line wants to change inline
			[ $key_direction -eq $is_key_dir ] || \
			warn "Command line will change inline key-direction"
		;;
		*)
			# Assume key-direction is missing from inline
			warn "TLS-auth key-direction missing"
		;;
		esac
	fi

	# Auto-detect --key-direction if not specified in command line
	# default to current inline file or no_key_direction
	if [ "$inline_type" = "tls-auth" ] && [ ! $key_direction ]
	then
		# Determine inline <key-direction>
		is_key_dir="$(inline_renew_key_direction)"
		case "$is_key_dir" in
			0|1)	key_direction="$is_key_dir" ;;
			*)	warn "TLS-auth key-direction missing" ;;
		esac
	fi

	# Confirm renew type
	confirm "Renew inline file ? " "yes" \
		"Renew: $inline_file as Type: $inline_type"

	# Make a backup of inline file incase renew fails
	[ -f "$inline_file.backup" ] && \
		die "Backup already exists: $inline_file.backup"
	cp "$inline_file" "$inline_file.backup" || \
		die "Unable to create backup: $inline_file.backup"

	# Remove the old .inline file
	# .inline HASH is checked prior to removal
	silent_remove=1
	inline_remove "$name"

	# Disable completion notices from sub processes
	silent_inline=1

	# Build the new .inline file
	case "$inline_type" in
		tls-base)
			silent_base=1
			inline_base "$name" $cmd_opts
			inline_index_update add
		;;
		tls-auth)
			inline_tls_auth "$name" "$key_direction" $cmd_opts
		;;
		tls-crypt)
			inline_tls_crypt_v1 "$name" $cmd_opts
		;;
		tls-crypt-v2)
			inline_tls_crypt_v2 "$name" $cmd_opts
		;;
		*)
			die "Unknown error inline_type: $inline_type"
		;;
	esac

	# Renew successful, remove the backup
	rm -f "$inline_file.backup"

	notice "Inline $inline_type file renewed: $inline_file"
} # => inline_renew ()

# Get current inline key direction
inline_renew_key_direction ()
{
	grep '^key-direction [01]$' "$inline_file" | awk '{print $2}'
}

# Create inline credentials file from Easy-RSA PKI
inline_base ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	while [ -n "$1" ]; do
		case "$1" in
			nokey) no_x509_key=1 ;;
			add-dh) inline_dh_file=1 ;;
			*) warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	ca_file="$EASYRSA_PKI/ca.crt"
	crt_file="$EASYRSA_PKI/issued/$name.crt"
	key_file="$EASYRSA_PKI/private/$name.key"
	inline_file="$EASYTLS_PKI/$name.inline"
	help_note="Run 'easytls status' to verify certificate revokation."

	[ -f "$crt_file" ] || die "\
Certificate file missing or revoked: $crt_file
$help_note"

	if [ "$no_x509_key" ]
	then
		# Key file is not required
		:
	else
		# Key file is required
		[ -f "$key_file" ] || die "\
Key file missing or revoked: $key_file
$help_note"
	fi

	if [ "$inline_dh_file" ]
	then
		# dh file is required
		help_note="Use --dh=<file_name> to specify an alternate dh file."
		default_dh_file="$EASYRSA_PKI/dh.pem"
		EASYRSA_DH_FILE="${EASYRSA_DH_FILE:-"$default_dh_file"}"
		[ -f "$EASYRSA_DH_FILE" ] || die "\
Diffy Hellman parameters file missing: $EASYRSA_DH_FILE
$help_note"
	fi
	unset help_note

	# get the serial number of the certificate from openssl
	crt_serial=""
	openssl_crt_serial

	# Check .inline file does not exist
	if [ "$EASYTLS_BATCH" ]
	then
		rm -f "$inline_file"
	else
		[ -f "$inline_file" ] && die "Inline file exists: $inline_file"
	fi

	# Build .inline file
	{	printf "%s\n" "# EasyTLS - File name base: $name"
		printf "%s\n" "# Serial number: $crt_serial"
		printf "%s\n" ""
		printf "%s\n" "<cert>"
		cat "$crt_file"
		printf "%s\n" "</cert>"
		printf "%s\n" ""
		printf "%s\n" "<key>"

		if [ "$no_x509_key" ]
		then
			printf "%s\n" \
			" * Replace this line with your complete x509 key file *"
		else
			cat "$key_file"
		fi

		printf "%s\n" "</key>"
		printf "%s\n" ""
		printf "%s\n" "<ca>"
		cat "$ca_file"
		printf "%s\n" "</ca>"
		printf "%s\n" ""

		if [ "$inline_dh_file" ]
		then
			printf "%s\n" "<dh>"
			cat "$EASYRSA_DH_FILE"
			printf "%s\n" "</dh>"
			printf "%s\n" ""
		fi

	} > "$inline_file" || die "Failed to create inline file: $inline_file"

	# Update INLINE index
	# Only if this is the root caller
	[ ! $silent_base ] && inline_index_update add

	[ ! $silent_base ] && notice "Inline base file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_base ()

# Append TLS auth file to base file
inline_tls_auth ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			0|1)	key_direction="$1" ;;
			add-dh)	cmd_opts="$cmd_opts add-dh" ;;
			nokey)	cmd_opts="$cmd_opts nokey" ;;
			*) 	warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	tls_auth_key="$EASYTLS_PKI/tls-auth.key"
	inline_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_auth_key" ] || \
		die "TLS key file does not exist: $tls_auth_key"

	case "$key_direction" in
		0|1)
			# Using user specified --key-direction
			:
		;;
		*)
			# No key-direction found, not inlining --key-direction
			[ $silent_inline ] || \
				warn "TLS-auth key-direction missing"
			no_key_direction=1
		;;
	esac

	# Inline base file
	silent_base=1
	inline_base "$name" $cmd_opts

	{	printf "%s\n" "# TLS auth"
		printf "%s\n" ""

		if [ ! $no_key_direction ]
		then
			printf "%s\n" "key-direction $key_direction"
			printf "%s\n" ""
		fi

		printf "%s\n" "<tls-auth>"
		cat "$tls_auth_key"
		printf "%s\n" "</tls-auth>"
		printf "%s\n" ""
	} >> "$inline_file" || die "Failed to create inline file: $inline_file"

	# Hash inline file and add hash to index
	inline_index_update add

	[ ! $silent_inline ] && \
		notice "Inline TLS auth file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_tls_auth ()

# Append TLS crypt file to base file
inline_tls_crypt_v1 ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			add-dh) cmd_opts="$cmd_opts add-dh" ;;
			nokey) cmd_opts="$cmd_opts nokey" ;;
			*) warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	tls_file="$EASYTLS_PKI/tls-crypt.key"
	inline_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_file" ] || die "TLS key file does not exist: $tls_file"

	# Inline base file
	silent_base=1
	inline_base "$name" $cmd_opts

	{	printf "%s\n" "# TLS crypt"
		printf "%s\n" ""
		printf "%s\n" "<tls-crypt>"
		cat "$tls_file"
		printf "%s\n" "</tls-crypt>"
		printf "%s\n" ""
	} >> "$inline_file" || die "Failed to create inline file: $inline_file"

	# Hash inline file and add hash to index
	inline_index_update add

	[ ! $silent_inline ] && \
		notice "Inline TLS crypt file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_tls_crypt_v1 ()

# Append TLS crypt v2 file to base file
inline_tls_crypt_v2 ()
{
	[ $# -ge 1 ] || die "Required option(s): <filename_base>"

	verify_tls_init

	name="$1"
	shift

	cmd_opts=""
	while [ -n "$1" ]; do
		case "$1" in
			add-dh) cmd_opts="$cmd_opts add-dh" ;;
			nokey) cmd_opts="$cmd_opts nokey" ;;
			add-md) add_metadata=1 ;;
			*) warn "Ignoring unknown command option: '$1'" ;;
		esac
		shift
	done

	tls_file="$EASYTLS_PKI/$name-tls-crypt-v2.key"
	metadata_file="$EASYTLS_MD_DIR/$name-tls-crypt-v2.metadata"
	inline_file="$EASYTLS_PKI/$name.inline"

	[ -f "$tls_file" ] || die "TLS key file does not exist: $tls_file"
	[ -f "$inline_file" ] && die "Inline file already exist: $inline_file"
	if [ $add_metadata ]
	then
		[ -f "$metadata_file" ] || \
			die "metadata file does not exist: $metadata_file"

		# Get metadata and remove unwanted fields: easytls and CA-Identity
		metadata_string="$(cat "$metadata_file")"
		metadata_string="${metadata_string#* }"
		metadata_string="${metadata_string#* }"
		metadata_string="# Key metadata: $metadata_string"

		# Get the CA serial number
		ca_cert="$EASYRSA_PKI/ca.crt"
		ca_serial="$(fn_ca_serial)"
		ca_serial="${ca_serial#*=}"
		ca_serial_string="# CA serial: $ca_serial"
	fi

	# Inline base file
	silent_base=1
	inline_base "$name" $cmd_opts

	{	printf "%s\n" "# TLS crypt v2"
		printf "%s\n" ""
		[ $add_metadata ] && {
			printf '%s\n' "$ca_serial_string"
			printf '%s\n' "$metadata_string"
			printf "%s\n" ""
			}
		printf "%s\n" "<tls-crypt-v2>"
		cat "$tls_file"
		printf "%s\n" "</tls-crypt-v2>"
		printf "%s\n" ""
	} >> "$inline_file" || die "Failed to create inline file: $inline_file"

	# Hash inline file and add hash to index
	inline_index_update add

	[ ! $silent_inline ] && \
		notice "Inline TLS crypt v2 file created: $inline_file"

	# explicitly return success for callers
	return 0

} # => inline_tls_crypt_v2 ()


############################################################################
#
# EASYTLS BUILD Section
#

# Create TLS auth file
build_tls_auth ()
{
	# This is allowed without a complete Easy-RSA PKI
	# Verify Easy-TLS has been correctly setup
	verify_tls_init

	# Verify OpenVPN version and use correct syntax to --genkey
	verify_openvpn
	case $openvpn_version in
	2.5|2.6) build_string="--genkey tls-auth" ;;
	2.4) build_string="--genkey --secret" ;;
	*) die "Unsupported OpenVPN version $openvpn_version" ;;
	esac

	key_file="$EASYTLS_PKI/tls-auth.key"

	[ -f "$key_file" ] && \
		die "TLS auth key already exists: $key_file"

	"$EASYTLS_OPENVPN" $build_string "$key_file" || \
		die "Failed to create TLS auth key: $key_file"

	notice "TLS auth key created: $key_file"
} # => build_tls_auth ()

# Create TLS crypt v1 file
build_tls_crypt_v1 ()
{
	# This is allowed without a complete Easy-RSA PKI
	# Verify Easy-TLS has been correctly setup
	verify_tls_init

	# Verify OpenVPN version and use correct syntax to --genkey
	verify_openvpn
	case $openvpn_version in
	2.5|2.6) build_string="--genkey tls-crypt" ;;
	2.4) build_string="--genkey --secret" ;;
	*) die "Unsupported OpenVPN version $openvpn_version" ;;
	esac

	key_file="$EASYTLS_PKI/tls-crypt.key"

	[ -f "$key_file" ] && \
		die "TLS crypt v1 key already exists: $key_file"

	"$EASYTLS_OPENVPN" $build_string "$key_file" || \
		die "Failed to create TLS crypt v1 key: $key_file"

	notice "TLS crypt v1 key created: $key_file"
} # => build_tls_crypt_v1 ()

# Create TLS crypt v2 server file
build_tls_crypt_v2_server ()
{
	[ $# -ge 1 ] || die "Required option(s): <server_filename_base>"

	# Verify Easy-TLS and Easy-RSA have been correctly setup
	# This key does not require EasyRSA PKI
	# but for the client metadata this script does
	# So make CA a requirement for both server and client
	verify_ca_init

	# Verify OpenVPN version and use correct syntax to --genkey
	verify_openvpn
	case $openvpn_version in
	2.5|2.6) build_string="--genkey tls-crypt-v2-server" ;;
	*) die "Unsupported OpenVPN version $openvpn_version" ;;
	esac

	srv_name="$1"
	srv_cert="$EASYRSA_PKI/issued/$srv_name.crt"
	key_file="$EASYTLS_PKI/$srv_name-tls-crypt-v2.key"

	[ -f "$srv_cert" ] || \
		die "Easy-TLS requires that the x509 certificate has been built.
Missing file: $srv_cert"

	[ -f "$key_file" ] && die "Server file already exists: $key_file"

	"$EASYTLS_OPENVPN" $build_string "$key_file" || \
		die "Failed to create tls-crypt-v2-server key: $key_file"

	notice "TLS crypt v2 server key created: $key_file"
} # => build_tls_crypt_v2_server ()

# Create TLS crypt v2 client file
build_tls_crypt_v2_client ()
{
	[ $# -ge 2 ] || \
	die "Required option(s): <server_filename_base> <client_filename_base>"

	# Verify Easy-TLS and Easy-RSA have been correctly setup
	# This key does not require EasyRSA PKI
	# but for the client metadata this script does
	# So make CA a requirement for both server and client
	verify_ca_init

	# Verify OpenVPN version and use correct syntax to --genkey
	verify_openvpn
	case $openvpn_version in
	2.5|2.6) build_string="--genkey tls-crypt-v2-client" ;;
	*) die "Unsupported OpenVPN version $openvpn_version" ;;
	esac

	ca_cert="$EASYRSA_PKI/ca.crt"
	srv_name="$1"
	srv_cert="$EASYRSA_PKI/issued/$srv_name.crt"
	shift

	cli_name="$1"
	cli_cert="$EASYRSA_PKI/issued/$cli_name.crt"
	shift

	# Need to decide the best way to set these
	EASYTLS_TLSCV2_CG="${EASYTLS_TLSCV2_CG:-"$1"}"

	# don't do that ..
	[ "$srv_name" = "$cli_name" ] && \
		die "Server name cannot be the same as the client name."

	[ -f "$srv_cert" ] || \
		die "Easy-TLS requires that the x509 certificate has been built.
Missing srv file: $srv_cert"

	[ -f "$cli_cert" ] || \
		die "Easy-TLS requires that the x509 certificate has been built.
Missing cli file: $cli_cert"

	in_file="$EASYTLS_PKI/$srv_name-tls-crypt-v2.key"
	key_file="$EASYTLS_PKI/$cli_name-tls-crypt-v2.key"

	[ -f "$in_file" ] || die "Server key does not exist: $in_file"
	[ -f "$key_file" ] && die "Client key already exists: $key_file"

	# Confirm metadata Custom-Group
	[ $EASYTLS_TLSCV2_CG ] && {
		confirm "Is the Custom-Group field correct ? " "yes" \
		"Custom-Group field for metadata: $EASYTLS_TLSCV2_CG"
		}

	# Confirm metadata Hardware-Address(es)
	[ $EASYTLS_TLSCV2_HWADDR ] && {
		notice "All Hardware-Addresses are valid length hexidecimal values."
		confirm "Is the Hardware-Address field correct ? " "yes" \
		"Hardware-Address field for metadata: $EASYTLS_TLSCV2_HWLIST"
		}

	metadata=""
	b64_metadata=""
	b64_enc_metadata

	"$EASYTLS_OPENVPN" --tls-crypt-v2 "$in_file" \
		$build_string "$key_file" "$b64_metadata" || \
		die "Failed to create tls-crypt-v2-client key: $key_file"

	notice "TLS crypt v2 client key created: $key_file"
} # => build_tls_crypt_v2_client ()

# Verify the input is a 12 digit hex value and export it to the HW list
hw_addr_hex_check ()
{
	temp_hw_addr="$(printf '%s' "$1" | \
		sed -e 's/\://g' -e 's/\-//g' -e 'y/abcdef/ABCDEF/')"

	[ 12 -eq ${#temp_hw_addr} ] || {
		help_note="Hardware Address must be 12 digits exactly!"
		return 1
		}
	printf '%s\n' "$temp_hw_addr" | grep -q '^[[:xdigit:]]\{12\}$' || {
			help_note="Hardware Address must be hexidecimal digits!"
			return 1
		}
	export EASYTLS_TLSCV2_HWLIST="${EASYTLS_TLSCV2_HWLIST} ${temp_hw_addr}"
	return 0
}

# Base64 encode metadata fields
b64_enc_metadata ()
{
	# metadata strings:
	#
	# All fields are single contiguous words
	#
	# 1.  "easytls-$EASYTLS_VERSION"
	#     easytls-cryptv2-verify.sh only uses the 'easytls' part
	#
	# 2   CA Identity
	#     `openssl output`; Drop decription, change space to underscore
	#                       and remove colons ':' (Hex only field)
	#
	# 3.  Client certificate serial
	#     `openssl output`; Drop the 'serial=' (Hex only field)
	#
	# 4.  Client CommonName
	#
	# 5.  Creation date of this key:
	#     %s     seconds since 1970-01-01 00:00:00 UTC
	#
	# 6.  Custom Group string:
	#     Default: EASYTLS (This is a simple place holder only)
	#
	# 7.  Hardware Address string:
	#     Default: 000000000000 (This is a simple place holder only)
	#

	# metadata_version
	metadata_version="easytls-$EASYTLS_VERSION"

	# CA Identity
	generate_ca_identity

	# get the serial number of the certificate from openssl
	crt_file="$cli_cert"
	crt_serial=""
	openssl_crt_serial

	# Set creation date
	key_date="$(date +%s)"

	# Build metadata
	metadata="$metadata_version $ca_identity $crt_serial $cli_name $key_date"

	# Append --custom-group
	if [ -n "$EASYTLS_TLSCV2_CG" ]
	then
		metadata="$metadata $EASYTLS_TLSCV2_CG"
	else
		metadata="$metadata EASYTLS"
	fi

	# Append --hw-addr
	if [ -n "$EASYTLS_TLSCV2_HWUSED" ]
	then
		MD_HW_HEAD="HW"
		for i in $EASYTLS_TLSCV2_HWLIST
		do
			MD_HW_LIST="$MD_HW_LIST-$i"
		done
		metadata="$metadata ${MD_HW_HEAD}${MD_HW_LIST}"
	else
		metadata="$metadata 000000000000"
	fi

	# Save metadata in plain text
	save_metadata

	easytls_verbose "metadata: $metadata"
	# Base64 encode metadata
	b64_metadata="$(printf "%s" "$metadata"|"$EASYRSA_OPENSSL" enc -e -a -A)"
} # => b64_enc_metadata ()

# Generate CA Identity from CA fingerprint
generate_ca_identity ()
{
	# Set the CA
	ca_cert="$EASYRSA_PKI/ca.crt"

	# CA fingerprint
	ca_fingerprint="$(fn_ca_fingerprint)"
	easytls_verbose "CA fingerprint: $ca_fingerprint"

	# CA Identity
	ca_identity="$(fn_ca_identity)"
	easytls_verbose "CA Identity: $ca_identity"
} # => generate_ca_identity ()

# Collect CA serial number
fn_ca_serial ()
{
	"$EASYRSA_OPENSSL" x509 -in "$ca_cert" -noout -serial
}

# Collect CA fingerprint
fn_ca_fingerprint ()
{
	"$EASYRSA_OPENSSL" x509 -in "$ca_cert" -noout -fingerprint
}

# Collect CA Identity
fn_ca_identity ()
{
	printf '%s' "$ca_fingerprint" | sed -e 's/^.*=//g' -e 's/://g'
}

# Save metadata
save_metadata ()
{
	metadata_debug="$EASYTLS_MD_DIR/$cli_name-tls-crypt-v2.metadata"
	printf "%s\n" "$metadata" > "$metadata_debug"
}

# Save the ID
save_id ()
{
	# Verify Easy-TLS and Easy-RSA have been correctly setup
	# Need the CA
	verify_ca_init

	# Generate CA Identity from CA fingerprint
	generate_ca_identity

	printf "%s\n" "$ca_identity" > "$EASYTLS_CA_IDENTITY" || \
		die "Failed to create CA Identify: $EASYTLS_CA_IDENTITY"

	notice "Saved CA Identify: $EASYTLS_CA_IDENTITY"
}


############################################################################
#
# DISABLED-LIST Section
#

# Manage easytls/disabled-list.txt - Used by easytls-cryptv2-verify.sh
disabled_list_manager ()
{
	action="$1"

	# Allow the list to be rehashed
	case $action in
	rehash)
		# This needs more work to recreate the date stamps.
		disabled_list_update_and_hash
		notice "disabled-list rehash successful."
		return 0
	;;
	esac

	name="$2"
	crt_file="$EASYRSA_PKI/issued/$name.crt"
	[ -f "$crt_file" ] || die "Cannot find certificate: $crt_file"

	# TODO: should this be PKI init ?
	#verify_pki_init
	verify_tls_init

	# get the serial number of the certificate from openssl
	# https://github.com/TinCanTech/easy-tls/issues/80
	crt_serial=""
	openssl_crt_serial

	# Verify disabled-list Hash
	disabled_list_verify_hash || die "Disabled list is corrupt."

	# Check disabled-list for duplicates
	disabled_list_serial_status="$(disabled_list_serial_search)"
	[ $disabled_list_serial_status -lt 2 ] || die "Serial is duplicated"

	# 'disable' or 'enable' serial number
	case $action in
	disable) # Add serial number to the disabled-list
		if [ $disabled_list_serial_status -eq 0 ]
		then
			printf '%s\n' "$crt_serial $name" >> \
				"$EASYTLS_DISABLED_LIST" || \
				die "Failed to update disabled-list."

			# Verify serial was added
			disabled_list_serial_status="$(disabled_list_serial_search)"
			[ $disabled_list_serial_status -eq 1 ] || \
				die "disabled-list error add"
			disabled_list_updated=1
		else
			# serial is already disabled
			:
		fi
	;;
	enable) # Remove serial number from the disabled-list
		if [ $disabled_list_serial_status -eq 1 ]
		then
			sed -i "/^${crt_serial}[[:blank:]]${name}$/d" \
				"$EASYTLS_DISABLED_LIST" || \
				die "Failed to update disabled-list."

			# Verify serial was removed
			disabled_list_serial_status="$(disabled_list_serial_search)"
			[ $disabled_list_serial_status -eq 0 ] || \
				die "disabled-list error del"
			disabled_list_updated=1
		else
			# serial is already enabled
			:
		fi
	;;
	*) die "disabled-list action invalid: $1"
	;;
	esac

	# Update and/or Notify
	if [ $disabled_list_updated ]
	then
		disabled_list_update_and_hash
		notice "Updated disabled-list: $name ${1}d"
	else
		notice "No change: $name is already ${1}d"
	fi
} # => disabled_list_manager ()

# Search disabled-list for serial number
disabled_list_serial_search ()
{
	grep -c "^${crt_serial}[[:blank:]]${name}$" "$EASYTLS_DISABLED_LIST"
}

# Update disabled-list footer and hash
disabled_list_update_and_hash ()
{
	# Update time-stamp
	update_text="# Updated: $(date) -- $action: $name"
	sed -i -e '/^# Updated: .*$/d' "$EASYTLS_DISABLED_LIST" || \
		die "disabled list update failed"
	printf '%s\n' "$update_text" >> "$EASYTLS_DISABLED_LIST" || \
		die "disabled list update failed"

	# Save new disabled-list Hash
	disabled_list_save_hash || die "Failed to save disabled-list Hash"
}

# Verify current disable-list hash
disabled_list_verify_hash ()
{
	# Read the saved hash
	disabled_list_saved_hash="$(cat "$EASYTLS_DISABLED_HASH")"
	# Generate the current hash
	generate_file_hash "$EASYTLS_DISABLED_LIST" || \
		die "disabled_list_verify_hash: Failed to hash: $inline_file"
	disabled_list_current_hash="$generated_hash"
	# Verify hash match
	[ "$disabled_list_current_hash" = "$disabled_list_saved_hash" ] || \
		return 1
	easytls_verbose "Disabled-list hash check OK"
}

# Save new disable-list hash
disabled_list_save_hash ()
{
	# Generate the current hash
	generate_file_hash "$EASYTLS_DISABLED_LIST" || \
		die "disabled_list_save_hash: Failed to hash: $inline_file"
	disabled_list_current_hash="$generated_hash"
	# Save the current hash
	printf '%s\n' "$disabled_list_current_hash" > \
		"$EASYTLS_DISABLED_HASH" || \
		return 1
}

############################################################################
#
# IMPORT Section
#

# Import pre-existing TLS keys
import_key ()
{
	[ $# -ge 2 ] || \
	die "Required option(s): <file-type> <file-name>"
	key_type="$1"

	# WARNING: Cannot verify the source is actually a valid key!
	key_file="$2"
	[ -f "$key_file" ] || die "Cannot find file: $key_file"

	case "$key_type" in
	tls-auth)
		dest_key="$EASYTLS_PKI/tls-auth.key"
		[ -f "$dest_key" ] && die "Key file exists: $dest_key"
		cp "$key_file" "$dest_key" || \
			die "Failed to import file: $key_file"
		;;
	tls-crypt)
		dest_key="$EASYTLS_PKI/tls-crypt.key"
		[ -f "$dest_key" ] && die "Key file exists: $dest_key"
		cp "$key_file" "$dest_key" || \
			die "Failed to import file: $key_file"
		;;
	tls-crypt-v2)
		# Validate commonName
		default_cert_CN="${key_file%.key}"
		requested_cert_CN="${$3:-$default_cert_CN}"

		cert_file="$EASYRSA_PKI/$requested_cert_CN.crt"
		[ -f "$cert_file" ] || die "Cannot find file: $cert_file"
		actual_cert_CN="$(openssl_crt_cn)"

		if [ "$requested_cert_CN" = "$actual_cert_CN" ]
		then
			: # CN OK
		else
			help_note="Requested CN $requested_cert_CN"
			die "does not match certificate $actual_cert_CN"
		fi

		dest_key="$EASYTLS_PKI/$actual_cert_CN-tls-crypt-v2.key"
		[ -f "$dest_key" ] && die "Key file exists: $dest_key"
		cp "$key_file" "$dest_key" || \
			die "Failed to import file: $key_file"
		;;
	*)
		die "Unknown key type: $key_type"
		;;
	esac

	notice "Successfully imported $key_type key from $key_file to $dest_key"
}

############################################################################
#
# EASYTLS SETUP Section
#

# vars setup
# Here sourcing of 'vars' if present occurs. If not present, defaults are used
# to support running without a sourced config format
vars_setup()
{
	# Try to locate a 'vars' file in order of location preference.
	# If one is found, source it
	vars=

	# set up program path
	prog_file="$0"
	prog_dir="${prog_file%/*}"
	prog_vars="${prog_dir}/vars"
	# set up PKI path
	pki_vars="${EASYRSA_PKI:-$PWD/pki}/vars"

	# command-line path:
	if [ ! -z "$EASYRSA_VARS_FILE" ]; then
	  if [ ! -f "$EASYRSA_VARS_FILE" ]; then
		# If the --vars option does not point to a file
		# then show helpful error.
			die "The file '$EASYRSA_VARS_FILE' was not found."
		fi
		vars="$EASYRSA_VARS_FILE"
	# PKI location, if present:
	elif [ -f "$pki_vars" ]; then
		vars="$pki_vars"
	# EASYRSA, if defined:
	elif [ -n "$EASYRSA" ] && [ -f "$EASYRSA/vars" ]; then
		vars="$EASYRSA/vars"
	# program location:
	elif [ -f "$prog_vars" ]; then
		vars="$prog_vars"
	# vars of last resort ./vars
	elif [ -f "./vars" ]; then
		vars="./vars"
		warn "'./vars' of last resort !"
	fi
	
	# If a vars file was located, source it
	# If $EASYRSA_NO_VARS is defined (not blank) this is skipped
	if [ -z "$EASYRSA_NO_VARS" ] && [ -n "$vars" ]; then
		EASYRSA_CALLER=1
		. "$vars"
		# Make this a verbose only notice
		easytls_verbose "Note: using Easy-RSA configuration from: $vars"
	fi
	
	# Set defaults, preferring existing env-vars if present
	set_var
	set_var EASYRSA			"$prog_dir"
	set_var EASYRSA_OPENSSL		"openssl"
	set_var EASYRSA_PKI		"$PWD/pki"
	set_var EASYRSA_TEMP_DIR	"$EASYRSA_PKI"
	set_var EASYRSA_INDEX		"$EASYRSA_PKI/index.txt"

	set_var EASYTLS_PKI		"$EASYRSA_PKI/easytls"
	set_var EASYTLS_DATA_DIR	"$EASYTLS_PKI/data"
	set_var EASYTLS_MD_DIR	"$EASYTLS_PKI/metadata"
	set_var EASYTLS_INLINE_INDEX	"$EASYTLS_DATA_DIR/easytls-inline-index.txt"
	set_var EASYTLS_IL_INDEX_HASH	"$EASYTLS_DATA_DIR/easytls-inline-index.hash"
	set_var EASYTLS_OPENVPN		"/usr/sbin/openvpn"
	set_var EASYTLS_DISABLED_LIST	"$EASYTLS_PKI/easytls-disabled-list.txt"
	set_var EASYTLS_DISABLED_HASH	"$EASYTLS_DATA_DIR/easytls-disabled-list.hash"
	set_var EASYTLS_CA_IDENTITY	"$EASYTLS_PKI/easytls-ca-identity.txt"

	# Assign value to $EASYRSA_TEMP_DIR_session and work around
	# Windows mktemp bug when parent dir is missing
	if [ -z "$EASYRSA_TEMP_DIR_session" ]; then
		if [ -d "$EASYRSA_TEMP_DIR" ]; then
			EASYRSA_TEMP_DIR_session="$(mktemp_make_temp)"
		else
			# Directory does not exist then we have not run init-pki
			mkdir -p "$EASYRSA_TEMP_DIR" || \
				die "Cannot create $EASYRSA_TEMP_DIR"

			EASYRSA_TEMP_DIR_session="$(mktemp_make_temp)"
			rm -rf "$EASYRSA_TEMP_DIR"
		fi
	fi
} # vars_setup()

# mktemp return temp_dir name
mktemp_make_temp ()
{
	mktemp -du "$EASYRSA_TEMP_DIR/easy-rsa-$$.XXXXXX"
} # => mktemp_make_temp ()

# variable assignment by indirection when undefined; merely exports
# the variable when it is already defined (even if currently null)
# Sets $1 as the value contained in $2 and exports (may be blank)
set_var()
{
	[ $# -eq 0 ] && return
	var=$1
	shift
	value="$*"
	eval "export $var=\"\${$var-$value}\""
} #=> set_var()

# Set the Easy-TLS version
easytls_version ()
{
	notice "Easy-TLS version: $EASYTLS_VERSION"
} # => easy_tls_version ()

############################################################################
#
# EASYTLS COMMAND Section
#

########################################
# Invocation entry point:

EASYTLS_VERSION="1.27"

# Be secure with a restrictive umask
[ -z "$EASYTLS_NO_UMASK" ] && umask 077

# Parse options
while :; do
	# Separate option from value:
	opt="${1%%=*}"
	val="${1#*=}"
	empty_ok="" # Empty values are not allowed unless excepted

	case "$opt" in
	--batch)
		empty_ok=1
		export EASYTLS_BATCH=1 ;;
	--pki-dir)
		export EASYRSA_PKI="$val" ;;
	--vars)
		export EASYRSA_VARS_FILE="$val" ;;
	--verbose)
		empty_ok=1
		export EASYTLS_VERBOSE=1 ;;
	--silent)
		empty_ok=1
		export EASYTLS_SILENT=1 ;;
	--dh)
		export EASYRSA_DH_FILE="$val" ;;
	--custom-group)
		# This is deliberately undocumented
		# Need to decide between --cmd-opt or cmd-word
		export EASYTLS_TLSCV2_CG="$val" ;;
	--hw-addr)
		# Needs to allow multiples. EG: eth & wifi
		export EASYTLS_TLSCV2_HWUSED=1
		EASYTLS_TLSCV2_HWADDR="$val"
		# Verify this is a 12 digit hex only value
		hw_addr_hex_check "$EASYTLS_TLSCV2_HWADDR" || \
			die "Invalid Hardware Address: $EASYTLS_TLSCV2_HWADDR"
		;;
	--openvpn)
		export EASYTLS_OPENVPN="$val" ;;
	--no-auto-check)
		empty_ok=1
		auto_check_disabled=1 ;;
	*)
		break ;;
	esac

	# fatal error when no value was provided
	if [ ! $empty_ok ] && { [ "$val" = "$1" ] || [ -z "$val" ]; }; then
		die "Missing value to option: $opt"
	fi

	shift
done

# Intelligent env-var detection and auto-loading:
vars_setup

# Register cleanup on EXIT
trap "cleanup" EXIT
# When SIGHUP, SIGINT, SIGQUIT, SIGABRT and SIGTERM,
# explicitly exit to signal EXIT (non-bash shells)
trap "exit 1" 1
trap "exit 2" 2
trap "exit 3" 3
trap "exit 6" 6
trap "exit 14" 15

# determine how we were called, then hand off to the function responsible
cmd="$1"
[ -n "$1" ] && shift # scrape off command
case "$cmd" in
	init-tls)
		init_tls "$@" || \
			die "Error: init_tls"
		;;
	build-tls-auth)
		build_tls_auth "$@" || \
			die "Error: build_tls_auth"
		;;
	build-tls-crypt)
		build_tls_crypt_v1 "$@" || \
			die "Error: build_tls_crypt_v1"
		;;
	build-tls-crypt-v2-server)
		build_tls_crypt_v2_server "$@" || \
			die "Error: build_tls_crypt_v2_server"
		;;
	build-tls-crypt-v2-client)
		build_tls_crypt_v2_client "$@" || \
			die "Error: build_tls_crypt_v2_client"
		;;
	save-id)
		save_id || \
			die "Error: save_id"
		;;
	status)
		status "$@" || \
			die "Error: status"
		;;
	inline-base)
		inline_base "$@" || \
			die "Error: inline_base"
		;;
	inline-tls-auth)
		inline_tls_auth "$@" || \
			die "Error: inline_tls_auth"
		;;
	inline-tls-crypt)
		inline_tls_crypt_v1 "$@" || \
			die "Error: inline_tls_crypt_v1"
		;;
	inline-tls-crypt-v2)
		inline_tls_crypt_v2 "$@" || \
			die "Error: inline_tls_crypt_v2"
		;;
	inline-remove)
		inline_remove "$@" || \
			die "Error: inline_remove"
		;;
	inline-renew)
		inline_renew "$@" || \
			die "Error: inline_renew"
		;;
	inline-show)
		inline_show "$@" || \
			die "Error: inline_show"
		;;
	inline-index-rebuild)
		inline_index_rebuild "$@" || \
			die "Error: inline_index_rebuild"
		;;
	inline-expire)
		inline_expire "$@" || \
			die "Error: inline_expire"
		;;
	cert-expire)
		cert_expire "$@" || \
			die "Error: cert_expire"
		;;
	d|disable)
		disabled_list_manager "disable" "$@" || \
			die "Error: disabled_list_manager"
		;;
	e|enable)
		disabled_list_manager "enable" "$@" || \
			die "Error: disabled_list_manager"
		;;
	disabled-list-rehash)
		disabled_list_manager "rehash" "$@" || \
			die "Error: disabled_list_manager rehash"
		;;
	import-key)
		import_key "$@" || \
			die "Error: import_key"
		;;
	version|-v|--version)
		easytls_version || \
			die "Error: easytls_version"
		exit 0
		;;
	""|help|-h|--help|--usage)
		cmd_help "$1" || \
			die "Error: cmd_help"
		exit 0
		;;
	*)
		die "Unknown command '$cmd'. Run without commands for help."
		;;
esac

# EasyTLS auto-check
inline_auto_check || die "Error: inline_auto_check"

# vim: ft=sh nu ai sw=8 ts=8 noet
