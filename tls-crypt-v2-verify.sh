#!/bin/sh

# Copyright - negotiable
copyright ()
{
cat << VERBATUM_COPYRIGHT_HEADER_INCLUDE_NEGOTIABLE
# tls-crypt-v2-verify.sh -- Do simple magic
#
# Copyright (C) 2020 Richard Bonhomme (Friday 13th of March 2020)
# https://github.com/TinCanTech/easy-tls
# tincanteksup@gmail.com
# All Rights reserved.
#
# This code is released under version 2 of the GNU GPL
# See LICENSE of this project for full licensing details.
#
# Acknowledgement:
# syzzer: https://github.com/OpenVPN/openvpn/blob/master/doc/tls-crypt-v2.txt
#
# Verify:
#   metadata version
#   metadata custom group
#   TLS key age
#   Identity (CA Fingerprint)
#   disabled list
#   Client certificate serial number
#     * via certificate revokation list (Default)
#     * via `openssl ca` (Not recommended)
#     * via openssl index.txt (Preferred)
#
VERBATUM_COPYRIGHT_HEADER_INCLUDE_NEGOTIABLE
}

# This is here to catch "print" statements
# Wrapper around printf - clobber print since it's not POSIX anyway
# shellcheck disable=SC1117
print() { printf "%s\n" "$1"; }

# Exit on error
die ()
{
	[ -n "$help_note" ] && printf "\n%s\n" "$help_note"
	printf "\n%s\n" "ERROR: $1"
	printf "%s\n" "https://github.com/TinCanTech/easy-tls"
	exit "${2:-255}"
}

# Tls-crypt-v2-verify failure, not an error.
fail_and_exit ()
{
	if [ $TLS_CRYPT_V2_VERIFY_VERBOSE ]
	then
		printf "%s " "$tls_crypt_v2_verify_msg"
		[ -z "$success_msg" ] || printf "%s " "$success_msg"
		printf "%s\n%s\n" "$failure_msg $md_name" "$1"

		printf "%s\n" \
			"* ==> version       local: $local_version"

		printf "%s\n" \
			"* ==> version      remote: $md_version"

		[ $TLS_CRYPT_V2_VERIFY_CG ] && printf "%s\n" \
			"* ==> custom_group  local: $TLS_CRYPT_V2_VERIFY_CG"

		[ $TLS_CRYPT_V2_VERIFY_CG ] && printf "%s\n" \
			"* ==> custom_group remote: $md_custom_g"

		printf "%s\n" \
			"* ==> identity      local: $local_identity"

		printf "%s\n" \
			"* ==> identity     remote: $md_identity"

		printf "%s\n" \
			"* ==> serial       remote: $md_serial"

		printf "%s\n" \
			"* ==> name         remote: $md_name"

		printf "%s\n" \
			"* ==> date         remote: $md_date"

		[ $2 -eq 1 ] && printf "%s\n" \
			"* ==> Client serial status: revoked"

		[ $2 -eq 2 ] && printf "%s\n" \
			"* ==> Client serial status: disabled"

		[ -n "$help_note" ] && printf "%s\n" "$help_note"

		printf "%s\n" "https://github.com/TinCanTech/easy-tls"
	else
		printf "%s %s %s %s\n" "$tls_crypt_v2_verify_msg" \
			"$success_msg" "$failure_msg" "$md_name"
	fi
	exit "${2:-254}"
} # => fail_and_exit ()

# Help
help_text ()
{
	help_msg='
  tls-crypt-v2-verify.sh

  This script is intended to be used by tls-crypt-v2 client keys
  generated by EasyTLS.  See: https://github.com/TinCanTech/easy-tls

  Options:
  help|-h|--help      This help text.
  -v|--verbose        Be a little more verbose at run time (Not Windows).
  -c|--ca=<path>      Path to CA *REQUIRED*
  -t|--tls-age        TLS Crypt V2 Key allowable age in days (default=1825).
                      To disable age check use --tls-age=0
  --verify-via-ca     Verify client serial number status via `openssl ca`
                      NOT RECOMMENDED
  --verify-via-index  Verify client serial number status via openssl index.txt
                      PREFERRED - This method does not require the script to
                      load openssl binary.
                      The default method is to verify client serial number
                      status is via the Certificate Revokation List.
  -g|--custom-group=<GROUP>
                      Also verify the client metadata against a custom group.
                      The custom group can be appended when EasyTLS generates
                      the tls-crypt-v2 client key by using:
                      easytls --custom-group=XYZ build-tls-crypt-v2-client
                      XYZ MUST be a single alphanumerical word with NO spaces.
  --cache-id          Use the saved CA ID from easytls.

  Exit codes:
  0   - Allow connection, Client key has passed all tests.
  1   - Disallow connection, client key has passed all tests but is REVOKED.
  2   - Disallow connection, serial number is disabled.
  3   - Disallow connection, local/remote Identities do not match.
  4   - Disallow connection, local/remote Custom Groups do not match.
  5   - Disallow connection, invalid metadata_version field.
  6   - Disallow connection, TLS key has expired.
  9   - BUG Disallow connection, general script failure.
  11  - ERROR Disallow connection, client key has invalid serial number.
  12  - ERROR Disallow connection, missing remote Identity.
  13  - ERROR Disallow connection, missing local Identity. (Unlucky)
  21  - USER ERROR Disallow connection, options error.
  22  - USER ERROR Disallow connection, failed to set --ca <path> *Required*.
  23  - USER ERROR Disallow connection, missing CA certificate.
  24  - USER ERROR Disallow connection, missing CRL file.
  25  - USER ERROR Disallow connection, missing index.txt.
  26  - USER ERROR Disallow connection, missing safessl-easyrsa.cnf.
  27  - USER ERROR Disallow connection, missing EasyTLS disabled list.
  28  - USER ERROR Disallow connection, missing openvpn server metadata_file.
  29  - USER ERROR Disallow connection, Invalid value for --tls-age.
  33  - USER ERROR Disallow connection, missing EasyTLS CA Identity file.
  121 - BUG Disallow connection, client serial number is not in CA database.
  122 - BUG Disallow connection, failed to verify CRL.
  123 - BUG Disallow connection, failed to verify CA.
  127 - BUG Disallow connection, duplicate serial number in CA database. !?
  253 - Disallow connection, exit code when --help is called.
  254 - BUG Disallow connection, fail_and_exit() exited with default error code.
  255 - BUG Disallow connection, die() exited with default error code.
'
	printf "%s\n" "$help_msg"

	# For secrity, --help must exit with an error
	exit 253
}

# Verify CA
verify_ca ()
{
	if [ $use_cache_id ]
	then
		return 0
	else
		openssl x509 -in "$ca_cert" -noout
	fi
}

# Local identity
fn_local_identity ()
{
	if [ $use_cache_id ]
	then
		printf "%s\n" "$ca_identity"
	else
		openssl x509 -in "$ca_cert" -noout -fingerprint | sed 's/ /_/g'
	fi
}

# Break metadata_string into variables
metadata_string_to_vars ()
{
	md_version="${1%-*.*}"
	md_identity="$2"
	md_serial="$3"
	md_name="$4"
	md_date="$5"
	md_custom_g="$6"
}

# Convert metadata file to metadata_string
metadata_file_to_metadata_string ()
{
	cat "$openvpn_metadata_file"
}

# Verify the age of the TLS key from metadata
verify_tls_key_age ()
{
	# Disable check if --tls-age=0 (Default age is 5 years)
	[ $tls_key_expire_age_seconds -eq 0 ] && return 0

	# current date
	local_date_sec=$(date +%s)

	# days since key creation
	key_age_sec=$(( local_date_sec - md_date ))
	key_age_day=$(( key_age_sec / (60*60*24) ))

	# Check key_age is less than --tls-age
	[ $key_age_sec -lt $tls_key_expire_age_seconds ] || return 1

	# Success message
	insert_msg="Key age $key_age_day days OK ==>"
	success_msg="$success_msg $insert_msg"
}

# verify serial number is hex only
# grep bug ? \+
allow_hex_only ()
{
	printf '%s' "$md_serial" | grep -q '^[[:xdigit:]]\+$'
}

# Check metadata client certificate serial number against disabled list
verify_serial_number_not_disabled ()
{
	# Search the disabled_list for client serial number
	client_disabled="$(fn_search_disabled_list)"
	case $client_disabled in
	0)
		# Client is not disabled
		return 0
	;;
	*)
		# Client is disabled
		insert_msg="client serial number is disabled:"
		failure_msg="$insert_msg $md_serial"
		return 1
	;;
	esac

	# Otherwise fail
	help_note="Check your disabled list: $disabled_list"
	insert_msg="client serial number failed disabled test:"
	failure_msg="$insert_msg $md_serial"
	return 1
}

# Search disabled list for client serial number
fn_search_disabled_list ()
{
	grep -c "^${md_serial}[[:blank:]]${md_name}$" \
		"$disabled_list"
}

# Verify CRL
verify_crl ()
{
	openssl crl -in "$crl_pem" -noout
}

# Decode CRL
fn_read_crl ()
{
	openssl crl -in "$crl_pem" -noout -text
}

# Search CRL for client cert serial number
fn_search_crl ()
{
	printf "%s\n" "$crl_text" | grep -c \
		"^[[:blank:]]*Serial Number: ${md_serial}$"
}

# Final check: Search index.txt for Valid client cert serial number
fn_search_index ()
{
	grep -c "^V.*[[:blank:]]${md_serial}[[:blank:]].*/CN=${md_name}.*$" \
		"$index_txt"
}

# Check metadata client certificate serial number against CRL
serial_status_via_crl ()
{
	client_cert_revoked="$(fn_search_crl)"
	case $client_cert_revoked in
	0)
		# Final check: Is this serial in index.txt
		case "$(fn_search_index)" in
		0)
		failure_msg="Serial number is not in the CA database:"
		fail_and_exit "SERIAL_NUMBER_UNKNOWN" 121
		;;
		1)
		client_passed_all_tests_connection_allowed
		;;
		*)
		die "Duplicate serial numbers: $md_serial" 127
		;;
		esac
	;;
	1)
		client_passed_all_tests_certificate_revoked
	;;
	*)
		insert_msg="Duplicate serial numbers detected: "
		failure_msg="$insert_msg $md_serial"
		die "Duplicate serial numbers: $md_serial" 127
	;;
	esac
}

# This is the only way to connect
client_passed_all_tests_connection_allowed ()
{
	insert_msg="Client certificate is recognised and not revoked:"
	success_msg="$success_msg $insert_msg $md_serial"
	success_msg="$success_msg $md_name"
	absolute_fail=0
}

# This is the only way to fail for Revokation
client_passed_all_tests_certificate_revoked ()
{
	insert_msg="Client certificate is revoked:"
	failure_msg="$insert_msg $md_serial"
	fail_and_exit "REVOKED" 1
}

# Check metadata client certificate serial number against CA
serial_status_via_ca ()
{
	# This is non-functional until openssl is fixed
	verify_openssl_serial_status

	# Get serial status via CA
	client_cert_serno_status="$(openssl_serial_status)"

	# Format serial status
	client_cert_serno_status="$(capture_serial_status)"
	client_cert_serno_status="${client_cert_serno_status% *}"
	client_cert_serno_status="${client_cert_serno_status##*=}"

	# Considering what has to be done, I don't like this
	case "$client_cert_serno_status" in
	Valid)
		client_passed_all_tests_connection_allowed
	;;
	Revoked)
		client_passed_all_tests_certificate_revoked
	;;
	*)
		die "Serial status via CA has broken" 9
	;;
	esac
}

# Use openssl to return certificate serial number status
openssl_serial_status ()
{
	# openssl appears to always exit with error - but here I do not care
	openssl ca -cert "$ca_cert" -config "$openssl_cnf" \
		-status "$md_serial" 2>&1
}

# Capture serial status
capture_serial_status ()
{
	printf "%s\n" "$client_cert_serno_status" | grep '^.*=.*$'
}

# Verify openssl serial status returns ok
verify_openssl_serial_status ()
{
	return 0 # Disable this `return` if you want to test
	# openssl appears to always exit with error - have not solved this
	openssl ca -cert "$ca_cert" -config "$openssl_cnf" \
		-status "$md_serial" || \
		die "openssl returned an error exit code" 101

# This is why I am not using CA, from `man 1 ca`
: << MAN_OPENSSL_CA
WARNINGS
       The ca command is quirky and at times downright unfriendly.

       The ca utility was originally meant as an example of how to do things
       in a CA. It was not supposed to be used as a full blown CA itself:
       nevertheless some people are using it for this purpose.

       The ca command is effectively a single user command: no locking is 
       done on the various files and attempts to run more than one ca command
       on the same database can have unpredictable results.
MAN_OPENSSL_CA
# This script ONLY reads, .:  I am hoping for better than 'unpredictable' ;-)
}

# Check metadata client certificate serial number against index.txt
serial_status_via_pki_index ()
{
	is_valid="$(fn_search_valid_pki_index)"
	is_revoked="$(fn_search_revoked_pki_index)"
	if [ $is_revoked -eq 0 ]
	then
		if [ $is_valid -eq 1 ]
		then
			client_passed_all_tests_connection_allowed
		else
			# Cert is not known
			insert_msg="Serial number is not in the CA database:"
			failure_msg="$insert_msg $md_serial"
			fail_and_exit "SERIAL_NUMBER_UNKNOWN" 121
		fi
	else
		client_passed_all_tests_certificate_revoked
	fi
}

# Final check: Search index.txt for Valid client cert serial number
fn_search_valid_pki_index ()
{
	grep -c \
	"^V.*[[:blank:]]${md_serial}[[:blank:]].*\/CN=${md_name}.*$" \
		"$index_txt"
}

# Final check: Search index.txt for Revoked client cert serial number
fn_search_revoked_pki_index ()
{
	grep -c \
	"^R.*[[:blank:]]${md_serial}[[:blank:]].*\/CN=${md_name}.*$" \
		"$index_txt"
}

# Initialise
init ()
{
	# Fail by design
	absolute_fail=1

	# metadata version
	local_version="easytls"

	# TLS expiry age (days) Default 5 years
	TLS_CRYPT_V2_VERIFY_TLS_AGE=$((365*5))

	# From openvpn server
	openvpn_metadata_file="$metadata_file"

	# Log message
	tls_crypt_v2_verify_msg="* TLS-crypt-v2-verify (crl) ==>"

	# Test certificate Valid/Revoked by CRL not CA
	test_method=1
}

# Dependancies
deps ()
{
	# CA_DIR MUST be set with option: -c|--ca
	[ -d "$CA_DIR" ] || die "Path to CA directory is required, see help" 22

	# CA required files
	ca_cert="$CA_DIR/ca.crt"
	ca_identity_file="$CA_DIR/easytls/easytls-ca-identity.txt"
	crl_pem="$CA_DIR/crl.pem"
	index_txt="$CA_DIR/index.txt"
	openssl_cnf="$CA_DIR/safessl-easyrsa.cnf"
	disabled_list="$CA_DIR/easytls/easytls-disabled.txt"

	# Ensure we have all the necessary files
	help_note="This script requires an EasyRSA generated CA."
	[ -f "$ca_cert" ] || die "Missing CA certificate: $ca_cert" 23

	if [ $use_cache_id ]
	then
	help_note="This script requires an EasyTLS generated CA identity."
	[ -f "$ca_identity_file" ] || \
		die "Missing CA identity: $ca_identity_file" 33

		ca_identity="$(cat "$ca_identity_file")"
	fi

	help_note="This script requires an EasyRSA generated CRL."
	[ -f "$crl_pem" ] || die "Missing CRL: $crl_pem" 24

	help_note="This script requires an EasyRSA generated DB."
	[ -f "$index_txt" ] || die "Missing index.txt: $index_txt" 25

	help_note="This script requires an EasyRSA generated PKI."
	[ -f "$openssl_cnf" ] || die "Missing openssl config: $openssl_cnf" 26

	help_note="This script requires an EasyTLS generated disabled_list."
	[ -f "$disabled_list" ] || \
		die "Missing disabled list: $disabled_list" 27

	# `metadata_file` must be set by openvpn
	help_note="This script can ONLY be used by a running openvpn server."
	[ -f "$openvpn_metadata_file" ] || \
		die "Missing: openvpn_metadata_file: $openvpn_metadata_file" 28
	unset help_note

	# Get metadata_string
	metadata_string="$(metadata_file_to_metadata_string)"

	# Populate metadata variables
	metadata_string_to_vars $metadata_string

	# Ensure that TLS expiry age is numeric
	# https://stackoverflow.com/a/3951175
	case $TLS_CRYPT_V2_VERIFY_TLS_AGE in
	''|*[!0-9]*)
	# Exit script with error code 29 and disallow the connection
	die "Invalid value for --tls-age: $TLS_CRYPT_V2_VERIFY_TLS_AGE" 29
	;;
	*)
	# maximum age in seconds
	tls_key_expire_age_seconds=$((TLS_CRYPT_V2_VERIFY_TLS_AGE*60*60*24))
	;;
	esac
}

#######################################

# Initialise
init


# Options
while [ -n "$1" ]
do
	# Separate option from value:
	opt="${1%%=*}"
	val="${1#*=}"
	empty_ok="" # Empty values are not allowed unless expected

	case "$opt" in
	help|-h|-help|--help)
		empty_ok=1
		help_text
	;;
	-v|--verbose)
		empty_ok=1
		TLS_CRYPT_V2_VERIFY_VERBOSE=1
	;;
	-c|--ca)
		CA_DIR="$val"
	;;
	-t|--tls-age)
		TLS_CRYPT_V2_VERIFY_TLS_AGE="$val"
	;;
	--verify-via-ca)
		empty_ok=1
		tls_crypt_v2_verify_msg="* TLS-crypt-v2-verify (ca) ==>"
		test_method=2
	;;
	--verify-via-index)
		empty_ok=1
		tls_crypt_v2_verify_msg="* TLS-crypt-v2-verify (index) ==>"
		test_method=3
	;;
	-g|--custom-group)
		TLS_CRYPT_V2_VERIFY_CG="$val"
	;;
	--cache-id)
		empty_ok=1
		use_cache_id=1
	;;
	*)
		die "Unknown option: $1" 253
	;;
	esac

	# fatal error when no value was provided
	if [ ! $empty_ok ] && { [ "$val" = "$1" ] || [ -z "$val" ]; }; then
		die "Missing value to option: $opt" 21
	fi

	shift
done


# Dependancies
deps


# Metadata Version

	# metadata_version Must equal 'metadata_version_easytls'
	case $md_version in
	"$local_version")
		success_msg="$md_version OK ==>"
	;;
	*)
		if [ -z "$md_version" ]
		then
			insert_msg="metadata version is missing."
		else
			insert_msg="metadata version is not recognised:"
		fi
		failure_msg="$insert_msg $md_version"
		fail_and_exit "METADATA_VERSION" 5
	;;
	esac


# Metadata custom_group

	# md_custom_g Must equal TLS_CRYPT_V2_VERIFY_CG
	if [ -n "$TLS_CRYPT_V2_VERIFY_CG" ]
	then
		if [ "$md_custom_g" = "$TLS_CRYPT_V2_VERIFY_CG" ]
		then
			insert_msg="custom_group $md_custom_g OK ==>"
			success_msg="$success_msg $insert_msg"
		else
			insert_msg="metadata custom_group is not correct:"
			[ -z "$md_custom_g" ] && \
				insert_msg="metadata custom_group is missing"

			failure_msg="$insert_msg $md_custom_g"
			fail_and_exit "METADATA_CUSTOM_GROUP" 4
		fi
	fi


# TLS Key expired

	# Verify key date and expire by --tls-age
	verify_tls_key_age || {
		max_age_msg="Max age: $TLS_CRYPT_V2_VERIFY_TLS_AGE days"
		key_age_msg="Key age: $key_age_day days"
		failure_msg="Key expired: $max_age_msg $key_age_msg ==>"
		fail_and_exit "TLS_KEY_EXPIRED" 6
		}


# Client certificate serial number

	# Non-empty, Hex only string accepted
	allow_hex_only || {
		failure_msg="Invalid: Client serial number"
		fail_and_exit "SERIAL_NUMBER_INVALID" 11
		}


# Identity

	# Using --cache-id openssl is not loaded here
	# Otherwise it is loaded twice

	# Verify CA
	# Load openssl (1) and verify the CA cert is valid
	verify_ca || die "Bad CA $ca_cert" 123

	# Local Identity
	# Load openssl (2) and return CA fingerprint
	local_identity="$(fn_local_identity)"

	# local_identity is required
	[ -z "$local_identity" ] && {
		failure_msg="Missing: local identity"
		fail_and_exit "LOCAL_IDENTITY" 13
		}

	# md_identity is required
	[ -z "$md_identity" ] && {
		failure_msg="Missing: remote identity"
		fail_and_exit "REMOTE_IDENTITY" 12
		}

	# Check metadata Identity against local Identity
	if [ "$local_identity" = "$md_identity" ]
	then
		insert_msg="identity OK ==>"
		success_msg="$success_msg $insert_msg"
	else
		failure_msg="identity mismatch"
		fail_and_exit "IDENTITY_MISMATCH" 3
	fi


# Disabled list

	# Check serial number is not disabled
	verify_serial_number_not_disabled || {
		failure_msg="Client is disabled"
		fail_and_exit "CLIENT_DISABLED" 2
		}


# Verify serial status
test_method=${test_method:-1}

	case $test_method in
	1)
		# Method 1
		# Check metadata client certificate serial number against CRL

		# Verify CRL
		# Load openssl (3) and verify the CRL is valid
		verify_crl || die "Bad CRL: $crl_pem" 122

		# Capture CRL
		# Load openssl (4) and return the CRL
		crl_text="$(fn_read_crl)"

		# Load openssl 4 times

		# Verify via CRL
		serial_status_via_crl
	;;
	2)
		# Method 2
		# Check metadata client certificate serial number against CA

		# Due to openssl being "what it is", it is not possible to
		# reliably verify the 'openssl ca $cmd'

		# Load openssl 3 times

		# Verify via CA
		# Load openssl (3) and return the serial status
		serial_status_via_ca
	;;
	3)
		# Method 3
		# Search openssl index.txt for client serial number
		# and return Valid, Revoked or not Known status
		# openssl is never loaded for this check
		serial_status_via_pki_index
	;;
	*)
		die "Unknown method for verify: $test_method" 9
	;;
	esac

# Any failure_msg means fail_and_exit
[ "$failure_msg" ] && fail_and_exit "NEIN" 9

# For DUBUG
[ "$FORCE_ABSOLUTE_FAIL" ] && absolute_fail=1 && \
	failure_msg="FORCE_ABSOLUTE_FAIL"

# There is only one way out of this...
[ $absolute_fail -eq 0 ] || fail_and_exit "ABSOLUTE_FAIL" 9

# All is well
[ $TLS_CRYPT_V2_VERIFY_VERBOSE ] && \
	printf "%s\n" "<EXOK> $tls_crypt_v2_verify_msg $success_msg"

exit 0
